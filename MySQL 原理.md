# MySQL 原理

# 初识 MySQL

MySQL 是种关系型数据库管理系统，用于存储和管理数据。MySQL 支持各种操作系统，不同平台的实现，目录结构和使用方式稍有不同，这里以类 UNIX 平台为例进行学习。

MySQL 基于 Client-Server 结构，服务端程序直接与存储的数据交互，接收请求，读写数据并进行相应的计算和处理，然后返回。客户端程序只是向服务端发送请求，同时接收和处理返回结果。

MySQL 的服务端程序和客户端程序都是计算机内的进程，代表服务端程序的进程，称为 MySQL 实例。

## 启动连接

MySQL 安装目录 *bin* 子目录，包含许多可执行文件，MySQL 的大多功能都可以通过这些文件进行使用。这里学习启动 MySQL 服务端/客户端的可执行文件。

### 启动服务器

**mysqld**

*mysqld* 可执行文件表示 MySQL 服务端程序，执行它启动一个 MySQL 实例。

**mysqld_safe**

*mysqld_safe* 是启动脚本，它会调用 *mysqld*，然后持续监控服务端程序的运行状态，如果发生错误，它能协助重启服务端程序。另外，它还会把出错信息和诊断信息写到错误日志。

错误日志是以 *.err* 为拓展名的文件，位于 MySQL 数据目录。

**mysql.server**

*mysql.server* 是启动脚本，它会调用 *mysqld_safe*，参数 *start* 表示启动服务端程序。

```
mysql.server start
```

参数 *stop* 表示关闭正在运行的服务端程序。

```
mysql.server stop
```

> *mysql.server* 其实是一个链接文件，对应的实际文件是 *BASE_DIR/support-files/mysql.server*。

**mysqld.multi**

*mysqld.multi* 脚本用于启动/关闭多个 MySQL 实例，或者报告它们的运行状态

### 客户端连接

**mysql**

*mysql* 表示 MySQL 客户端程序，用于发出请求和接收响应。

```
mysql -h主机地址 -P端口 -u用户名 -p密码
```

参数 *-h* 指定 MySQL 实例的主机地址，实例在本机可省。参数 *-P* 指定 MySQL 实例的端口，默认 3306。通常，短参和值之间可以有任意空白，但是 *-p* 不支持，因为密码可能以空白开头。

连接成功后，如果想断开连接并关闭客户端，可以使用 *quit* 或 *exit* 命令。

## 通信过程

### C/S 通信方式

MySQL 的客户端和服务端之间的交互，就是进程间的通信。进程通信最常见的方式是 TCP/IP 协议，这也是最常用的方式，只有这种方式需要 *-h* 和 *-P* 参数定位服务端。

对于 Windows 平台的实现，还支持命令管道和共享内存的通信方式，类 UNIX 平台的实现，还支持 UNIX 域套接字通信方式。

### 请求处理过程

以查询请求为例，说明 MySQL 服务端处理客户端请求的过程。

**管理连接**

MySQL 支持同时处理多个客户端连接，每个连接使用一个线程维护，并且，客户端断开连接后，维护连接的线程不会销毁，而是保存起来等待处理下个连接。MySQL 使用线程池处理客户端连接。因为线程池的大小有限，必要时 MySQL 会拒绝客户端的连接请求。

客户端发出的连接请求，需要携带主机、用户名、密码等信息，服务端进行认证，认证失败则拒绝连接，认证成功则会为这个连接维护一堆数据，比如 Session 系统变量。

连接成功之后，服务端线程如果长时间没有收到客户端的请求，将自动断开连接。

**查询缓存**

MySQL 基于文本缓存返回成功的查询请求，查询缓存全局共享。每收到一个查询请求，首先都会尝试从缓存查找结果。请求与缓存即使含义相同，只要有任何字符差异，比如空格、注释、大小写，都会导致不命中缓存。如果有使用某些系统函数、用户自定义变量、函数，则无法使用查询缓存，返回的结果也不会被缓存，因为这些元素的值动态变化。

MySQL 缓存机制会监视涉及的表，如果表的结构或数据被修改，那么这个表相关的查询缓存都会失效。

> 查询缓存虽然可以提升性能，但是维护这块缓存也带来一些消耗，从 MySQL 5.7.20 开始，就不推荐使用查询缓存，MySQL 8.0 甚至直接移除查询缓存。

**语法解析**

缓存没有命中，就要进入查询阶段。查询请求本质就是文本，主要元素是  SQL 命令。服务端在此对 SQL 语句进行分析，检查语法是否正确，再把涉及的表、查询条件提取出来，放到内部的数据结构，以供后续使用。

**查询优化**

服务端已经得到必要的信息，比如要查找的表和列、搜索条件，根据这些足以精确查找数据。不过，MySQL 认为用户编写的 SQL 语句在 MySQL 的执行效率不一定高，需要进行一些优化，比如把外连接转换为内连接、子查询转换为连接、表达式简化。

优化结果是一个执行计划，计划表明应该使用哪些索引执行查询，以及表间的连接顺序。使用 `explain` 命令可以查看某个查询语句的执行计划。

**调用存储引擎**

为了管理方便，MySQL 把服务端分为 Server 层和存储引擎，前面的步骤都在 Server 层执行，现在，Server 根据执行计划，调用存储引擎的接口，获取数据，然后返回给客户端。

连接管理、查询缓存、语法解析、查询优化都属于 Server 层的动作，存储引擎负责读写数据。Server 层和存储引擎的交互，常以记录为单位。当然，记录不会直接返回给客户端，而是放在一个缓冲区，等到缓冲区满后，再执行发送。缓冲区的大小由系统变量 `net_buffer_length` 控制。

## 存储引擎

MySQL 把数据的存储和提取操作封装到"存储引擎"模块。数据表由一行一行的记录组成，这是逻辑概念，底层如何组织数据，则由存储引擎决定。MySQL 提供许多存储引擎实现，使用不同存储引擎的表，存储结构不同，支持的功能也不同，比如 InnoDB 表支持事务、外键、行级锁，这些功能 MyISAM 表都没有。

存储引擎都基于相同的接口设计，所以不论使用哪种存储引擎，Server 层的调用方式不变。

MySQL 从 5.5.5 开始以 InnoDB 作为默认存储引擎，之前一直都是 MyISAM。

**相关命令**

查看可用的存储引擎列表。

```
show engines;
```

查看默认存储引擎。

```
show variables like 'default_storage_engine';
```

创建表时指定存储引擎。

```
create table 表名 (
	...
) engine = 存储引擎;
```

修改已存在表的存储引擎。

```
alter table 表名 engine = 存储引擎;
```

# MySQL 配置

MySQL 的服务端和客户端都有许多可配置参数，用于修改程序的运行逻辑。比如，MySQL 服务端可以修改最大客户端连接数，默认 151。这些参数，可以在执行启动脚本时设置，有命令行、配置文件两种设置方式。

## 命令行

使用启动脚本的命令行参数设置 MySQL 参数，有两种格式，长格式 `--option=value` 中间不能有空白字符，短格式 `-option value` 的名和值之间可以有任意空白字符，密码 `-p` 除外。

示例，设置 MyISAM 作为默认存储引擎。

```
mysql.server start --default_storage_engine=MyISAM;
```

示例，设置禁用 TCP/IP 网络通信。

```
mysql.server start --skip-networking;
```

## 配置文件

命令行参数只影响此次运行，每次启动都需要添加相同的参数，否则又会使用默认配置，比较麻烦。MySQL 启动时会加载一些配置文件，这些文件包含 MySQL 参数。可以修改配置文件，以持久地配置参数。

**配置文件的路径**

执行 MySQL 启动脚本，将依次从以下路径加载配置文件。

| 路径                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| *default-file*        | 这是一个命令行参数，指定只加载某个配置文件，忽略其它配置文件。 |
| *ect/my.cnf*          |                                                              |
| *etc/mysql/my.cnf*    |                                                              |
| *SYSCONFDIR/my.cnf*   | SYSCONFDIR 是用 CMake 构建 MySQL 时，SYSCONFDIR 参数指定的目录。 |
| *$MYSQL_HOME/my.cnf*  | 只有服务端相关的参数。MYSQL_HOME 是环境变量，使用 *mysqld_safe* 脚本启动服务，如果没有配置 SYSCONFDIR，它默认是 MySQL 的安装目录。 |
| *defaults-extra-file* | 这是一个命令行参数，指定额外的配置文件的路径。               |
| *~/.my.conf*          |                                                              |
| *~/.mylogin.cnf*      | 只有客户端相关的参数。                                       |

**配置文件的格式**

配置文件的 MySQL 参数被分为多个组，每个组以 `[组名]` 开始，如下所示。

```
[server]
option1 = value1
option2 = value2
...

[mysqld]
option3 = value3
option4 = value4
...
```

每个 MySQL 参数独占一行，等号 `=` 周围可以有空白字符，还能使用 `#` 添加注释。

每个分组，只会被同名的启动脚本加载，比如，*mysql.server* 加载 `[mysql.server]` 的内容。不过，有两个分组比较特别：

* `[server]` 分组的参数作用于所有的服务端程序。
* `[client]` 分组的参数作用于所有的客户端程序。

因为 *mysql.server* 调用 *mysqld_safe*，而 *mysqld_safe* 调用 *mysqld*，所以它们都会加载 `[mysqld]` 分组。

还能在分组名的尾部追加 MySQL 版本号，限定这个分组只在特定版本生效，比如 `[server-5.7]`。

**配置分组的优先级**

不同配置文件，按照加载顺序，后面文件的参数的优先级更高。相同配置文件，不同分组按照上下顺序，后面分组的参数的优先级更高。

另外，配置文件的优先级始终低于命令行，而且，有的启动参数只能在命令行设置，比如 defaults-file。

**限制单个配置文件**

使用命令行参数 *default-file* 指定某个配置文件的路径，脚本将只加载这个配置文件，跳过其它配置文件，如果文件不存在或无法访问，将会发生错误。

# MySQL 变量

## 系统变量

MySQL 程序运行时会使用许多变量，它们决定着程序的运行，称为系统变量。

**系统变量的作用域**

每个客户端连接可能想有不同的行为，为此，系统变量有作用范围之分：

* `GLOBAL`：决定服务端的整体操作。
* `SESSION`：决定客户端连接的操作。

服务端程序启动时，把所有全局变量初始化为默认值。服务端会为每个客户端连接维护一组会话变量，这些会话变量在建立连接时使用相应的全局变量进行初始化。

并非所有系统变量都有 `GLOBAL` 和 `SESSION` 作用域，有的变量只有 `GLOBAL`，比如 max_connections，而有的变量只有 `SESSION`，比如 insert_id，它是某个 auto_increment 列的初始值。

**设置系统变量**

系统变量都有默认值，可以使用 MySQL 参数（命令行，或配置文件）修改变量的默认值，大多系统变量还支持运行时修改。系统变量和 MySQL 参数不是对应关系，有的系统变量只读，有的 MySQL 参数也不影响系统变量。

```
set [global|session] 变量 = 值
```

```
set [@@(global|session).]变量 = 值
```

修改全局系统变量的值之后，新值将作用于后面建立的客户端连接，已有连接的会话变量不会有改变。若要影响当前连接，只能通过修改它的会话变量。

**查看系统变量**

默认查看会话范围，除非指定 `GLOBAL` 或这个变量没有会话范围。

```
show [global|session] variables like '匹配模式';
```

## 状态变量

状态变量类似系统变量，它的作用是描述服务端程序当前的运行状态，可以把它看作只读的系统变量。而且，状态变量也有 `GLOBAL` 和 `SESSION` 作用范围。

```
show [global|session] status like '匹配模式';
```

# 字符集和比较规则

文本数据必须指定其使用的字符集，否则只是没有意义的二进制编码。比较规则用于排序数据等用途，每种字符集都有多种比较规则，有的比较规则不区分大小写，有的比较直接使用二进制编码。

## 数据的字符集

查看 MySQL 可用的字符集，任何与"字符集"相关的命令，基本都可以使用"charset"替换"character set"。 

```
show (character set|charset) like '匹配模式';
```

每种字符集都有多种比较规则，在 MySQL，比较规则的名字都由下划线连接的 3 个部分组成，第一个部分表示对应的字符集，第二个部分是规则所用的语言，第三个部分表示是否区分语言中的重音、大小写等。

| 后缀（第三部分） | 说明             |
| ---------------- | ---------------- |
| _ai              | 不区分重音       |
| _as              | 区分重音         |
| _ci              | 不区分大小写     |
| _cs              | 区分大小写       |
| _bin             | 以二进制方式比较 |

查看 MySQL 可用的比较规则。

```
show collation like '匹配模式';
```

## 分级的字符集

MySQL 可在 4 个层级设置字符集和比较规则：服务器、数据库、表，列。

**服务器级别**

MySQL 提供两个系统变量，表示服务器级别的字符集和比较规则。

| 系统变量             | 说明     |
| -------------------- | -------- |
| character_set_server | 字符集   |
| collation_server     | 比较规则 |

**数据库级别**

创建数据库时指定字符集和比较规则，默认使用服务器级别的设置。

```
create database 数据库名
	[default] charset 字符集
	[collate 比较规则];
```

修改已有数据库的字符集和比较规则。

```
alter database 数据库名
	[[default] charset 字符集名]
	[collate 比较规则名];
```

可以使用两个只读的系统变量，查看当前连接的数据库的字符集和比较规则。

| 系统变量               | 说明     |
| ---------------------- | -------- |
| character_set_database | 字符集   |
| collation_database     | 比较规则 |

**表级别**

创建表时指定字符集和比较规则，默认使用数据库级别的设置。

```
create table 表名
	[[default] charset 字符集名]
	[collate 比较规则名];
```

修改已有表的字符集和比较规则。

```
alter table 表名
	[[default] charset 字符集名]
	[collate 比较规则名];
```

**列级别**

创建表时指定列的字符集和比较规则，默认使用表级别的设置。

```
create table 表名 (
	列名 字符串类型 [charset 字符集名] [collate 比较规则名]),
	其它列...
);
```

修改已有表的列的字符集和比较规则。

```
alter table 表名 modify 列名 字符串类型 [charset 字符集名] [collate 比较规则名]);
```

## 通信的字符集

客户端发送给服务端的数据，以及服务端返回给客户端的数据，其实都是文本，需要进行编码、解码，甚至转码。

**建立网络连接**

MySQL 客户端通常使用与操作系统一致的字符集。对于 UNIX 平台，LC_ALL、LC_CTYPE、LANG 这 3 个环境变量决定着操作系统使用哪种字符集，优先级依次递减，如果都没有配置，系统就使用默认的字符集。

MySQL 客户端向服务端请求连接时，把字符集和用户名、密码等信息一同发出。服务端收到连接请求，根据客户端的字符集，为这个连接维护 3 个可写的会话变量：

* character_set_client：服务端解码请求时使用的字符集。
* character_set_connection：服务端把请求转码为这个字符集再进行处理。
* character_set_results：服务端向客户端返回数据时使用的字符集。

以下命令为这三个变量统一设置相同的值，这是一个语法糖。

```
set names 字符集名;
```

**客户端的编码**

客户端接收用户的输入，使用初始设置的字符集进行编码，然后发出。

**服务端的处理**

服务端收到请求，按照 MySQL 协议进行解析，使用 character_set_client 解码请求语句，得到请求原语。然后把数据转码为 character_set_connection 进行处理。中途转码，因为相同数据在不同的字符集和比较规则可能有不同的结果。

值和列进行比较，如果两边的字符集不同，将把值转码为列的字符集，并使用列的比较规则进行比较。

**返回响应结果**

计算出结果，使用 character_set_results 对其转码，然后返回给客户端。类 UNIX 平台，*mysql* 脚本会直接打印返回结果，如果是自制的客户端程序，还能做更多处理，至少可以转码。

# InnoDB 记录行格式

存储引擎 InnoDB 把数据存到磁盘，记录在磁盘的存储格式称为行格式。InnoDB 支持 4 种行格式：COMPACT、REDUNDANT、DYNAMIC、COMPRESSED。其它存储引擎也有使用行格式，它们的实现大同小异。

创建表时指定行格式。

```
create table 表名 (
	...
) row_format = 行格式;
```

修改已有表的行格式。

```
alter table 表名 row_format = 行格式;
```

## COMPACT

对于 COMPACT 行格式，可以把它的结构分为两个部分：额外信息、真实数据。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-dfb7387d.png)

**变长字段长度列表**

MySQL 支持变长数据类型，比如 `varchar(M)`，这种字段的大小不固定，所以行格式需要记录它们真正占用的空间大小。变长字段长度列表，按照逆序保存各个变长字段的字节数。

每个长度使用 1 或 2 个字节，如果字段可能达到的最大长度超过 255 字节，并且真实数据超过 127 字节，就使用两个字节，否则使用 1 个字节。

如果字段的内容特别大，COMPACT 将把这个字段的部分数据存到溢出页，长度列表只记录本地的数据的长度。

如果没有变长类型字段，或者所有列的值都是 `null`，行格式就不会有变长字段长度列表。

**NULL 值列表**

COMPACT 使用 NULL 值列表标记值为 `null` 的字段，真实数据处则不必存 `null` 值，节省空间。NULL 值列表的设置过程可以分为以下 3 步：

* 如果没有允许值为 `null` 的列，行格式不会有 NULL 值列表。
* 每个允许值为 `null` 的列，都对应一个二进制位，这些位按逆序存到 NULL 值列表。
* NULL 值列表必须占用整数个字节，如果有多的位，高位补零。

**记录头信息**

固定占用 5 个字节，它的 40 个二进制位分为多个部分，分别有不同的含义。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-5fa9ebde.png)

| 名字         | 大小   | 说明                                                         |
| ------------ | ------ | :----------------------------------------------------------- |
| 预留位1      | 1 bit  | 没有使用                                                     |
| 预留位2      | 1 bit  | 没有使用                                                     |
| delete_mask  | 1 bit  | 标记当前记录是否被删除                                       |
| min_rec_mask | 1 bit  | 标记 B+ 树每层最小非叶结点，即每层最小目录项记录             |
| n_owned      | 4 bit  | 记录代表的分组包含的记录数，这条记录的偏移量就是槽           |
| heap_no      | 13 bit | 记录在页面堆的序号                                           |
| record_type  | 3 bit  | 记录的类型，0 普通记录，1 目录项记录，2 最小记录，3 最大记录 |
| next_record  | 16 bit | 下一条记录的真实数据的相对位置                               |

**真实数据**

除了表示用户数据的列，InnoDB 还会为记录添加一些列，即隐藏列。比如，InnoDB 表必须有主键，如果用户没有定义主键，就选一个值不允许为 `null` 的 `unique` 列作为主键，如果没有这样的列，那就生成 db_row_id 列作为主键。

| 隐藏列      | 必需 | 大小   | 说明                            |
| ----------- | ---- | ------ | ------------------------------- |
| db_row_id   | 否   | 6 byte | 记录 ID，表内唯一标识一条记录。 |
| db_trx_id   | 是   | 6 byte | 事务 ID                         |
| db_roll_ptr | 是   | 7 byte | 回滚指针                        |

COMPACT 对 `char(M)` 字段的处理有些特殊。如果字符集对每个字符都固定使用 N 个字节编码，那么这个字段固定占用 M*N 个字节，空闲空间空格补齐。如果字符集是变长编码，COMPACT 就把它视为变长字段，需要记录真实数据的长度，这个字段至少占用 M 个字节，这能减少空间的再分配，降低空间碎片的产生概率。

## REDUNDANT

MySQL 5.0 使用 REDUNDANT 作为默认的行格式。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-204eab88.png)

字段长度偏移量是列的值在真实数据的结束位置，这样就能使用两个相邻的偏移量来计算列值长度。

记录头信息固定占用 6 个字节，相比于 COMPACT，它没有 record_type 属性，另外多出两个属性。

| 名字            | 大小  | 说明                              |
| --------------- | ----- | --------------------------------- |
| n_field         | 4 bit | 列的数量                          |
| 1byte_offs_flag | 1 bit | 使用 1 或 2 个字节保存 1 个偏移量 |

REDUNDANT 根据记录的真实数据总的大小来设置使用 1 或 2 个字节保存偏移量：

* 如果真实数据的总字节数小于 127，每个偏移量占用 1 字节。
* 如果总字节数大于 127，但不大于 32767，每个偏移量占用 2 字节。
* 如果总字节数超过 32767 字节，把部分数据放到溢出页。

REDUNDANT 使用偏移量的第 1 个位表示对应的列是否为 `null`，定长类型即使为 `null` 也占用固定大小，变长类型如果为 `null`，则不占用空间。

对于 `char(M)` 字段，不论什么字符集，REDUNDANT 固定使用 N*M 个字节。可以看出，REDUNDANT 组织数据的方式比较简单，因此使用的空间比 COMPACT 多得多。

## 其它行格式

DYNAMIC、COMPRESSED 和 COMPACT 非常相似，但在处理溢出列时稍有不同，它们不会在当前页保留溢出列的任何数据，即溢出列的所有内容都在溢出页，列值是溢出页的地址。

另外，COMPRESSED 还会对页面进行压缩，节省空间。

## 溢出列结构

记录存于页内，页是一种数据结构，它的大小有限，所以每个页的记录也有限。如果某个列的值非常大，超出页的限制，就需要使用溢出页，这个列称为溢出列。

COMPACT 和 REDUNDANT 会在当前页保存溢出列的部分数据，而 DYNAMIC 和 COMPRESSED 则是把溢出列的全部内容都放到溢出页。不过，它们都会在列值处使用 20 个字节记录溢出页的地址。

溢出的数据可能需要使用多张溢出页，这些页连成一个单向链表，溢出列保存的是头结点页的地址。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-b9dcdf86.png)

# InnoDB 的 index 页

## 页和 index 页

页是 InnoDB 管理存储空间的基本单位，即使读取一条记录，也会加载整个页面。当数据量较大时，还会使用更大范围的区。

页有许多种类型，这里学习用于存储索引的 index 页。由于 InnoDB 是 "数据即索引"，所以，index 页又被成为数据页。默认 index 页的大小是 16KB，它的结构如下所示。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-045e3256.png)

| 名字               | 名字           | 大小    | 说明                         |
| ------------------ | -------------- | ------- | ---------------------------- |
| File Header        | 文件头部       | 38 byte | 页的通用信息                 |
| Page Header        | 页面头部       | 56 byte | index 页专门信息             |
| Infimum + Supremum | 最小和最大记录 | 26 byte | 两条虚拟记录                 |
| User Records       | 用户记录       | 不确定  | 真正的表记录                 |
| Free Space         | 空闲空间       | 不确定  | 页中尚未使用的空间           |
| Page Directory     | 页目录         | 不确定  | 某些记录的相对位置（页目录） |
| File Trailer       | 文件尾部       | 8 byte  | 校验页是否完整               |

## 页的用户记录

表示用户数据的记录在页的 User Records 部分，页初始时没有任何记录，自然也没有 User Records 部分，后面每向页插入一条记录，就要从 Free Space 划分一些空间到 User Records 部分，如果没有空闲空间，就需要申请新的 index 页。

页存储记录时，需要使用行格式的"记录头信息"，这里以 COMPACT 为例进行学习。

**delete_mask**

当 delete_mask 为 1 时，表示这条记录被删除，由此可见，MySQL 的 delete 操作是逻辑删除，因为真正地把数据从磁盘删除，需要重新排列剩余的数据，这会严重影响 delete 的性能。

所有被删除的记录，使用记录头信息的 next_record 属性组成一条单向链表，后面插入的新记录，可能会回收使用这些垃圾空间。

**heap_no**

用户记录都在 User Records 部分，紧密排列，InnoDB 把这种结构称为堆。记录头信息 heap_no 属性表示记录在堆内的序号，即这是页的第几条记录，从 0 开始，按 1 迭代。

注意，用户记录的 heap_no 属性从 2 开始，因为页初始会添加两条虚拟记录：最小记录、最大记录。记录根据主键比较大小。

记录一旦设置 heap_no 成功，值就不可变，即使记录被删除，这个值也不会被赋给其它记录。

**next_record**

记录使用 next_record 属性，按照主键升序，组成一条单向链表，且以 Supremum 作为头结点，Infimum 作为尾结点。这个 next_record 属性，表示当前记录的真实数据，距离下一条记录的真实数据多少个字节，正值表示下一条记录在当前记录的后面。

## 页目录 Page Directory

页目录用于优化根据键值的查询命令，非常重要。已知所有记录按照升序组成单向链表，根据键值查找记录，最简单的方式就是遍历记录链表，性能很低，明显不靠谱。

为此，index 页把记录链表截成多个组，每组的最后一个结点是该组的最大记录。然后，把每组的最后一条记录的偏移量提取出来，逆序存放在靠近页尾的地方，这就是页目录。这些偏移量称为槽，每个槽占用 2 字节。

现在，根据键值查找记录的命令，将按以下步骤执行：

* 二分查找，不断迭代，确定目标记录所在分组的槽。
* 根据前一个槽，遍历目标槽的所有记录，直到找到目标记录。

这样，根据键值的查询的效率将大大提升，即把遍历整个链表，优化为遍历一个子链。

InnoDB 规定，Infimum 分组只有一条记录，其它分组的记录在 4~8 条之间，所以页目录至少有两个槽。新的记录会加入键值比它大，且差值最小的槽所代表的分组，如果分组的记录数达到 8，则把它一分为二，新增一个槽。

## 页头部 Page Header

占用 56 个字节，存储 index 页的状态信息。

| 状态                | 大小    | 说明                                               |
| ------------------- | ------- | -------------------------------------------------- |
| PAGE_N_DIR_SLOTS    | 2 byte  | 页中槽的数量                                       |
| PAGE_HEAP_TOP       | 2 byte  | 空闲空间 Free Space 的开始地址                     |
| PAGE_N_RECS         | 2 byte  | 页的记录数量，只是未被删除的"用户记录"             |
| PAGE_N_HEAP         | 2 byte  | 页的记录数量，包括最小、最大和删除的记录           |
| PAGE_FREE           | 2 byte  | 第一条标记删除的记录的地址，即垃圾链表头结点的地址 |
| PAGE_GARBAGE        | 2 byte  | 删除的记录总的字节数                               |
| PAGE_LAST_INSERT    | 2 byte  | 最近插入记录的位置                                 |
| PAGE_DIRECTION      | 2 byte  | 最新一条记录的插入方向                             |
| PAGE_N_DIRECTION    | 2 byte  | 相同方向的连续插入次数                             |
| PAGE_MAX_TRX_ID     | 8 byte  | 修改当前页的最大事务 ID，只在二级索引设置          |
| PAGE_INDEX_ID       | 8 byte  | 索引 ID，表示当前页属于哪个索引                    |
| PAGE_LEVEL          | 2 byte  | 页在 B+ 树的层级，最低 1 是叶结点                  |
| PAGE_BTR_SEG_LEAF   | 10 byte | B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义    |
| PAGE_BTR_SEG_TOP 10 | 10 byte | B+ 树非叶子段的头部信息，仅在 B+ 树的 Root 页定义  |

**插入方向**：插入的记录如果比上一条插入的记录大，它的插入方向是右边，否则是左边。

## 页的通用部分

前面的部分都是 index 页特有的内容，File Header 和 File Trailer 是任何类型的页都有的通用内容。

### 文件头 File Header

占用 38 字节，保存页的各种通用信息。每个页都有一个表空间内唯一的页号，用于标识和快速定位，它占用 4 个字节，第一个页的页号是 0，所以表空间的页的数量有限。有些页支持组成链表，比如 Index 页，这些页只是逻辑连接，不需物理相邻。

| 状态                             | 大小   | 说明                                                         |
| -------------------------------- | ------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4 byte | 页的校验和，版本 4.0.14 以前表示表空间 ID                    |
| FIL_PAGE_OFFSET                  | 4 byte | 页号                                                         |
| FIL_PAGE_PREV                    | 4 byte | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4 byte | 下一个页的页号                                               |
| FIL_PAGE_TYPE                    | 2 byte | 页的类型                                                     |
| FIL_PAGE_LSN                     | 8 byte | 页最近一次修改时对应的 LSN 值                                |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 byte | 只在系统表空间的第一个页定义，表示文件至少被刷新到这个 LSN 值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 byte | 页所属的表空间                                               |

**FIL_PAGE_OFFSET**

页号用于在表空间内唯一定位一个页，每个页都有页号。

**FIL_PAGE_SPACE_OR_CHKSUM**

页的校验和。所谓校验和，就是使用算法，对字符串计算出一个较短的结果，如果两条字符串的校验和不同，那它们肯定不相等。

**FIL_PAGE_TYPE**

页的类型，索引页是 FIL_PAGE_INDEX，溢出页是 FIL_PAGE_TYPE_BLOB。

**FIL_PAGE_PREV 和 FIL_PAGE_NEXT**

如果表很大，可能需要多个页保存它的数据，FIL_PAGE_PREV 和 FIL_PAGE_NEXT 属性把这些页串联起来，组成双向链表。并非所有类型的页都有使用这两个属性，但 index 页有用。

### 文件尾 File Trailer

占用 8 个字节，用于校验页的完整性。前 4 个字节是页的校验和，与 File Header 的校验和对应，后 4 个字节是页最近一次修改时的 LSN 值，与 File Header 的 LSN 对应。File Header 在页的前面，会先被刷盘，如果没有发生意外，File Trailer 的这两个属性应该与 File Header 一致，除非发生错误，导致 File Trailer 没有被更新。

# MySQL 数据目录

像 InnoDB、MyISAM 这类存储引擎会把数据持久化，数据的存放位置是**数据目录**，这个目录的路径对应一个系统变量 "datadir"，类 UNIX 平台默认 */usr/local/var/mysql*。

```
show variables like 'datadir';
```

## 通用结构

**数据库目录**

每个数据库都对应数据目录下的一个同名子目录，每个数据库子目录都有一个 *db.opt* 文件，这个文件保存数据库的一些元数据，比如字符集、比较规则。

**表结构文件**

数据表的信息分为结构定义和用户记录，前者包含表名、字符集、比较规则这些元数据，InnoDB、MyISAM 会为每个表创建一个的同名文件，后缀 *.frm*，放在数据库子目录，这个文件以二进制格式存储表结构信息。

至于用户记录，各个存储引擎使用不同的方式进行存储。

## 数据存储

### InnoDB 表空间

InnoDB 使用表空间管理 index 页。表空间是一个抽象概念，对应文件系统上的一个或多个文件，可以把它看作数据页的集合，表的数据存放在某个表空间下的某些页。有多个类型的表空间。

**系统表空间**

默认情况，InnoDB 将在数据目录创建一个文件，名为 *ibdata1*，大小 12MB，它是系统表空间的实现。这么点大当然不够，这个文件能够进行自扩展。

通过配置参数，可以指定系统表空间对应多个文件，以及这些文件的名字、自扩展性等。以下配置，MySQL 启动之后将会创建两个 512M 大小的文件作为系统表空间，关键字 autoextend 表示 *data2* 允许自扩展。

```
[server]
innodb_data_file_path=data1:512M;data2:512M:autoextend
```

> 系统表空间还可以配置放在其它目录，不多赘述。

每个 MySQL 实例只有一份系统表空间，版本 5.5.7 至 5.6.6，InnoDB 默认把表的数据存到系统表空间。

**独立表空间**

MySQL 5.6.6 以及之后，InnoDB 会为每个表创建一个独立表空间，表的数据默认被存放到对应的独立表空间而非系统表空间。每个表的独立表空间对应一个数据库子目录下的与表同名的文件，后缀 *.ibd*。

通过配置参数 `innodb_file_per_table` 指定数据保存到系统表空间，默认值 1 表示使用独立表空间，修改参数只对新建的表起作用。

```
[server]
innodb_file_per_table=0
```

把表的数据从系统表空间转移到独立表空间。

```
alter table 表名 tablespace [=] innodb_file_per_table;
```

把表的数据从独立表空间转移到系统表空间。

```
alter table 表名 tablespace [=] innodb_system;
```

**其它表空间**

通用表空间，undo 表空间，临时表空间，等等。

### MyISAM 表文件

MySQL 会在数据库子目录下为每个 MyISAM 表创建两个同名文件，后缀 *.MYD* 存放数据，后缀 *.MYI* 存放索引。

## 系统数据库

MySQL 初始自带几个数据库，它们包含服务程序运行需要的数据，以及一些运行状态信息：

* **mysql**

  重要核心，包含用户账户和权限信息，某些存储过程和事件、运行日志、帮助信息，以及时区信息，等等。

* **information_schema**

  服务器维护的所有其它数据库的元数据，比如有哪些表、哪些列，哪些索引，这个库没有对应的子目录。

* **performance_schema**

  服务器运行过程中的一些状态信息，包括最近执行的语句，执行过程每个阶段的耗时，内存使用情况，等等。

* **sys**

  以视图的形式把 information_schema 和 performance_schema 结合起来，综合展示服务器运行状态。

# InnoDB 的表空间

## 独立表空间

独立表空间的结构更加简单，系统表空间还要额外包含一些关于整个系统的信息。

### 区和段的概念

**区的概念**

表空间可以有很多个页，为了管理大量的页，InnoDB 提出区的概念。对于 16KB 大小的页，区由 64 个连续的页组成，因此，区默认 1MB 大小。独立表空间和系统表空间，都能看作由若干个连续的区组成。

每 256 个区划分为一组，并且，表空间第一个组的前 3 个页，以及其它组的前两个页的页面类型固定。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-5476262f.png)

FSP_HDR 保存本组所有区的属性和表空间的整体属性，每个表空间只有第一个页是这种类型；IBUF_BITMAP 保存 Change Buffer 相关信息；INODE 保存 INODE Entry 数据结构；XDES 保存本组所有区的属性。

**段的概念**

扫描 B+ 树，InnoDB 首先根据条件定位到一条用户记录，然后沿着记录链表和页面链表向后遍历。如果叶结点页比较分散，遍历会产生大量随机 I/O，降低性能。所以，应该尽量让链表相邻的页同时物理相邻，这样就能在遍历时使用顺序 I/O。区的作用就是如此，它的页都物理相邻，页号连续，如果表的数据量很大，InnoDB 就会按区来为索引分配空间，甚至一次性分配多个连续的区。这可能造成浪费，因为数据往往不能完全填充整个区，但能有效减少随机 I/O。

只有叶结点才会被遍历，如果把叶结点和非叶结点混放，遍历效果将大打折扣。所以，InnoDB 使用不同的区来存储叶结点和非叶结点。存放叶结点的区是一个段，存放非叶结点的区是另一个段。每个索引都有两个段，即叶结点段和非叶结点段。

其实，段不是一开始就直接分配完整的区，这对数据量较小的索引来说非常浪费，而是先从碎片区按页来分配存储空间，当段占用 32 个页之后，再以区为单位分配，前面获得的碎片页保留，其中的数据也不会转移。所以，**段是零散的页和一些完整的区的集合**。

### 区和段的结构

**区的状态**

表空间的区有 4 种状态，除了 FSEG，其它状态的区都直属表空间管理。

| 状态      | 说明                                               |
| --------- | -------------------------------------------------- |
| FREE      | 空闲的区，页都没有被使用                           |
| FREE_FRAG | 还有剩余空闲空间的**碎片区**，有些页还未被分配使用 |
| FULL_FRAG | 没有剩余空闲空间的**碎片区**，所有页都已被分配使用 |
| FSEG      | 附属于某个段的区                                   |

**XDES Entry 结构**

InnoDB 使用 XDES Entry 结构管理区，每个区都对应一个 XDES Entry，结构中记录着对应的区的一些属性。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-8ab1d0f2.jpg)

| 组成部分          | 大小    | 说明                                                         |
| ----------------- | ------- | ------------------------------------------------------------ |
| Segment ID        | 8 byte  | 所属段的 ID                                                  |
| List Node         | 12 byte | 用于连接多个 XDES Entry 成为链表，结构如下图所示             |
| State             | 4 byte  | 区的状态                                                     |
| Page State Bitmap | 16 byte | 每两个位对应区的一个页，第一个位表示页是否空闲，第二个位没用 |

List Node 有 4 个属性，分别表示前、后 XDES Entry 的页号和页内偏移量。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-b54ef39c.jpg)

**XDES Entry 链表**

InnoDB 怎么快速找到指定状态的区？为此，表空间把**直属**的区对应的 XDES Entry 组成 3 个链表：

* FREE 链表：其中的区都是 FREE 状态；
* FREE_FRAG 链表：其中的区都是 FREE_FRAG 状态；
* FULL_FULL 链表：其中的区都是 FULL_FULL 状态。

现在，表空间需要时可以直接从 FREE_FRAG 链表取出一个结点来申请碎片页，以及使用 FREE 链表创建碎片区。

每个段会根据其包含的区的使用情况，也把它们组成 3 个链表：

* FREE 链表：其中的区的所有页面都未被使用；
* NOT_FULL 链表：其中的区的部分页面已被使用；
* FULL 链表：其中的区的所有页面都被使用。

**List Base Node 链表基结点**

InnoDB 使用 List Base Node 结构记录 XDES Entry 链表，List Length 表示链表结点数量。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-ed530fe9.jpg)

**INODE Entry 结构**

InnoDB 使用 INODE Entry 结构管理段，每个段都对应一个 INODE Entry，结构中记录着对应的段的一些属性

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-ebbe7472.jpg)

NOT_FULL_N_USED 表示已经使用了多少个 NOT_FULL 链表的页，再次分配空闲页时就能直接定位而不用从链表头挨个遍历；Magic Number 标记 INODE Entry 是否初始化；总共 32 个 Fragment Array Entry 结构，记录零散页的页号；另外 3 个 List Base Node，这是段的 3 个 XDES Enty 链表的基结点。

### 特殊页面结构

现在已经了解表空间、区、段、XDES Entry、INODE Entry、各种 XDES Enty 链表的概念，那么这些东西到底存放在哪里呢？这就需要深入了解每组开头的几种特殊类型页面的结构。

**FSP_HDR 类型**

以下是 FSP_HDR 页面的结构图，可以发现其保存着本组所有区的 XDES Entry 结构，Empty Space 部分用于填充页面空白，没有意义。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-d9376168.jpg)

展开 File Space Header 部分，以下是它的结构图，其保存着表空间的 3 个 XDES Enty 链表的基结点，另外还有两个基结点：SEG_INODES_FULL 和 SEG_INODES_FREE，它们是 INODE 页面组成的链表的基结点。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-e88bf5bd.jpg)

**XDES 类型**

对于 XDES 页面，没什么好说，相比 FSP_HDR 页面，它仅保存着本组所有区的 XDES Entry 结构。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-c08c4818.jpg)

**INODE 类型**

INODE 页面保存段的相关属性，比如包含的零散页的地址以及段的 3 个 XDES Enty 链表的基结点。如果表空间有很多个段，可能需要多个 INODE 页，这些页会根据使用情况组成两个链表：

* SEG_INODES_FULL 链表：其中的 INODE 页都没有空闲空间来存储额外的 INODE Entry 结构。
* SEG_INODES_FREE 链表：其中的 INODE 页都还有空闲空间。

这两个链表的基结点保存在 FSP_HDR 页的 File Space Header 部分末尾。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-4640f926.jpg)

**IBUF_BITMAP 类型**

暂不学习，Change Buffer 相关内容在后面。

### Segment Header 结构

对于索引，Root 页的 Page Header 部分会保存两个属性：PAGE_BTR_SEG_LEAF、PAGE_BTR_SEG_TOP，它们是这个索引对应的叶子节点段和非叶子节点段的头部信息，对应两个 Segment Header 结构。这样，我们就能知道这个索引属于哪个段，需要时访问对应的 INODE Entry 结构。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-0e2f0e8b.jpg)

## 系统表空间

每个 MySQL 实例只有一个系统表空间，以下是系统表空间的整体结构，可以发现其与独立表空间相似，只是额外增加了一些有关整个系统信息的页面。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-97ea9524.jpg)

页号为 3~7 的页面都是系统表空间独有，以下是这些页面的说明。

| 页号 | 页面类型 | 说明                   |
| ---- | -------- | ---------------------- |
| 3    | SYS      | Insert Buffer 头部信息 |
| 4    | INDEX    | Insert Buffer 根页面   |
| 5    | TRX_SYS  | 事务系统相关信息       |
| 6    | SYS      | 第一个回滚段的页面     |
| 7    | SYS      | 数据字典头部信息       |

**InnoDB Data Dictionary 数据字典**

除了用户数据，MySQL 还需保存一些额外信息，比如有哪些表？这些表有哪些列、索引和外键？这类信息其实就是表的元数据，InnoDB 定义了一系列内部系统表来记录这些元数据，它们也以 B+ 树形式存放，这些系统表也被称为**数据字典**，以下是它们的基本说明。

| 表名             | 说明                     |
| ---------------- | ------------------------ |
| SYS_TABLES       | 所有表的信息             |
| SYS_COLUMNS      | 所有列的信息             |
| SYS_INDEXES      | 所有索引的信息           |
| SYS_FIELDS       | 所有索引对应的列的信息   |
| SYS_FOREIGN      | 所有外键的信息           |
| SYS_FOREIGN_COLS | 所有外键对应的列的信息   |
| SYS_TABLESPACES  | 所有表空间的信息         |
| SYS_DATAFILES    | 所有表空间对应文件的信息 |
| SYS_VIRTUAL      | 所有虚拟生成列的信息     |

SYS_TABLES 、SYS_COLUMNS 、SYS_INDEXES 、SYS_FIELDS 这 4 个表称为基本系统表，最为重要，通过它们可以获得任何其它系统表和用户表的元数据。怎么找到基本系统表？这没办法了，只能硬编码，页号为 7 的页面保存着这 4 个表的聚簇索引和二级索引对应的 B+ 树的根页面。

以下是页号为 7 的页的结构图，可以发现，它还管理着下一个可分配的列、表、索引、表空间的 ID 编号。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-5036dad2.jpg)

用户不能直接访问 InnoDB 内部系统表，不过，系统数据库 information_schema 提供了一些以 innodb_sys 开头的表，InnoDB 会在启动时读取系统表然后把数据填充到这些表中，当然，两边的表的结构并不完全一样。

# B+ 树索引的原理

索引是一种数据结构，设计的目的是快速检索记录。

## 聚簇索引

已经知道，在 InnoDB，表的记录存放在一个或多个 index 页，这些页组成双向链表，记录在页内按主键升序组成单向链表。每个 index 页还会生成页目录，用于二分查找，快速检索记录。

**为什么要设计索引**

如果表的记录都在一个页，根据主键的查询可以使用页目录快速检索。但是，如果查询条件是其它的列，并且这个列没有建立索引，那就只能沿着链表挨个遍历所有记录，即全表扫描。

如果表的记录分散在多个页，如何确定目标记录在哪个页呢？目前来看，只能沿着链表检查所有页面，并且，如果查询条件不是主键，还要遍历页内的记录链表。

**目录项快速定位页**

现在只考虑条件是主键的查询。如何快速定位目标记录所在的页呢？参考页目录的设计，把所有数据页按照主键升序排列，组成双向链表，即后一个页的主键都比前一个页大，然后提取每个页的最大键值。这样，就能通过比较查询条件和各个页的最大键值，快速目标记录所在的页。

如何管理每个页的最大键值，关联这些值和对应的页呢？InnoDB 把这些信息存到 index 页，不过，这时的记录类型是目录项记录。对于主键索引，目录项记录有两个字段：最大键值和页号。现在，就能像普通的数据页那样检索目录项，查找页号，定位目标页。

**分裂分层和 B+ 树**

页的空闲空间如果不足以存放新的记录，这时会生成一个新页，用于保存多余的记录，这叫"页分裂"。新的记录不一定在新的页，因为要保证页间的主键顺序，所以新记录可能插到前面的页，把旧记录移到新页。无论数据页或目录页，都能进行页分裂。

如果数据页很多，目录项自然也会很多，可能会有多个目录页。这时，检索最开始又该如何确定目标记录在哪个目录页呢？很简单，照搬前面的方案，构建目录页的目录页，同级的目录页按照主键升序组成双向链表。这样不断地构建范围更大的目录页，直到顶层只有一个页，这个页叫做 Root 页。

这种数据结构就是 B+ 树，底层的数据页称作叶结点，中间的目录页称作内结点。MySQL 把最下面的叶结点那层看作第 0 层，层级向上依次递增。对于 InnoDB，所有索引都是 B+ 树结构。使用 B+ 树索引查找记录，都是从顶层的 Root 页开始。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-73064f39.jpg)

**聚簇索引就是数据**

MySQL 把叶结点保存着完整用户记录，根据**主键**排序的 B+ 树，称为聚簇索引。"根据主键排序"有两个意思：

* 页内记录按主键升序组成单链表
* 同层页间按主键升序组成双链表

InnoDB 表本身就以 B+ 树的结构存储，所以，InnoDB 表是一个聚簇索引，这就是**索引即数据**。

每当为一个表创建 B+ 树索引，会先为它创建一个 Root 页，初始 Root 页为空。最开始，插入的用户记录会直接存到 Root 页，直到 Root 页的空闲空间不足，再生成一个新页，把 Root 页的记录复制到新页，新页又进行页分裂并存入新记录，同时，Root 页更新为目录页。

## 其它索引

**二级索引**

聚簇索引只能用于根据主键的搜索，如果条件是其它的列怎么办？InnoDB 允许为普通列创建 B+ 树索引，这种索引称做二级索引或辅助索引，页内和页间根据索引列排序，叶结点只保存索引列和主键，而非完整记录。

如果想通过二级索引查找完整的记录，还要根据叶结点的主键值查找聚簇索引，这叫"回表"。因为普通列的值可能重复，所以二级索引的查找，不是找到一个就结束，而是先找到第一个满足的叶结点，然后沿着底层的链表向后遍历和回表，直到遇见条件不满足的记录，最后返回所有满足条件的记录。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-c4520890.jpg)

**联合索引**

联合索引也是二级索引，只不过它有多个索引列。假设 C1、C2 是索引列，B+ 树先根据 C1 排序，如果这个列的值相等，再根据 C2 排序。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-8495c305.jpg)

## 注意事项

**内结点的目录项的唯一性**

对于聚簇索引，目录项只包含主键和页号，但这对于二级索引不太严谨，因为二级索引可能存在多个叶结点的最大值都相同，这会导致目录页有多个相同的目录项。所以，二级索引的目录项增加一个列：主键，这就可以保证目录项的唯一性。并且，二级索引的目录项在索引列相等时，根据主键排序。

**B+ 树百万级别的储存性能**

假设每个数据页保存 100 条记录，每个目录页保存 1000 条记录。这样，单层的 B+ 树可以保存 100 条记录，双层的 B+ 树可以保存 100,000 条记录，三层的 B+ 树可以保存 100,000,000 条记录，这已经是百万级别，四层甚至达到亿万级别。

对于大部分数据表，三层的 B+ 树足以存放所有数据，但这也是百万级别。即使是这么大的数据量，每次根据索引列的检索，通常只会查找 3 个页面，即 2 个目录页和 1 个数据页，并且在页内，还有页目录的支持。

**每个页面最少有两条记录**

B+ 树之所以储存这么多数据，查询速度还那么快，因为 B+ 树本质是一个多层目录，每经过一个目录，就能筛选掉许多子目录。如果一个结点只有一条记录，目录的层数会非常多，每次检索需要查找大量的页。

所以，MySQL 规定 index 页至少有两条记录。根据这个规定，还可以计算可变长列最多能存放多少字节。

## MyISAM 索引

MyISAM 存储引擎也支持索引，同样把索引组织为树。不同的是，MyISAM 把数据和索引分开管理，表的所有记录都放在一个数据文件。MyISAM 表会自动为主键创建索引，索引信息放在一个索引文件，索引的叶结点保存的是键值+记录指针，而非完整的记录。查找先根据索引获取指针，然后通过指针从数据文件拿到目标记录。

所以，MyISAM 建立的所有索引都是二级索引。如果需要，可以对其它列建立索引或联合索引，原理类似。

# B+ 树索引的应用

## 索引的代价

**空间上的代价**

对于 InnoDB，建立一个索引，就是创建一颗 B+ 树，每个结点都是 index 页，每个页默认占用 16KB 空间。

**时间上的代价**

每次修改表的数据，为了维护 B+ 树结构，需要进行相应的修改，比如页分裂、页回收。如果表的索引太多，那么每个简单的修改，都有可能引发大量的 B+ 树更新，这会带来很大的性能消耗。

另外，执行查询语句之前要生成一个执行计划，这个计划会计算使用各个索引的成本，最后选择成本最低的索引执行查询。如果表的索引太多，这会增加成本分析的耗时。

## 索引的应用

### 索引用于查询

如果不用索引，查询将选择全表扫描的执行方案，遍历所有记录，即从最左边开始，沿着底层链表，扫描聚簇索引的用户记录。

**扫描区间和边界条件**

查询使用索引，首先找到第一个**符合条件**的记录，接着向后遍历，直到遇见不符合条件的记录。"符合条件"指符合边界条件。遍历的范围叫做扫描区间，这把原本的全表扫描优化为扫描某个区间，形成扫描区间所用的查询条件叫做边界条件。

扫描区间不是最终结果，而是缩小的检索范围，遍历到的每条记录，还要使用非边界条件进行二次判断，对于二级索引，可能还要回表获得其它字段才能进行二次判断。

有的扫描区间只有一个值，称为单点扫描区间，包含多个值的扫描区间叫做范围扫描区间。对于全表扫描，可以看作聚簇索引的 (-∞,+∞) 扫描区间。

**扫描区间的计算方式**

查询语句可能有多个索引可用，计算某个索引的扫描区间时，可以把不相关的条件与 True 等同。每个小条件都会形成一个扫描区间，使用 AND 连接的条件，取扫描区间的交集，使用 OR 连接的条件，取扫描区间的并集。最后的结果，就是使用这个索引时的扫描区间。

联合索引，有些条件虽然涉及索引列，但不能作为边界条件。因为，只有前一个索引列的值固定，记录才根据当前列排序。如果前一个索引列不固定，那后一个索引列的条件不可用。

### 索引用于排序

**文件排序**

使用 ORDER BY 子句排序结果集，需要把数据加载到内存，使用排序算法进行排序，当结果集太大时，还要借助磁盘存放中间结果，最后返回客户端。MySQL 把这种排序方式称为文件排序。

**索引排序**

如果 ORDER BY 使用索引列，可能会省去文件排序的步骤。因为索引本身有序，如果 ORDER BY 子句的排序规则和索引一致，那么遍历索引就是 ORDER BY 期望的结果。降序 DESC 也能使用索引，通过"查找某条记录的上一条记录"进行实现，这比"查找某条记录"稍微复杂。

如果 ORDER BY 想要使用联合索引，排序列的顺序应该与索引列的左侧连续顺序一致，即最左原则。

**无法使用索引的情况**

用于排序的列不属于同一个索引。

用于排序的列不符合联合索引的最左原则。

排序列不是以单独列名出现，可能被修饰，比如使用函数。

混用 ASC 和 DESC，这种情况即使能用索引，消耗也会很大，执行计划基本不会选择这个方案。

形成扫描区间的索引列与排序列不同，这时索引的扫描顺序与排序列无关。

### 索引用于分组

类似于索引排序。通常，分组会使用临时表存放中间结果。如果用于分组的列是索引列，那么同组的记录在索引的底层连续，直接遍历索引可以快速得到分组结果，然后进行其它的统计操作。

## 创建和使用

**索引目标**

应该只为 WHERE 子句中的列、连接子句中的列，或者 ORDER BY、GROUP BY 中的列创建索引。

**索引下推**

对于二级索引，如果非边界条件的列被用户记录包含，那么不用回表，直接原地进行二次判断。

**覆盖索引**

对于二级索引，如果查询的列被用户记录包含，那么不用回表，直接返回结果。

**最左原则**

不多赘述，考虑联合索引的排序规则，就知道只有最左原则才能利用联合索引。

**前缀索引**

对于较长的字符串列，建立完整的索引比较耗费空间，可以只对部分前缀建立索引，索引根据前缀排序。

```
alter table 表名 add index 索引名(列名(前缀长度));
```

# InnoDB 页的缓冲



# 事务简介和应用



# 重做日志 Redo

崩溃恢复

# 未作日志 Undo



# 版本镜像 MVCC



# InnoDB 锁

