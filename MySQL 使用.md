# 数据类型

## 数值类型

**整数**

| 整数类型    | 字节 | 最小值                 | 最大值                |
| ----------- | ---- | ---------------------- | --------------------- |
| `tinyint`   | `1`  | `-128`                 | `127`                 |
| `smallint`  | `2`  | `-32768`               | `32767`               |
| `mediumint` | `3`  | `-8388608`             | `8388607`             |
| `int`       | `4`  | `-2147483648`          | `2147483647`          |
| `bigint`    | `8`  | `-9223372036854775808` | `9223372036854775807` |

整数类型支持在后面追加小括号，括号中的数字指定显示宽度。这仅仅用于显示宽度，如果实际值超过这个宽度，宽度格式就没有意义，实际值仍然正常插入。

宽度显示可以配合 `zerofill` 使用，使用 0 填充空位：

```
alter table people id int(10) zerofill;
```

所有整数类型都有一个可选属性，无符号 `unsigned`：

```
alter table people id int(10) unsigned zerofill;
```

此时，该整数类型的下限变为 0，上限取原来值的两倍。

另外，整数类型还有一个属性，自增 `auto_increment`。一张表最多只能有一个自增字段。对于任何想要使用自增的字段，应该定义为 `not null`，并定义为 `primary key` 或定义为 `unique` 键。自增类型的值一般从 1 开始，每行增加 1，也可以自定义步长。

**小数**

| 浮点数类型 | 字节 |
| ---------- | ---- |
| `float`    | 4    |
| `double`   | 8    |

| 定点数类型 | 字节 |
| ---------- | ---- |
| `decimal`  | M+2  |

定点数在 MySQL 中以字符串的形式存放，比浮点数更精确。

浮点数和定点数都可以用类型名称加 `(M,D)` 的方式进行表示。`(M,D)` 表示该值一共有 `M` 位数位，其中有 `D` 位是小数位。如果不使用 `(M,D)` 指定精度，浮点数会按实际精度显示，定点数默认整数位为 10，小数位为 0。

定义的精度如果不能满足插入值，浮点数会取四舍五入的结果插入，而定点数会截断数值插入，并会报错。

**BIT**

`bit` 类型用于存放位字段值。`bit(M)` 表示可以存放 `M` 位二进制数，`M` 的范围位 `0~64`，如果不写，默认为 1。

对于 `bit` 类型的数据，直接使用 `select` 不会看到结果，可以使用函数 `bin()` 显示为二进制格式，或使用 `hex()` 显示为十六进制格式。

数据插入 `bit` 类型字段时，首先转换为二进制，如果位数满足，才能正常插入。否则，插入失败。

## 日期类型

| 日期和时间类型 | 字节 | 最小值                | 最大值                |
| -------------- | ---- | --------------------- | --------------------- |
| `date`         | `4`  | `1000-01-01`          | `9999-12-31`          |
| `time`         | `3`  | `-838:59:59`          | `838:59:59`           |
| `datetime`     | `8`  | `1000-01-01 00:00:00` | `9999-12-31 23:59:59` |
| `timestamp`    | `4`  | `19700101080001`      | 2038 年的某个时刻     |
| `year`         | `1`  | `1901`                | `2155`                |

如果插入值超出类型的范围限制，系统会进行错误提示，并以零值进行存储。

`timestamp` 与 `datetime` 相比，它的显示与时区有关。当插入日期到 `timestamp` 字段时，值会先转换为本地时区后存放。而从数据库取出时，也同样会将日期转换为本地时区后显示。但 `timestamp` 的取值范围较短，不适合存放较久远的日期。

> MySQL 的时区属性是 `time_zone`，值默认为 `SYSTEM`，也就是操作系统的时区。

`year` 用于表示年份，它接受 `YYYY` 和 `YY` 两种格式的值，当使用两位字符串时，`00` 到 `69` 表示 `2000~2069`，
`70` 到 `99` 表示 `1970~1999`。

**日期值的格式**

日期类型的插入格式有很多，包括整数（如 `2100`）、字符串（如 `"2010-01-19 10:10:10"`）、
函数（如 `now()`）等。那么，到底什么样的格式才能正确插入到对应的字段呢？

以 `datetime` 为例进行说明。

* `YYYY-MM-DD HH:MM:SS` 或 `YY-MM-DD HH:MM:SS` 的字符串。允许不严格语法，即任何标点符都可以作为日期部分和时间部分的分隔符。如果月、日、时、分、秒不一定非要指定两位数。
* `YYYYMMDDHHMMSS` 或 `YYMMDDHHMMSS` 格式的字符串。
* `YYYYMMDDHHMMSS` 或 `YYMMDDHHMMSS` 格式的数字。
* 函数返回的结果，其值适合 `datetime`、`date` 或 `timestamp` 上下文，如 `now()`。

## 字符串类型

| 字符串类型     | 字节/字符    | 描述及存储需求                                 |
| -------------- | ------------ | ---------------------------------------------- |
| `char(M)`      | `M` 个字符   | M 为 0~255 之间的整数                          |
| `varchar(M)`   | `0~M` 个字符 | M 为 0~65535 之间的整数，值的长度 +1 个字节    |
| `binary(M)`    | `M` 个字节   | M 为 0~255 之间的整数                          |
| `varbinary(M)` | `0~M` 个字节 | M 为 0~65535 之间的整数，值的长度 +1 个字节    |
| `tinyblob`     |              | 允许长度 0~255 字节，值的长度 +1 个字节        |
| `blob`         |              | 允许长度 0~65535 字节，值的长度 +2 个字节      |
| `mediumblob`   |              | 允许长度 0~167772150 字节，值的长度 +3 个字节  |
| `longblob`     |              | 允许长度 0~4294967295 字节，值的长度 +4 个字节 |
| `tinytext`     |              | 允许长度 0~255 字节，值的长度 +1 个字节        |
| `text`         |              | 允许长度 0~65535 字节，值的长度 +2 个字节      |
| `mediumtext`   |              | 允许长度 0~167772150 字节，值的长度 +3 个字节  |
| `longtext`     |              | 允许长度 0~4294967295 字节，值的长度 +4 个字节 |

`char` 和 `varchar` 很相似，都用来保存较短的字符串。但 `char` 列的长度固定为创建时声明的长度，而 `varchar` 列中的值为可变长字符串。

键检索的时候，`char` 会删除尾部的空格，`varchar` 则会保留这些空格。

`binary` 和 `varbinary` 类似于 `char` 和 `varchar`。只不过它们储存的是二进制字符串，而不是字符串。

## ENUM 类型

MySQL 支持枚举类型，它的值范围需要在创建表时显式指定，对 1~255 个成员的枚举需要 1 个字节储存，对 255~65535 个成员的枚举需要 2 个字节储存。最多有 65535 个枚举成员。

```
create table table_name (id int, gender enum('M','F'));
```

`enum` 是忽略大小写的。在插入值时，可以使用数字或字符串数字来表示对应位置的枚举成员。

## SET 类型

`set` 和 `enum` 类似，定义语法基本相同，但 `set` 字段支持插入多个成员，而 `enum` 字段只接受单个成员。

而且它的储存也有所不同：

* 1~8 个成员，占 1 个字节。
* 9~16 个成员，占 2 个字节。
* 17~24 个成员，占 3 个字节。
* 25~32 个成员，占 4 个字节。
* 33~64 个成员，占 8 个字节。

```
create table table_name (cars set('bentch','volvo','ferrari'));

insert into table_name(cars) values('bentch,volvo,ferrari'); # 插入多个值
```

# 变量

- 系统变量前缀 `@@`
- 用户变量前缀 `@`
- 局部变量没有前缀

## GLOBAL 和 SESSION 变量

全局全量的修改跨 `session` 有效，但 MySQL 重启后便会恢复原样。如果要永久性修改，需要修改 MySQL 的配置文件。

如果不在 `@@` 后指定 `global` 或 `session`，默认使用 `session` 变量。修改结果只对当前连接有效。

```
# 查看所有变量
SHOW [GLOBAL|SESSION] VARIABLES;
```

```
# 查看匹配通配符的变量
SHOW [GLOBAL|SESSION] VARIABLES LIKE '%var_name%';
```

```
# 查看指定变量
SELECT @@[GLOBAL|SESSION].var_name;
```

```
# 修改变量
SET @@[GLOBAL|SESSION].var_name = value;
```

## 用户变量

用户变量对当前 `session` 有效，用户变量不需要指定类型，局部变量必须指定类型。

```
# 定义用户变量
set @var_name = 1;
set @var_name := 2;
select @var_name :=2;
select 3 into @var_name;
```

## 局部变量

局部变量只在 `begin end` 中有效，且必须申明在复合语句的开头。

```
# 声明
declare var_name inT;
# 声明并赋值
declare var_name inT default 1;
```

```
# 直接赋值或查询赋值
set var_name = 2;
set var_name := 3;
select var_name := 4;
select col_name into var_name from ...
```

# 运算符

各种运算符的优先级太复杂，使用 `( )` 先需要先计算的操作括起来。

## 算数运算符

| 运算符       | 作用 |
| ------------ | ---- |
| `+`          | 加   |
| `-`          | 减   |
| `*`          | 乘   |
| `/` 或 `DIV` | 除   |
| `%` 或 `MOD` | 取模 |

## 比较运算符

MySQL 没有专门的 boolean 类型，所以用 1 表示 `true`，用 0 表示 `false`。

| 运算符              | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| `=`                 | 相等返回 1，否则返回 0                                       |
| `!=`                | 不相等返回 1，否则返回 0                                     |
| `<`                 | ...                                                          |
| `<=`                | ...                                                          |
| `>`                 | ...                                                          |
| `>=`                | ...                                                          |
| `between`           | 语法：`a between min and max`，相当于 `a >= min and a <= max`。 |
| `in`                | ...                                                          |
| `is null`           | ...                                                          |
| `is not null`       | ...                                                          |
| `like`              | 模糊匹配                                                     |
| `regexp` 或 `rlike` | 语法：`strA rlike strB`。如果 `strB` 是 `strA` 的子串，返回 1，否则返回 0。 |

## 逻辑运算符

| 运算符        | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| `not` 或 `!`  | 非。返回与操作数相反的结果，但 `not null` 的返回值位 `null`。 |
| `and` 或 `&&` | 与。操作数有一个为 `null`，则返回值为 `null`。               |
| `or` 或 `||`  | 或。当有一个操作数位 `null`，另一个操作数非 0，返回 1，否则返回 `null`。 |
| `xor`         | 异或。操作数有一个为 `null`，则返回值为 `null`。             |

## 位运算符

将操作数转换为二进制，计算后再将结果转换为十进制。

| 运算符 | 作用 |
| ------ | ---- |
| `&`    | ...  |
| `|`    | ...  |
| `^`    | ...  |
| `~`    | ...  |
| `>>`   | ...  |
| `<<`   | ...  |



## MyISAM

MyISAM 既不支持事务，也不支持外键。

**表锁**

MyISAM 只支持表锁，一下就把整张表锁住，太极端。读数据时它会对涉及的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。所以 MyISAM 的并发能力非常差，因为它的操作总是会锁定整张表，这很容易造成锁冲突，阻塞后面的访问请求。

MyISAM 在某些场景相对于 InnoDB 的访问速度有明显的提高，对事务完整性没有要求或者以 `select`、`insert` 为主的应用可以使用 MyISAM 表。因为读只会加共享锁，且 MyISAM 支持读数据时的并发插入，所以这两种操作都不会太影响性能。而且，MyISAM 对整张表加锁肯定比 InnoDB 一行一行地加锁要快的多。

**数据修复**

MyISAM 类型的表可能会损坏，原因是多种多样的，损坏后的表可能不能被访问。MyISAM 提供修复表的工具，可以用 `check table` 语句检查 MyISAM 表的健康，并用 `repair table` 语句修复一个损坏的 MyISAM 表。

MyISAM 表的修复可能会丢失一些数据，而且修复操作非常慢。

**异常崩溃恢复**

MyISAM 不支持异常崩溃恢复，InnoDB 表异常崩溃后，数据库重启时会保证数据恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log`。

## InnoDB

InnoDB 是 MySQL 5.5 之后的默认存储引擎，具有提交、回滚和崩溃恢复能力的事务安全保障，同时提供更小的锁粒度（行锁）和更强的并发能力，拥有自己独立的缓存和日志。

相比于 MyISAM，InnoDB 会占用更多的磁盘空间以保留数据和索引，但这在大部分时候多是值得的。

### InnoDB 的自动增长列

创建表时设置自增，列必须是数值类型的：

```
CREATE TABLE table_name (
	column_name_1 colmn_type_1 constraints auto_increment,
	...
)
```

InnoDB 的自动增长列可以手动插入，但如果插入的值为空，实际插入的值将会是自动增长后的值。

可以使用 `alter` 命令修改 InnoDB 表自动增长列的初始值：

```
alter table table_name auto_increment = n
```

在 MySQL 8.0 之前，对于 InnoDB 来说，`auto_increment` 只保留在内存中，如果数据库重启，这个值就会丢失，数据库会将它重置为自增列的最大值+1，这可能会导致在数据库重启后，自增数值和预期的不一致。

这个问题在 MySQL 8.0 之后被解决，方法是将自增主键的计数器持久化到 `redo log` 中，计数器每次发生变化都会将其写入这个文件。数据库重启后，会根据 REDO LOG 中的计数器信息来初始化 `auto_increment`。

对于 InnoDB 表，自增列必须被索引。如果是组合索引，也必须是组合索引中的第一列。但对于 MyISAM 表，自增列可以是组合索引的其它列，但这样在插入记录后，自增列是按照组合索引的前面几列排序后递增的。

### 外键约束

MySQL 支持外键约束的常用引擎只有 InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。

子表在创建外键约束时，可以指定父表在删除、更新时，对子表的相应操作。包括 `restrict`、`cascade`、`set null`、`no action`。其中 `restrict` 和 `no action` 作用相同，表示子表有关联数据的情况下父表不能更新。`cascade` 表示父表在更新或删除时，同时更新或删除子表对应的记录。`set null` 表示父表在更新或删除时，子表对应的字段被设置为 `null`。

```
create table table_name (
	...
	constraint key_name foreign key (col_name1) references othertable (col_name2) on delete restrict on update cascade
);

key_name：约束名
foreign key：关键字，表示外键约束
该SQL语句表示将当前表的col_name1字段与othertable表的col_name2字段建立外键关系，同时指定 col_name1有记录时，col_name2不能删除对应的记录；col_name2更新时，同步更新col_name1的记录。
```

### 主键和索引

不同于其它存储引擎，InnoDB 的数据文件本身就存储为 B+Tree 结构，这个聚簇索引也被称为主索引，并且也是 InnoDB 表的主键。InnoDB 表的每行数据都保存在主索引的叶子结点上。因此，所有 InnoDB 表都必须包含主键，如果创建表时不指定主键，InnoDB 会自动创建一个长度为 6 字节的 `long` 类型隐藏字段作为主键。

在 InnoDB 表上，除了主键以外其它索引都叫辅助索引或者二级索引，二级索引的数据结构也是 B-Tree。但它的叶子结点保存的是键值和主键值。所以非聚簇索引的查询是先找到主键值，然后通过聚簇索引查找最终数据。因此，主键的创建是否合理，会影响所有索引的效率。

### 存储方式

InnoDB 存储数据和索引有两种方式：

* 使用共享表空间存储：这种方式创建的表的表结构保存在 `.frm` 文件，数据和索引保存在 `innodb_home_dir` 和 `innodb_data_file` 定义的表空间，可以是多个文件。
* 使用多表空间存储：这种方式创建的表的表结构仍保存在 `.frm` 文件，但是表的数据和索引单独保存在 `.ibd` 文件。如果是一个分区表，每个分区单独对应一个 `.bd` 文件，文件名是 "表名+分区名"，可以在创建分区的时候指定每个分区的数据的保存位置，以此将表的 IO 均匀分布在多个磁盘上。

使用共享表空间时，随着数据的增长，表空间的管理维护会越来越困难，所以一般建议使用多表空间。多表空间的数据文件没有大小限制，既不需要设置初始大小，也不需要设置文件最大限制、拓展等参数。

> 即使使用多表空间进行存储，共享表空间仍然是必须的。因为 InnoDB 把内部数据词典和在线重做日志放在了这个文件。

对于多表空间存储的 InnoDB 表，可以比较方便的进行单表备份和恢复。但是直接复制 `.db` 文件是不行的，因为没有共享表空间的数据字典信息，直接复制的 `.bd` 文件和 `.frm` 文件在恢复时是不能被正确识别的。可以通过以下命令将备份恢复到数据库：

```
alter table table_name discard tablespace
alter table table_name import tablespace
```

## 比较

* 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
* 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
* 外键：InnoDB 支持外键。
* 备份：InnoDB 支持在线热备份。
* 崩溃恢复：MyISAM 不支持崩溃恢复，但它可以使用 MySQL 自带的工具进行修复，不过可能会丢失部分数据，且修复速度很慢。InnoDB 依靠 `redo log` 文件进行异常崩溃恢复。
* 其它特性：MyISAM 支持压缩表和空间数据索引。

# 索引

索引的本质是一种数据结构，它把表的特定字段用一个适合的数据结构组织起来，以此让查询变得高效。根据使用的数据结构，MySQL 的索引可以分为 Hash 索引和 B-Tree 索引。

MyISAM 和 InnoDB 表创建的索引默认都是 B-Tree 索引，只有 Memory 支持 Hash 索引。

MySQL 目前还不支持函数索引，但可以通过两种方式实现函数索引的功能：

* 前缀索引：对字段的前面部分进行索引。
* 虚拟列索引：MySQL 5.7 之后，可以创建一个虚拟字段作为索引，这个字段根据原始的字段计算得到。

所有类型的字段都可以被索引，使用索引是提高 `select` 性能的最佳途径。

## 索引的优缺点

优点：

- 使用索引可以大大加快数据的检索速度，这也是创建索引的主要原因。
- 通过创建唯一性索引，可以保证数据表中每一行数据的唯一性。

缺点：

- 创建和维护索引需要耗费许多时间。当对表中数据进行增删改时，如果数据有建立索引，那么索引也需要修改，这会降低 SQL 执行效率。
- 索引需要存储在磁盘文件中，这会耗费一定空间。

索引查询通常都比全表扫描要快，但如果数据量不大，那么使用索引也不一定能够带来很大提升。

## 二叉树和红黑树的缺点

使用二叉树存储索引，存储结构可能变成一条单链表。

红黑树是自平衡的二叉查找树，它虽然能解决二叉树的缺点，但它始终是二叉的，它的结点最多只有两个分支，这造成树的高度无法降低，使得查询需要更多的 IO 次数。

## Hash 索引

Memory 存储引擎支持 B-Tree 索引和 Hash 索引。

顾名思义，Hash 索引就是使用索引字段建立一个 Hash 表，这对于使用等式条件的查询非常有效，因为 Hash 表的查询速度是 *O(1)*。

但是，哈希索引具有几个严重的缺陷：

* 只支持等式条件的查询，比如 `=`、`<=>`。
* 不能加速 `order by` 操作。
* 不能用于范围查询，比如 `<`、`>`。
* 每次都只能对一个索引值的查询进行加速。

上面这些缺陷的原因都很容易明白，毕竟 Hash 表的功能就是这么单一。

## B-Tree

B-Tree 称为多路平衡查找树，B+Tree 是 B-Tree 的变体。目前大部分数据库及文件系统都支持使用 B-Tree 或 B+Tree 作为索引结构。

### B-Tree 和 B+Tree 的区别

- B-Tree 的结点既存放 key 也存放 data，而 B+Tree 只有叶子结点存放 key 和 data，中间结点只存放 key。

  这样做可以节省大量的存储空间，其次还能显著加快检索速度：data 占用的空间往往远大于 key，现在把中间结点的 data 删除，那么就能存储更多的 key，从而增加更多的分叉，使得能减少 IO 的次数。

  一个 3 层的 B+Tree 就可以存储近 2100 万条数据。

- B-Tree 的叶子结点相互独立，而 B+Tree 的叶子结点是双向链表，提高区间访问的性能。又因为 B-Tree 的叶结点是按升序排列的，那这就很有利于 order by 和 范围查询，

- B-Tree 的检索相当于对范围内所有结点的 key 做二分查找，可能还没有到达叶子结点，就检索完成。而 B+Tree 的检索效率就很稳定，任何查找都是从根结点到叶子结点。

### InnoDB 的聚簇索引实现

MyISAM 和 InnoDB 都是使用 B+Tree 作为索引的数据结构，但两者的实现方式不太一样。

InnoDB 表将自己的所有数据记录组织为一颗 B+Tree，使用主键作为 key。如果没有声明主键，也没有唯一索引这种可唯一标识记录的列，InnoDB 表将使用隐藏字段作为主键，这个隐藏字段是 `long` 类型。

这样做使得 InnoDB 表不用回表查询，速度会快一点。且叶结点是按照 key 的升序排列，互连为双向链表，这对于主键的 order by 和范围查询就很有利。

但这也使得 InnoDB 表的数据的插入和更新需要更多的维护，新插入的记录需要根据 key 值进行查找和排序，如果修改记录的 key 值，那么它还需要在 B+Tree 中进行调正，而叶结点包含 data，调整代价较大。

**通常使用整型自增作为主键**

整型数据比较小，占用的空间较少。且它的比较逻辑 `==` 效率较高，至少比字符串高，因为字符串是转换为 ASICI 然后一位一位的比较。

由于 B+Tree 的叶结点根据 key 值升序排列，且使用双指针连接成双链表。如果使用自增的主键，遍历叶结点链表的顺序就和记录的插入顺序相同。

**二级索引**

除聚簇索引外，InnoDB 还支持普通索引、联合索引、唯一索引等，这些都叫做二级索引。

二级索引的数据结构也是 B+Tree，但它们叶结点的 data 存储的不是表的记录，而是对应记录的主键值。使用二级索引进行查询时，首先在二级索引的结构中检索得到主键值，然后根据主键值在聚簇索引结构查询真正的数据。这个过程叫做回表。

### MyISAM 的非聚簇索引实现

MyISAM 的索引结构与 InnoDB 的二级索引相似，它的叶结点的 data 存储的是真实记录的地址。所以 MyISAM 表使用索引查询时，需要先在索引结构中查询记录地址，然后再访问数据文件获取记录。

这种将数据和索引分开的索引，叫做非聚簇索引。二级索引也是非聚簇索引。

## InnoDB 的几种二级索引

### 普通索引

普通索引的唯一作用就是加快查询速度，一张表允许创建多个普通索引，并允许数据重复和 `null`。

### 联合索引

包含多个字段的普通索引。

**存储方式**

联合索引的 B+Tree 结构，每个结点都会存储所有的索引字段。建立包含 3 个字段的联合索引，它的存储结构见下图：

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-0ed90719.png)

这些结点会依次比较索引的字段，然后进行排序。

**查找方式和最左前缀匹配原则**

最左前缀匹配原则之所以存在，和联合索引的构建方式及存储结构是有关系的。

创建索引 `(b, c, d)`，相当于创建了索引 `(b)`、`(b, c)`、`(b, c, d)`。这是因为，InnoDB 首先使用 `b` 字段构建索引，当 `b` 相等时再使用 `c` 字段，当 `c` 字段相等时再使用 `d` 字段。索引的第一列 `b` 在结构中整  体按照升序排列，而第二、三列 `c` 只在 `b` 相等的范围内局部有序，第三列 `d` 只在 `c` 相等的范围内局部有序。

所以，如果查询条件必须以联合索引首字段开始，如果不包含首个字段，那将无法应用联合索引。

查询字段跨列如 `(b, d)` 也会应用联合索引，但只是使用 `b` 字段，而不适用 `d`。

### 唯一索引

`unique index` 与普通索引基本相同，但它索引的字段具有唯一约束，使用唯一索引，大部分时候是为设置字段的唯一性，而不是优化查询。

创建或删除 `unique index` 时，可以不写 `index`，直接使用 `unique`。

### 前缀索引

对索引字段的前 N 个字符创建索引。前缀索引的长度跟存储引擎相关，对于 MyISAM 表，索引的前缀长度可以达到 1000 字节长，而对于 InnoDB 表，索引的前缀长度最长是 3072 字节。

前缀索引没有像 `unique` 这样的名字，它的创建与普通索引类似，使用 `index` 关键字，但要在索引的字段后面追加括号 `()`，其中的数字表示前缀长度。这种索引能大大缩小索引文件的大小，但前缀索引在排序 `order by` 和分组 `group by` 时无法使用。

需要注意，前缀的限制是以字节为单位，而 `create table` 语句中的前缀长度解释为字符数。

### 全文索引

全文索引主要是为检索大文本数据中的关键字信息，是目前搜索引擎数据库使用的一种技术。Mysql 5.6 之前只有 MYISAM 支持全文索引，之后 InnoDB 也支持全文索引。

## InnoDB 的索引优化

### 覆盖索引扫描

如果不使用主键索引，就一定会回表查询么？

不一定，如果查询字段本身就包含在索引当中，那么 MySQL 会直接返回这个值，不需要再查聚簇索引。即使是 MyISAM 也是如此。这种情况就称为覆盖索引。

回表查询是影响 MyISAM 性能的主要因素。

### 联合索引、最左匹配原则

使用表中的多个字段创建索引，就是联合索引，也叫组合索引、复合索引。下面创建一个普通联合索引：

```
CREATE INDEX my_union_index table_name(idx_col_name1,idx_col_name2,idx_col_name3)
```

**最左匹配原则**

使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配。如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 **`>`**、**`<`**、`between` 和以 `%` 开头的模糊条件，才会停止匹配。

比如 (col1 + col2 + col3) 联合索引，它可以被 col1、(col1 + col2)、(col1 + col2 + col3) 、(col1 + col3) 的等值条件查询使用，但不能被 (col2 + col1)、(col2 + col3) 使用。

所以在使用联合索引时，尽可能将区分度高的字段放在最左边，这可以过滤更多数据。

### 索引下推

索引下推是 MySQL 5.6 版本中提供的一项索引优化功能，它可以将对索引字段的过滤操作下放到存储引擎，从而减少不必要的 IO。

这是什么意思呢？假如没有下推优化，存储引擎通过索引检索到数据，然后将所有数据返回给 MySQL Server，Server 再根据条件筛选数据。

但如果有下推优化，存储引擎在查找索引时，会对索引值满足的索引项进行额外的条件判断，如果其不符合条件则跳过，这一步能减少回表 IO。同时，存储引擎返回给 Server 的数据会是少量的满足条件的数据。

## 创建索引

主键索引、唯一索引在定义主键约束、唯一约束的时候会自动创建。

创建表的时候创建索引：

```
CREATE TABLE table_name (
	...	
	[UNIQUE|FULLTEXT|SPATIAL] INDEX idx_name (idx_col_name)
)

idx_col_name：col_name [(length)] [ASC | DESC]。如果包含(length)，那就是前缀索引。
```

`create` 创建索引：

```
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX idx_name table_name(idx_col_name,...)
```

`drop` 删除索引：

```
DROP INDEX idx_name ON table_name
```

`alter` 添加或删除索引：

```
// 主键索引
ALTER TABLE table_name ADD PRIMARY KEY (column)
// 唯一索引
ALTER TABLE table_name ADD UNIQUE (column)
// 普通索引、联合索引、全文索引
ALTER TABLE table_name ADD [FULLTEXT] INDEX idx_name (idx_col_name,...)
```

```
ALTER TABLE table_name DROP INDEX idx_name
```

`alter` 修改索引名称：

```
ALTER TABLE table_name RENAME INDEX old_idx_name TO new_idx_name
```

## 索引设计原则

* 在条件列上创建索引，也就是在 `where` 后面的列上创建索引，或者在连接条件中指定的列。
* 尽量使用选择度高的列，相同列值的记录要尽量少，这样更容易区分记录。
* 使用短索引。
* 利用最左原则，减少索引的数量，即多创建联合索引。
* 对于 InnoDB 表，尽量手动指定主键。记录默认会按照一定的顺序保存，如果有明确定义的主键，则按主键顺序保存。如果没有主键，但有唯一索引，就按唯一索引的顺序保存。如果都没有，那么 InnoDB 使用隐藏列作为主键。按照主键或内部列进行的访问是最快的。如果有多个列都适合作为主键，选择最常作为条件的列。另外，InnoDB 表的普通索引都会保存主键的键值，所以主键应该选择较短的数据类型，减少磁盘占用，提高索引的缓存效果。

## 索引失效情况

* 以 `%` 开头的模糊查询不能利用 B-Tree 索引。这种情况推荐使用全文索引（FullText），或者对模糊查询的字段建立索引，将对它的查找建为子查询。
* 数据类型出现隐式转换时不会使用缩影。
* 混合索引不满足最左匹配原则。
* 如果全表扫描比使用索引快，MySQL 就不使用索引。
* 使用 or 分割查询条件，如果有任意一个条件的列没有索引，则不使用索引。

## 分析索引

查看表的索引：

```
show index from table_name
```

查看索引的使用情况：

```
show status like 'Handler_read%'
```

查看结果的 `Handler_read_key` 和 `Handler_read_rnd_next` 字段，前者表示一行记录被索引读的次数，越高越好。后者表示在数据文件中读下一行的次数，如果大量进行表扫描，它的值就会很高。

# 锁

锁是计算机用于协调多进程或多线程并发访问某一资源的机制。在数据库中，除了传统计算资源（如 CPU、I/O 等）的争用外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须考虑的问题。锁虽然能保证数据的一致性，但锁冲突是影响并发访问性能的重要因素。

MySQL 的不同存储引擎支持不同的锁。MyISAM 只支持表级锁。InnoDB 既支持行级锁，也支持表级锁，默认使用行级锁。

表级锁：开销小，加锁快。不会出现死锁。锁定粒度大，发生锁冲突的概率高，并发度低。

行级锁：开销大，加锁慢。会出现死锁。锁定粒度小，发生锁冲突的概率低，并发度高。

页面锁：适中。

## MyISAM 表锁

MySQL 的表级锁有两种模式：读锁和写锁。

|                | None | 读锁 | 写锁 |
| -------------- | ---- | ---- | ---- |
| 读锁（共享锁） | 兼容 | 兼容 | 冲突 |
| 写锁（排它锁） | 兼容 | 冲突 | 冲突 |

由上可见，MyISAM 表的读锁不会阻塞其它用户读同一张表，但会阻塞对同一张表的写。MyISAM 表的写锁则会阻塞其它用户对同一张表的读和写。所以，当一个线程获得一张表的写锁时，只有这个线程能对这张表进行更新操作。其它线程的读、写都会被阻塞，直到锁被释放。

**如何加表锁**

MyISAM 执行 `select` 前，会自动给所有表加读锁。在执行更新操作前，会自动给涉及到的表加写锁。这个过程不需要用户干预。当然，也可以手动加锁：

```
LOCK TABLE[S] table_name [READ|WRITE] [LOCAL]
```

其中，`LOCAL` 参数与并发插入有关，具体看书。

释放当前连接持有的所有表级锁：

```
UNLOCK TABLE[S]
```

每次都应该一次性为所有涉及到的表加锁。

如果在加锁后访问或更新其它未加锁的表，会报错。

## InnoDB 的锁

### InnoDB 的行锁及加锁方法

InnoDB 的行锁有两种模式：

* 共享锁（S）：允许一个事务读数据，阻止其它事务获得相同数据集的排它锁。
* 排它锁（X）：允许一个事务更新数据，阻止其他事务取得相同数据集额共享读锁和排它写锁。

|             | 共享锁（S） | 排它锁（X） |
| ----------- | ----------- | ----------- |
| 共享锁（S） | 兼容        | 冲突        |
| 排它锁（X） | 冲突        | 冲突        |

对于 `update`、`delete` 和 `insert` 语句，InnoDB 会自动给涉及到的数据集加排它锁。**对于普通 `select` 语句，InnoDB 不会加任何锁。**但序列化级别下的 `select` 会使用共享锁或排它锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁，它们都是表级锁：

* 意向共享锁（IS）：事务在给一行数据加共享锁前，需要先取得该表的 IS 锁。
* 意向排它锁（IX）：事务在给一行数据加排它锁前，需要先取得该表的 IX 锁。

|                  | 意向共享锁（IS） | 意向排它锁（IX） |
| ---------------- | ---------------- | ---------------- |
| 意向共享锁（IS） | 兼容             | 兼容             |
| 意向排它锁（IX） | 兼容             | 兼容             |

意向锁是 InnoDB 自动加的，不需用户干预。

除了让存储引擎自动负责加锁外，事务也可以显式给数据集加锁。在 MySQL 5.7 中，使用以下语句加锁：

```
# 共享锁
select * from table_name where ... lock in share mode
```

```
# 排它锁
select * from table_name where ... for update
```

MySQL 8.0 中：

```
# 共享锁
select * from table_name where ... for share
```

```
# 排它锁
select * from table_name where ... for update [nowait | skip locked]
```

当然，MySQL 8.0 依然支持之前的语法，向下兼容。

共享锁主要用于在需要数据依存关系时确认记录行是否存在，并确保没有人 `delete` 或 `update` 这行数据。但是，如果当前事务自己对这行数据进行更新操作，那么就会造成死锁。

在获取排它锁的过程中，如果遇到锁等待，默认会等待 50s。这在高并发的时候会造成连接数快速增加，甚至超过最大连接数。为此，MySQL 8.0 增加了两个选项：`nowait` 和 `skip locked`。`nowait` 表示遇到锁等待立即返回错误，`skip locked` 表示跳过被锁定的记录，继续更新其它行，但这可能会导致数据不一致。

### InnoDB 行锁实现方式

InnoDB 的行锁是通过给索引上的索引项加锁实现的。如果没有索引，InnoDB 将通过隐藏的聚簇索引来对记录加锁。InnoDB 行锁分为 3 中情形：

* Record lock：对索引项加锁。
* Gap lock：对索引项之间的 "间隙"、第一条记录前的 "间隙" 或最后一条记录后的 "间隙" 加锁。
* Next-key lock：前两种组合，对记录及其前面的 "间隙" 加锁。

> "间隙" 就是键值在条件范围内但并不存在的记录。

InnoDB 行锁的这种实现特点意味着：如果不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，实际效果跟表锁一样。

由于 InnoDB 的行锁是对索引项加锁，而不是对记录加锁，所以虽然是访问不同的记录行，但是如果是使用相同的索引项，还是会出现锁冲突。

当有多个索引时，不同的事务可以使用不同的索引项锁定不同的行，不论是使用主键索引、唯一索引或普通索引，InnoDB 行锁都会对数据加锁。也就是说，如果某个事务已经对这行记录加锁，那么其他事务即使使用不同的索引，也不能访问这行记录。

即使在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过比对不同执行计划的代价来决定的。如果 MySQL 认为全表扫描的效率更高，比如一些很小的表，它就不会使用索引。这种情况，InnoDB 会对所有记录加锁。因此，分析锁冲突的时候，需要检查是否有真正使用过索引。

另外，如果检索值的数据类型与索引字段不一样，虽然 MySQL 能进行类型转化，但它后面就不会使用索引，导致对所有记录加锁。

### Next-Key 锁

当事务隔离级别为可重复读时，我们使用范围条件而非相等条件检索数据，并请求共享或排它锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁。此外，InnoDB 还要对满足条件的间隙加锁。"间隙" 是键值在条件范围内但并不存在的记录。这种锁机制就叫做 Next-Key 锁。

InnoDB 之所以使用这种锁机制，一方面是为了防止幻读，避免事务期间其它事务插入满足条件的新数据。另一方面，是为了满足其恢复和复制的需要。

很显然，这种锁机制很容易导致锁冲突。因此，应该尽量避免使用范围条件。

还要说明，如果使用相等条件检索一个不存在的记录，InnoDB 也会使用 Next-Key 锁。

### InnoDB 使用表锁

对于 InnoDB 表，大多数时候使用行锁，因为事务和行锁往往是我们选择 InnoDB 的理由。但在个别情况中，也可以考虑使用表锁：

* 事务需要更新表的大部分或全部数据，表又比较大，如果使用行锁，总是要不停地去给每一行上锁，太影响执行效率。
* 事务涉及多张表，比较复杂，可能引起死锁，造成大量事务回滚。这种时候可以考虑一次性锁定事务涉及的所有表。

`lock tables` 虽然可以给 InnoDB 表加锁，但必须说明，表锁不是由 InnoDB 管理的，而是由上一层的 MySQL Server 负责的。仅当 `autocommit=0`、`innodb_table_locks=1`（默认）时，InnoDB 才能知道表是否被锁定。这种时候表锁才生效。

使用 `lock tables` 时要注意，需要将 `autocommit` 设为 0。在事务结束前，不能用 `unlock tables` 释放表锁，因为 `unlock tables` 会隐式提交事务。`commit` 和 `rollback` 不会释放用 `lock tables` 加的表锁，必须显式用 `unlock tables` 释放表锁，可以按如下做：

```
set autocommit=0;
lock tables t1 write, t2 read, ...;
[do something with table t1 and t2 hear];
commit;
unlock tables;
```

### 减少死锁的常用方法

* 如果有不同的程序并发访问多张表，应尽量以相同的顺序访问表。
* 在程序以批量方式处理数据时，应该先对数据排序，保证每个线程按固定顺序来处理记录。
* 事务如果要更新记录，应该尽早申请足够级别的排它锁。免得其它线程在中途获取到共享锁。
* 死锁很难完全避免，在程序设计中应该总是捕获并处理死锁异常。

# 事务

InnoDB 与 MyISAM 最大的区别有两点：一是支持行锁，二就是支持事务。

## 基本概念

### 事务及其 ACID 属性

事务是由一组 SQL 语句组成的逻辑单元，具有以下 4 种特性，通常称为 ACID 属性：

* 原子性（Atomicity）：事务是一个原子操作，其对数据的修改，要么全部执行，要么全部不执行。
* 一致性（Consistent）：事务执行前后，数据都保持一致。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
* 隔离性（Isolation）：一个事务所做的修改在最终提交之前，对其它事务是不可见的。
* 持久性（Durable）：事务完成后，它所作的修改是永久性的，即使出现系统故障也能保持。

InnoDB 使用 `redo log` 保证事务的持久性，使用 `undo log` 保证事务的原子性。

InnoDB 通过锁机制、MVCC 等手段保证事务的隔离性，默认隔离级别是 `REPEATABLE-READ`。

保证事务的持久性、原子性、隔离性之后，一致性才能得到保障。

### 并发事务的带来的问题

事务在并发执行时会带来一些问题，主要有以下 4 种：

| 问题       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 丢失更新   | 多个事务同时进行，后提交事务的更新覆盖了前面事务提交的更新结果。 |
| 脏读       | 一个事务读到另一个事务还未提交的修改。                       |
| 不可重复读 | 一个事务在内部两次读取同一个数据，但结果却不一样             |
| 幻读       | 一个事务按相同的查询条件重新读取以前检索过的数据，<br />却发现其它事务插入了满足条件的新数据 |

丢失更新是写的一致性问题，应该完全避免。但要防止丢失更新，不应该完全依靠事务控制器解决，还需要应用程序对要更新的数据加必要的锁来解决。防止更新丢失应该是应用的责任。

而脏读、不可重复读和幻读都是数据库读一致性问题，应该由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，主要有两种：

* 对数据加锁，阻止其它事务修改数据。
* 通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户角度来看，好像是数据库提供了同一数据的多个版本。所以，这种技术也叫做数据多版本并发控制（MVCC），也称为多版本数据库。

数据库的事务隔离越严格，并发的副作用就越小，事务的并发能力就越低。为了解决隔离与并发的问题，也为了避免手动使用锁，*ISO/ANSI SQL92* 定义了 4 个事务隔离级别，通过选择不同的隔离级别就可以处理大部分事务并发问题：

|                              | 读数据一致性                                   | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---------------------------------------------- | ---- | ---------- | ---- |
| 读未提交（Read Uncommitted） | 最低级别，<br />只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| 读已提交（Read Committed）   | 语句级                                         | 否   | 是         | 是   |
| 可重复读（Repeatable Read）  | 事务级                                         | 否   | 否         | 是   |
| 可序列化（Rerializable）     | 最高级别，事务级                               | 否   | 否         | 否   |

Read Committed，事务给操作的记录加行锁，从而禁止其它的事务修改该记录。



各种数据库产品不一定会完全实现这几个隔离级别，也可能会有自己的拓展，但 MySQL 是支持全部级别的。

> MySQL 的默认隔离级别是 `Repeatable Read`，这种时候可以避免大部分并发一致性问题，而且不会太影响 MySQL 性能。

## 事务控制

MySQL 支持本地事务，默认情况下，MySQL 是自动提交事务的，相当于每一句 SQL 命令都是一个单独的事务。

可以通过明确的事务控制命令 `START TRANSACTION` 或 `BEGIN` 来开启事务，使用 `Commit` 和 `Rollback` 命令可以提交或回滚事务：

```
START TRANSACTION | BEGIN [WORK]
	[do something]
	COMMIT [WORK]  [AND [NO] CHAIN] [[NO] RELEASE]
	ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
```

`CHAIN` 和 `RELEASE` 分别用来定义在事务提交或回滚后的操作，`CHAIN` 会立即开启一项新事务，并且和刚才的事务具有相同的隔离级别。`RELEASE` 则会断开和客户端的连接。

此外，也可以修改当前连接的事务提交方式：

```
SET AUTOCOMMIT = {0 | 1}
```

`AUTOCOMMIT=0` 表示关闭事务的自动提交，每一句 SQL 命令都需要手动 `COMMIT` 或 `ROLLBACK`。这时就没必要使用 `START TRANSACTION` 或 `BEGIN` 开启事务了。

在事务中还可以通过定义 `SAVEPOINT`，指定回滚事务的一个部分。可以定义多个 `SAVEPOINT`，相同名字的保存点，后面会覆盖前面的定义。对于不再使用的保存点，可以使用 `RELEASE SAVEPOINT` 命令删除：

```
SET AUTOCOMMIT = 0;
...
SAVEPOINT point_name;
...
ROLLBACK TO point_name;
RELEASE SAVEPOINT point_name;
COMMIT;
```

# MVCC

多版本并发控制 MVCC 是一致性非锁定读的实现，它应该是锁机制的一种升级，可以避免一些不必要的阻塞，提高并发度。`Repeatable Read` 和 `Read Committed` 隔离级别的实现依赖于 MVCC。

InnoDB 使用隐藏字段、`read view`、`undo log` 实现 MVCC。

## 一致性非锁定读

通常使用版本号或时间戳实现一致性非锁定读，更新数据时将对应的版本号+1，查询数据时将当前可见的版本号与对应记录的版本号对比，如果记录的版本号小于可见版本号，表示该记录对当前事务可见。

InnoDB 中，一致性非锁定读实现为 MVCC。如果当前事务读取的记录正被其它事务锁定，当前事务不会陷入阻塞，而是直接去获取历史快照版本，这种方式也叫快照读。

在 `Repeatable Read` 和 `Read Committed` 这两个隔离级别中，普通的 `select` 语句会使用一致性非锁定读。

## 一致性锁定读

锁定读就是使用锁机制保证数据的一致性，它与非锁定读的区别是：锁定读获取的数据一定是当前最新的，即当前读。而非锁定读获取的数据可能是历史版本，但非锁定读不会造成堵塞。

对于 InnoDB，所有的 `update`、`delete` 和 `insert` 语句，会自动给涉及到的数据集加排它锁，在范围查询条件下还会使用 Next-Key 锁。序列化级别下的 `select` 会使用共享锁或排它锁。

也可以手动加锁：

- `select ... for share`
- `select ... for update`

## InnoDB 对 MVCC 的实现

MVCC 的实现依赖于隐藏字段、`read view`、`undo log`。

**隐藏字段**

MVCC 会在每行记录后面添加 3 个隐藏字段：

* `DB_TRX_ID`：最近事务 id，最后一次插入或更新该行的事务 id，`delete` 操作也被视为更新，但会将记录 `record header` 中的 `deleted_flag` 标记为已删除。
* `DB_ROLL_PTR`：回滚指针，指向该行记录的 `undo log`，如果记录未被更新，则为空。
* `DB_ROW_ID`：如果没有设置主键且该表没有唯一非空索引，InnoDB 使用该字段生成聚簇索引。

**快照 read view**

`read view` 主要用于做可见性判断，其中保存 ”对当前事务不可见的其它事务的 id“：

* `m_low_limit_id`：目前出现过的最大的事务 id+1，即下一个将被分配的事务 id。大于等于这个 id 的数据版本对当前事务不可见。通常 `m_low_limit_id = m_creator_trx_id + 1`。
* `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 id，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 id 的数据版本对当前事务可见。
* `m_ids`：`read view` 创建时其他未提交的活跃事务 id 列表。创建 `read view` 时，将当前活跃事务的 id 记录下来，后续即使它们修改了数据记录，对当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）。
* `m_creator_trx_id`：创建该 `Read View` 的事务 id。

**undo log**

事务读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则通过 `undo log` 读取之前的版本数据，以此实现非锁定读。

`undo log` 分为两种：

* `insert undo log`：`insert` 产生的 `undo log`，因为 `insert` 的记录只对当前事务本身可见，对其他事务不可见，所以 `insert undo log` 在事务提交后可以直接删除而不需要进行 `purge` 操作。

  > `purge` 的任务是将数据库中已经 `mark del` 的数据删除，也会批量回收 `undo pages`。

* `update` 或 `delete` 产生的 `undo log`。 因为会对已存在的记录产生影响，为提供 MVCC 机制，需要保留 `update undo log`，在事务提交时将日志放到 `history list`，等待 `purge` 线程进行最后的删除操作。

不同事务或者相同事务的对同一记录行的修改，它们的 `undo log` 会连接为一条链表，链首是最新的记录，链尾是最早的旧记录。

## 数据可见性算法

InnoDB 的事务，在执行 `select` 前，会创建一个快照，快照保存当前数据库系统中活跃的事务的 id，其实就是不应该被当前事务看到的那些事务的 id（隔离性）。

当前事务 `select` 某个记录时，会先获取该记录的 `DB_TRX_ID`，然后和 `read view` 对比，判断记录的可见性。步骤如下：

* 如果记录的 `DB_TRX_ID` < `m_up_limit_id`，表明最近修改该行的事务在当前事务创建快照之前就已提交，所以该记录的当前版本对当前事务可见。

* 如果 `DB_TRX_ID` >= `m_low_limit_id`，表明最近修改该行的事务在当前事务创建快照之后才提交，所以该记录的当前版本对当前事务不可见。跳转到最后一步。

* `m_ids` 为空，表明在当前事务创建快照时，没有其它活跃的事务，那么该行记录的当前版本是在快照创建前提交的，所以它对当前事务可见。

* 如果 `m_up_limit_id` <= `DB_TRX_ID` < `m_low_limit_id`，表明修该行记录的事务在快照创建的时候处于 “活动状态” 或 “已提交状态”。现在需要对活跃事务列表 `m_ids` 进行查找：

  - 如果活跃事务列表 `m_ids` 中存在 `DB_TRX_ID`，表明：在快照创建前，该记录已被事务 `DB_TRX_ID` 修改，但这个事务还没有提交。或者在快照创建后，该记录才被事务 `DB_TRX_ID` 修改。

    在这两种情况下，该记录对当前事务都是不可见的。跳转到最后一步。

  - 活跃事务列表 `m_ids` 中不存在 `DB_TRX_ID`，表明事务 `DB_TRX_ID`  修改该记录后，在当前事务创建快照前就已经提交，所以该记录对当前事务可见。

* 根据该记录的 `DB_ROLL_PTR` 指针从 `undo log` 取出快照记录，用快照记录的 `DB_TRX_ID` 跳到第一步重新开始判断，直到找到满足的快照版本或返回空。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/mysql-4596890d.png)

## RC 和 RR 隔离级别下 MVCC 的差异

`Repeatable Read` 和 `Read Committed` 的普通 `select` 语句会使用一致性非锁定读。但它们创建 `read view` 的时机不同：

* `Repeatable Read`：每次 `select` 前都会创建一个快照。
* `Read Committed`：事务开启后，只在第一次 `select` 前创建一个快照。

这也就解释为什么 RC 存在不可重复读的问题。

## MVCC + Next-key 防止幻读

InnoDB 存储引擎在 RR 级别下通过 MVCC 和 Next-key 来解决幻读问题：

* 执行普通 `select` 时，使用 MVCC 快照读的方式获取数据。RR 会在第一次 `select` 前才创建快照，之后就一致使用这个快照读数据。所以快照创建后的数据修改对它不可见，这也防止了幻读。

  但与可序列化隔离级别不同，它只能防止快照创建后的幻读，而可序列化是防止事务开启后的幻读。

* 执行 `select...for update/share`、`insert`、`update`、`delete` 等当前读，获取的数据都是最新的，这种方式会产生幻读。

  InnoDB 会自动使用 Next-key 锁住范围内的间隙，从而防止幻读。

# MySQL 日志

MySQL 日志包括错误日志、查询日志、慢查询日志、事务日志、二进制日志等。其中比较重要的有二进制日志 `bin log`（归档日志）、事务日志 `redo log`（重做日志）、`undo log`（回滚日志）。

## 重做日志 redo log

`redo log` 是 InnoDB 独有的日志文件，它用于保证事务更新的一致性和持久性，和崩溃恢复能力。

它保存数据修改之后的值，如果 MySQL 实例异常宕机，重启时，InnoDB 会使用 `redo log` 恢复数据，保证数据的完整性。

### MySQL 的内存管理

关于 MySQL 的内存管理：MySQL 的数据和索引都是保存在文件系统中，如果每次都从磁盘中获取数据，那这些 IO 操作将大大降低数据库的效率。MySQL 会管理一块内存，用于缓存读取过的数据。

InnoDB 和 MyISAM 都实现有 Buffer Pool，但实现的细节不尽相同，最明显的差异是：MyISAM 只缓存索引块，所以它只能加速索引的读取，而 InnoDB 会缓存索引+数据。

MySQL 从磁盘读数据，是以页为单位的，加载出来的一页数据就叫做数据页，InnoDB 会将它放入缓存池中。查询操作都会先从缓存池中查找数据，如果没命中缓存，再加载磁盘文件。更新操作时，也是先尝试修改缓存池的数据，如果命中缓存，再加载磁盘文件。

### redo log 工作流程

`redo log` 会把对数据的修改操作记录到 `redo log buffer` 中，接着再将缓存刷盘到 `redo log` 文件中。

> `redo log buffer` 的作用与其它缓存一样，都是为了降低 IO 次数。

`redo log buffer` 会在何时将数据刷盘到 `redo log` 文件呢？InnoDB 提供有一个设置参数 `innodb_flush_log_at_trx_commit`，它支持三种刷盘策略：

* `0`：事务提交时不刷盘。
* `1`：默认值，事务提交时自动刷盘。
* `1`：事务提交时，只将 `redo log buffer` 写入 `page cache`。

`page cache` 是文件系统的缓存，不受 MySQL 管理。当数据被写入 `page cache` 后，还需要调用 `fsync` 将其中的内容写到 `redo log` 文件，这才真正完成刷盘功能。

对于策略 `1`，它会自动调用 `fsync` 一次性完成刷盘。

而对于其它两种策略，MySQL 后台运行有一个线程，每隔 1 秒就会把 `redo log buffer` 的内容写入 `page cache`，然后调用 `fsync` 进行刷盘。这样子的话，即使一个事务没有提交，它做的修改也会被记录到 `redo log` 文件，因为事务执行过程中的 `redo log` 记录是会被写入 `redo log buffer` 的。

还有一种情况会自动刷盘：当 `redo log buffer` 占用的空间达到 `innodb_log_buffer_size` 一半的时候，后台线程会自动刷盘。

三种策略各自的风险：

* `0`，如果 MySQL 挂机或宕机，可能会丢失最近 1 秒的 `redo log`。
* `1`，只要事务提交就一定会刷盘到文件，如果事务中间 MySQL 挂机或宕机，这部分日志会丢失，但由于事务未提交，所以不会产生数据不一致。
* `2`，MySQL 挂机不会丢失 `redo log`，但宕机可能会丢失最近 1 秒的 `redo log`。

### redo log 的作用

使用 `redo log` 的意义何在呢？每次事务结束直接将缓存数据刷盘不就好了么。

注意，`redo log` 记录的是 ”在指定的数据页上做了什么修改“ 这种信息。如果只是修改一两条记录就将整个数据页刷盘，太浪费资源。而且，数据页在磁盘中的存储是随机的，那对它的 IO 就更加耗时。

而 `redo log` 只记录被修改的数据，再加上是顺序的 IO，所以对 `redo log` 的刷盘远远快于数据页。

## 回滚日志 undo log

事务要执行的更新操作会先记录到 `undo log` 当中，然后再执行。如果事务发生异常，就直接利用 `undo log` 的信息将数据恢复到修改前的样子，完成回滚，保证事务的一致性。并且，回滚日志会先于数据持久化到磁盘，这就保证即使突然数据库挂机或宕机，数据库重启时也一定能使用 `undo log` 回滚数据。

事务提交后，`undo log` 不会被立马删除，而是被放到待清理链表中，等待判断没有事务用到该版本的信息时才会清理相应 `undo log`。它保存事务发生之前的数据版本，用于回滚，也能支持 MVCC 的读，即非锁定读。

## 二进制日志 bin log

`bin log` 是 MySQL 共有的日志，它与 `redo log` 相似，会记录所有的更新操作。但它是逻辑日志，记录内容是 SQL 语句的原始语义。而 redo log 是物理日志，记录内容是在数据页上做的修改。

`bin log` 的作用是数据备份、主从同步等，保证数据的一致性。`bin log` 记录所有的涉及更新的逻辑操作，并且是顺序写。

### 记录格式

`bin log` 有三种记录格式，可以通过 `binlog_format` 参数指定：

* `statement`
* `row`
* `mixed`

对于 `statement`，`bin log` 记录的是 SQL 语句原文。但这种方式有时不好，比如 `set update_time=now()`，同步数据时，恢复的值与原值是不同的。

这时可以选择 `row`，它会将原文的数据转换为固定的数值，比如 `set update_time=123456789`。

但 `row` 这种格式明显会占用较多的空间，会消耗更多 IO 资源，影响执行速度。所以就有折中的方法：`mixed`，它会检查 SQL 语句是否可能会引起数据不一致，如果是则使用 `row` 格式记录，否则直接记录原文。

`bin log` 日志以二进制方式存储，不能直接读取，需要使用 MySQL 工具 `mysqlbinlog` 查看。

## bin log 与 redo log 的区别

首先，`bin log` 是 MySQL server 层的，所有存储引擎都能使用，而 `redo log` 专属于 InnoDB。

其次，`bin log` 记录的是逻辑日志，而 `redo log` 记录的是物理日志。

最后，`bin log` 会记录所有可能的修改操作，而 `redo log` 的内容在数据刷盘后会被清除。也就是说，`bin log` 记录的是全量日志，`redo log` 记录的是数据文件还未来得及刷盘的数据。这就导致 `bin log` 无法用于数据库的崩溃恢复，因为它没有标记当前数据文件被写入到哪里。

## redo log 的两阶段提交

我们已经知道 `redo log` 会在事务执行期间持续的写入磁盘文件，而 `bin log` 不同，它的写入时机只能是事务提交时。这就有可能导致两份日志的逻辑不一致：`redo log` 已经写入，而 `bin log` 在写入时发生 MySQL 崩溃。恢复时，主机可根据 `redo log` 恢复数据，而从机由于 `bin log` 没来得及记录从而缺少部分更新。

为解决整个问题，InnoDB 使用两阶段提交处理 `redo log` 的写入：将 `redo log` 的写入拆分为两部分。具体内容如下所述。

`redo log` 在事务中间写入的日志，首先标记为 `prepare` 状态，等到 `bin log` 日志写入成功时，`InnoDB` 再将 `prepare` 日志设置为 `commit`，完成日志提交。

如果中间发生异常，`bin log` 处于 `prepare` 状态，需要检查 `bin log` 是否完整：

* 如果 `bin log` 存在并完整，则提交事务。
* 否则，回滚事务。

第一种情况，可能是 `bin log` 已经写入成功，但在报告 MySQL 的时候 MySQL 发生异常。第二种情况，则是 `bin log` 还没写或写到一半的时候 MySQL 发生异常。
