# Linux

# 初识 Linux

## Linux 的起源

20 世纪 60 年代，贝尔实验室的 Ken Thompson  开发出 UNIX 计算机操作系统，该系统被流传使用并逐渐流行。但在 1979 年，AT&T 公司将 UNIX 商业化，开始收费。源代码被当作商业机密，互筑堡垒。

> 有趣的是，为在 UNIX 更方便地编写程序，Ken Thompson 和同事还设计出 c 语言。所以，c 语言与 UNIX 密切相关，它在内核开发领域有着无法替代的地位。

为推动开源精神，Richard Stallman 发起 GNU 源代码开放计划，并制定 GPL 开源协议。1987 年，GNU 取得重大突破——发布 gcc 编译器，这使得程序员能基于该编译器编写自己的开源软件。1991 年，芬兰赫尔辛基大学的在校生 Richard Stallman 开发出类 UNIX 系统 Linux，由于其高质量的代码，Linux 迅速发展。

原始的 Linux 仅提供硬件抽象层、硬盘和文件系统控制、多任务等核心功能，并不算完整的操作系统，所以也把它称作内核 kernel。许多厂商基于内核，集成众多程序软件，开发自己的 Linux 发行版本，并出售技术服务。我们经常使用的，也是成熟的发行版本，而不是空白的 Linux 内核。

## 常见发行版本

根据不同的使用目的和场景，全球开发有数百款 Linux 系统版本，下面介绍常用的几款。

**红帽企业版 Linux，RedHat Enterprise Linux，RHEL**

红帽公司是全球最大的开源技术厂商，RHEL 是使用最广泛的 Linux 系统。RHEL 具有极强的性能与稳定性，并且在全球范围内拥有完善的技术支持。

**社区企业操作系统，Community Enterprise Operating System，CentOS**

通过把 RHEL 系统重新编译并发布给用户免费使用的 Linux 系统，具有广泛的使用人群，当前已被红帽 "收编"。

**Fedora**

红帽公司发布的桌面版 Linux 系统，目前已不限于桌面版。用户可免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 RHEL 系统，因此 Fedora 也称为 RHEL 系统的“试验田”。

**Debian**

稳定性、安全性强，提供免费的基础支持，可以良好地支持各种硬件架构，以及提供近十万种不同的开源软件，在国外拥有很高的认可度和使用率。

**Ubuntu**

派生自 Debian，对新款硬件具有极强的兼容能力。Ubuntu 与 Fedora 都是极其出色的 Linux 桌面系统，而且 Ubuntu 也能用于服务器领域。

**openSUSE**

源自德国，在全球范围内拥有不错的声誉和市场占有率。

**Gentoo**

具有极高的自定制性，操作复杂，适合有经验的人员使用。

# 安装和管理

## 软件管理和安装

### 红帽软件包管理器，RPM

最初，Linux 只能通过源码安装软件，这需要自行编译和解决依赖，非常不便。RPM 类似 Windows 控制面板，建有数据库，以记录软件信息并分析依赖关系。RPM 包是经过编译的程序，可以直接运行，通常以 *.rpm* 作为后缀。

以下是常用的 RPM 命令。

| 命令                    | 说明                      |
| ----------------------- | ------------------------- |
| rpm -ivh [filename].rpm | 安装软件                  |
| rpm -Uvh [filename].rpm | 升级软件                  |
| rpm -e [filename].rpm   | 卸载软件                  |
| rpm -qpi [filename].rpm | 查询软件描述信息          |
| rpm -qpl [filename].rpm | 列出软件文件信息          |
| rpm -qf [filename]      | 查询指定文件属于哪个RPM包 |

> RPM 虽源于红帽系统，但许多 Linux 发行版本也对其支持，它已成为 Linux 软件管理的事实标准。

### yum 软件仓库

尽管 RPM 机制能帮助分析依赖关系，但还是需要自己安装依赖项。使用 RPM 命令安装软件，将返回提示信息告诉你还需安装哪些依赖。这对于依赖较多的软件非常不便，升级软件可能也需要修改依赖的版本。

yum 是 RPM 的包管理器，它从远程仓库下载、安装软件及其依赖，把 RPM 包的安装自动化。yum 支持修改软件仓库，默认使用红帽官方的软件源。

以下是常用的 yum 命令。

| 命令                                        | 说明                         |
| ------------------------------------------- | ---------------------------- |
| yum repolist all                            | 列出所有仓库                 |
| yum list [softname\|all\|installed\|kernel] | 列出一个或一组软件包         |
| yum install [softname]                      | 安装软件包                   |
| yum update [softname]                       | 升级软件包，不指定则升级全部 |
| yum upgrade                                 | 升级软件包，并删除旧版本包   |
| yum remove [softname]                       | 删除软件包                   |
| yum reinstall [softname]                    | 重新安装软件包               |
| yum info [softname]                         | 查看软件包信息               |
| yum clean all                               | 清除所有仓库缓存             |
| yum check-update                            | 检查可更新的软件包           |

## 初始化和服务管理

### 启动流程

Linux 的开机过程大致如此：从 BIOS 开始；进入 Boot Loader；加载系统内核，内核进行初始化；启动初始化进程。初始化进程是系统的首个进程，需要完成初始化工作，为用户提供合适的工作环境。

### 运行级别

RHEL 7 使用 systemd 服务替换原来的 System V init 初始化进程，systemd 采用并发启动机制，显著提升开机速度。systemd 使用目标 target 替代原来运行级别的概念，两者对应关系如下。

| systemd                             | System V init | 说明             |
| ----------------------------------- | ------------- | ---------------- |
| runlevel0.target, poweroff.target   | 0             | 关机             |
| runlevel1.target, rescue.target     | 1             | 单用户模式       |
| runlevel2.target, multi-user.target | 2             | 等同于级别 3     |
| runlevel3.target, multi-user.target | 3             | 多用户的文本界面 |
| runlevel4.target, multi-user.target | 4             | 等同于级别 3     |
| runlevel5.target, graphical.target  | 5             | 多用户的图形界面 |
| runlevel6.target, reboot.target     | 6             | 重启             |
| emergency.target                    | emergency     | 紧急 Shell       |

查看默认 Target。

```
systemctl get-default
```

设置默认 Target。在旧版本，通过编辑 */etc/inittab* 文件修改默认运行级别。

```
systemctl set-default runlevel3.target
```

临时修改 Target。

```
systemctl isolate runlevel3.target
```

RHEL 7 依然支持 init 命令临时切换运行级别。

```
init 级别序号
```

### 服务管理

RHEL 7 使用 systemctl 命令管理服务，RHEL 6 则使用 service、chkconfig 等命令。

| 命令                                 | 说明                       |
| ------------------------------------ | -------------------------- |
| systemctl start [服务名称].service   | 启动服务                   |
| systemctl restart [服务名称].service | 重启服务                   |
| systemctl stop [服务名称].service    | 停止服务                   |
| systemctl reload [服务名称].service  | 重新加载配置，但不终止服务 |
| systemctl status [服务名称].service  | 查看服务状态               |

示例，关闭防火墙服务。

```
systemctl stop firewall.service
```

| 命令                                     | 说明                             |
| ---------------------------------------- | -------------------------------- |
| systemctl enable [服务名称].service      | 开机自动启动                     |
| systemctl disable [服务名称].service     | 禁止自动启动                     |
| systemctl is-enabled [服务名称].service  | 查看指定服务是否自动启动         |
| systemctl list-unit-files --type=service | 查看各个级别服务的启动与禁用情况 |

示例，禁止防火墙自动启动。

```
systemctl disable firewall.service
```

## 系统环境变量

### 相关概念

变量是计算机系统保存可变值的数据类型，可使用 echo 命令查看任何变量的值。变量名一般都是大写，这是约定俗成的规范。Linux 定义有许多环境变量，它们是设置系统运行状态的参数。

Linux 的一切皆文件，Linux 命令也不例外，命令的执行可分为以下四步。

* 判断是否以绝对路径或相对路径的方式输入命令，如果是则直接执行。

* 检查输入的命令是否为 "别名命令"，如果是则直接执行。

  > 设置别名命令 "alias 别名=命令"，取消别名命令 "unalias 别名"，查看别名命令 "alias 别名"。

* 判断输入命令是内部命令还是外部命令。内部命令是 Shell 的指令，直接执行。外部命令交由下一步处理。可使用 "type 命令名称" 查看命令是内部命令还是外部命令。

* 系统将在多个路径查找匹配的命令文件，定义这些路径的变量叫做 PATH，它告诉 Bash 待执行命令可能存放的位置。PATH 由多个路径值组成，每个值使用冒号 : 分隔，尾部没有冒号。

使用 echo 命令查看 PATH 变量，值为 */usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin*。为什么不把当前目录 . 添加到 PATH 呢？这样不是更方便嘛？假如黑客在常用目录放入与 ls、cd 等同名的木马文件，就极容易中招。这也解释为什么，即使我们在相同目录，也必须使用相对路径或绝对路径来运行可执行文件，因为 Bash 根本不会扫描当前目录。

常见的系统环境变量。

| 变量名       | 说明                   |
| ------------ | ---------------------- |
| HOME         | 家目录                 |
| SHELL        | 正使用的 Shell 解释器  |
| HISTSIZE     | 输出的历史命令记录条数 |
| HISTFILESIZE | 保存的历史命令记录条数 |
| MAIL         | 邮件保存路径           |
| LANG         | 系统语言、语系名称     |
| RANDOM       | 生成一个随机数字       |
| PS1          | 解释器的提示符         |
| PATH         | 用户命令文件路径       |

### 作用范围

> 此处仅是个人的解释性理解，并不是真正的原理。

类似 MySQL 状态变量，Linux 也使用分层的方式设置环境变量的值。Linux 默认有许多环境变量，并为它们赋予默认值。用户可通过配置文件，增加环境变量，或修改系统变量的默认值。我们通过 Shell 连接 Linux 时所看到变量，是会话变量，它们是前面所有配置的综合结果。会话变量间相互隔绝，互不影响。

在单个会话，可以设置本地变量。这种变量不具备全局性，作用范围也有限。此时使用 su 切换用户，新环境不会有这个变量。

```
FIRST=001
```

可使用 export 命令，把会话变量提升为 Shell 变量，这种变量在当前窗口有效。此时使用 su 切换用户，新环境会使用旧环境的 Shell 变量进行初始化。

```
export FIRST
```

### 设置方式

**配置文件**

常见的设置环境变量的配置文件，不同版本可能稍有差异。从上到下按序加载。

* */etc/environment*：开机时执行一次。
* */etc/profile*：用户登录时执行一次。
* */etc/bashrc*：打开终端时执行一次。
* *~/.profile*：只对单个用户生效，用户登录时执行一次。
* *~/.bashrc*：只对单个用户生效，打开终端时执行一次。

**临时设置**

使用 export 命令设置环境变量，立即并且只在当前 Shell 生效。

```
export PATH=$PATH:/usr/local/hadoop/bin
```

**永久设置**

根据需求修改配置文件，简单追加 export 命令即可，下例是配置 JDK 环境变量。

```
export JAVA_HOME=/opt/app/jdk1.8.0_321
export PATH=$PATH:$JAVA_HOME/bin
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
```

保存退出，使用 source 命令重新加载配置文件，使之立即生效。

```
source /etc/profile
```

注意，对于 *environment* 文件，不使用 export 命令，而是追加 "var=..." 语句。并且，需重启或注销，才能使之对所有终端生效，source 命令只能让 environment 在当前终端立即生效。

# 基本操作命令

## 命令解释器 shell

Linux 系统内核主要负责硬件资源的分配和管理，它使得各个硬件能协同工作运行，由此可见内核的重要性。直接修改内核参数容易造成安全问题，通常是使用系统调用接口进行管理。

终端 shell 是用户与内核交流的命令行工具，它本质是解释器，解析输入的命令，然后调用相应的系统接口完成工作。包括 RHEL 在内的主流 Linux 发行版本，默认都使用 Bash 终端，RHEL 的 Bash 程序位于 */bin/bash*。

> 除命令行工具外，Linux 还提供有操作更简易的图形化工具，这些工具本质是调用脚本，且应用专门，缺乏灵活性和可控性。而且，相较于命令行，图形工具更加消耗资源。

常见的 Bash 命令使用格式如下所示。对象指要处理的文件、目录、用户等资源；参数有长格式、短格式两种写法，分别以 -- 和 - 作为前缀，短格式的多个字母可以合并，比如 ps -aux；有些参数需要设置值，可能是在参数后追加空格和值，也可能使用等号 = 赋值。

```
命令名称 参数 对象
```

如果终端正在执行某个命令，可使用 Ctrl+c 终止该进程。

如果某个命令不断输出信息，搅乱屏幕，可在命令尾部追加 & 符号，使该命令后台运行。

## 帮助查看 man

遇到不熟悉的命令，可以使用 man 命令查看它的作用、参数等信息。

```
man 命令名称
```

命令 man 返回的信息非常多，按段落分隔，各段的作用如下所示。

| 名称        | 说明               |
| ----------- | ------------------ |
| NAME        | 命令名称           |
| SYNOPSIS    | 参数简介           |
| DESCRIPTION | 介绍说明           |
| EXAMPLES    | 使用演示           |
| OVERVIEW    | 基本概述           |
| DEFAULTS    | 默认功能           |
| OPTIONS     | 具体选项           |
| ENVIRONMENT | 环境变量           |
| FILES       | 涉及文件           |
| SEE ALSO    | 相关资料           |
| HISTORY     | 维护历史与联系方式 |

## 普通工作命令

### 关机和重启

shutdown 命令既能关机，也能重启。参数 -h 指定多少分钟后关机，参数 -r 指定多少分钟后重启。

```
shutdown -h -now/1/3	# 立刻/1分钟后/3分钟后关机
```

立即关机。

```
poweroff
```

立即关机

```
halt
```

立即重启。

```
reboot
```

把内存数据同步至磁盘，shutdown、halt、reboot 都会先执行该操作。

```
sync
```

### 终端打印 echo

打印字符串或变量值，字符串使用单引号、双引号括起。

```
echo 字符串|$变量名
```

若要打印命令的运行结果，使用 `` 括起命令。

```
echo `命令`
```

### 时间日期 date

查看或设置系统的时间和日期。参数以 "+" 开头，就按指定格式输出时间。默认打印时间，参数 -s 设置时间。

```
date <参数> <"+指定格式">
```

以下占位符用于设定时间格式。

| 符号 | 说明         |
| ---- | ------------ |
| %t   | 空格         |
| %H   | 小时，00～23 |
| %M   | 分钟，00～59 |
| %S   | 秒，00～59   |
| %Y   | 年           |
| %m   | 月           |
| %d   | 日           |
| %I   | 小时，00～12 |
| %j   | 今年第几天   |

示例，按指定格式打印时间。

```
date "+%Y-%m-%d %H:%M:%S"
```

示例，设置新的系统时间。

```
date -s "20170901 8:30:00"
```

```
date -s "2020-11-03 8:30:00"
```

### 下载文件 wget

根据网络地址下载文件。

```
wget <参数> 下载地址
```

| 参数 | 说明                               |
| ---- | ---------------------------------- |
| -b   | 后台进行                           |
| -P   | 存放目录                           |
| -t   | 最大尝试次数                       |
| -c   | 断点续传                           |
| -p   | 下载页面所有资源，包括图片、视频等 |
| -r   | 递归下载                           |

### 编译和安装 make

实际开发过程中，由于开发需求，常需要对一些软件进行源码安装

软件源码包解压后，解压目录通常包含configure 文件，其中配置编译参数，如果没有特殊要求，只需执行如下命令便可以完成源码编译安装

```
./configure
```

```
make
```

```
sudo make install
```

默认安装目录常为`/usr/local/`

以下方法可以修改默认安装目录

1. 修改configure 文件，prefix=安装目录

2. 执行configure 时指定安装目录

   ```
   ./configure --prefix=安装目录
   ```

3. make install 时指定安装目录

   ```
   make install DESTDIR=安装目录
   ```

## 进程状态检测

### 进程状态 ps

查看系统的进程状态。参数 -a 显示包括属于其它用户的所有进程；参数 -f 显示全格式，包括 PPID；参数 -u 显示进程的用户以及其它详细信息；参数 -x 显示没有控制终端的进程。

```
ps -aux
```

命令 ps 的返回信息是表格，各列说明如下所示。

| 列项    | 说明                                                 |
| ------- | ---------------------------------------------------- |
| USER    | 所有者                                               |
| PID     | 进程ID                                               |
| PPID    | 父进程ID，0表示原始进程                              |
| %CPU    | CPU占用率                                            |
| %MEM    | 内存占用率                                           |
| VSZ     | 虚拟内存使用量，单位 KB                              |
| RSS     | 固定内存使用量，单位 KB                              |
| TTY     | 所在终端缩写                                         |
| STAT    | 进程状态，R 运行、S 中断、D 不可中断、Z 僵死、T 停止 |
| START   | 启动时间                                             |
| TIME    | 实际使用 CPU 的时间                                  |
| COMMAND | 启动的命令和参数                                     |

### 监视进程 top

动态监视进程活动和系统负载等状态信息。

```
top
```

返回信息可按空行分成两段，后半段是进程信息，与 ps 命令的返回相似。前半段是系统状态，共有五行，各行说明如下所示。

| 位置   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 第一行 | 系统时间、运行时间、登录终端数、系统负载，分别是 1、5、15 分钟内的平均负载。 |
| 第二行 | 进程数量：总数、运行中数量、睡眠中数量、停止数量、僵死数量。 |
| 第三行 | CPU资源：用户占用百分比、内核占用百分比、优先级变更过的进程占用百分比、空闲百分比等。 |
| 第四行 | 物理内存：总量、使用量、空闲量、作为内核缓存的量。           |
| 第五行 | 虚拟内存：总量、使用量、空闲量、已被提前加载的量。           |

### 进程编号 pidof

根据服务名称查询其所有进程的 PID 值，PID 是进程的 ID，唯一且不可变。

```
pidof 服务名
```

### 关闭进程 kill

根据 PID 值杀死指定的进程，参数 -9 表示强制执行。

```
kill <-9> 进程PID
```

### 关闭服务 killall

根据服务名杀死进程及子进程，支持通配符。复杂应用常包含多个进程共同工作。

```
killall 服务名
```

### 进程树 pstree

查看按父子关系而组成的树状图。参数 -p 显示进程 ID，参数 -u 显示进程所属用户，参数 -A 使用 ASCII 字符连接结点，参数 -U 使用 UTF-8 字符连接结点。

```
pstree -pu
```

> 安装 pstree 命令的软件包。
>
> ```
> yum -y install psmisc
> ```

## 系统状态检测

### 网络信息 ifconfig

查看网卡配置、网络状态等信息。每个网卡的信息组织为单独的段落，以网卡名称开头。inet 和 ether 字段表示 IP 地址和 MAC 地址，RX 和 TX 表示接收、发送数据包的个数和累计流量。

```
ifconfig
```

### 负载信息 uptime

查看系统的负载信息。它的返回信息与 top 命令的第一行类似，即系统时间、运行时间、登录终端数、系统负载，分别是 1、5、15 分钟内的平均负载，值越小负载越低，尽量不长期超过 1，生产环境不要超过 5。

```
uptime
```

> **平均系统负载 load average**
>
> 指定时间段内，系统中处于可运行、等待但不可中断的平均线程数量。值越低越好，0.00 表示没有线程运行或等待，CPU 空闲。0.50 表示 CPU 正以 %50 的负荷运行，新的线程能立即申请到 CPU 时间片。1.00 表示 CPU 正以 %100 的负荷运行，新的线程需等待另一个线程结束或 CPU 时间片过期。1.50 表示 CPU 满负荷工作，若有 15 个线程请求运行，其中 5 个需要等待 CPU 时间片。
>
> 对于多处理器或多核心的系统，负载的含义取决于处理器、核心的数量。若有 4 个处理器，那么系统在负载达到 4.00 之前不会满负荷工作。文件 */proc/cpuinfo* 保存着 CPU 的信息。

### 内存信息 free

查看内存的使用情况，参数 -h 将以更易阅读的方式显示信息。返回信息组织为表格，各列分别表示总量、已用量、可用量、进程共享使用量、磁盘缓存使用量、内存缓存使用量。

```
free -h
```

### 系统内核 uname

查看系统内核信息。参数 -a 返回详细内容，分别是内核名称、主机名、内核版本、节点名、系统时间、硬件名称、硬件平台、处理器类型、操作系统名称等。

```
uname -a
```

> 如果要查看当前发行版本的版本信息，可查看 */etc/redhat-release* 文件。

###  用户终端 who

查看当前登录的用户终端信息，包括用户名、终端设备、登录时间。

```
who
```

### 登录记录 last

查看登录记录，last 的信息以日志文件的形式保存，可能被篡改。

```
last
```

### 命令历史 history

查看执行过的命令。默认记录 1k 条命令，可修改 */etc/profile* 文件的 HISTSIZE 变量值来自定义历史记录上限。可使用 "!编号" 命令重复执行历史命令。参数 -c 清除所有历史记录。

```
history <-c>
```

> 命令历史保存在用户目录的 *.bash_history* 文件。

## 文件目录管理

### 当前路径 pwd

查看当前目录的绝对路径。

```
pwd
```

### 切换目录 cd

切换工作目录，目标路径可以是绝对路径或相对路径。此外，cd - 切换到上次所处目录，cd .. 切换到上级目录，cd ~ 切换到当前用户家目录，cd ~username 切换到指定用户家目录。

```
cd 目标路径
```

### 文件信息 ls

查看指定目录的文件信息。参数 -a 显示包括隐藏文件的全部文件，参数 -l 显示文件属性，参数 -d 显示目录属性。默认查看当前目录。

```
ls <参数> 目录路径
```

示例，查看文件属性。返回信息按行描述文件，包含文件类型、所有者所属组其它人的权限、硬连接引用次数、所有者名字、所属组名字、文件大小 KB、最近一次修改时间、文件名。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-8bd03018.png)

### 创建文件 touch

创建空白文件，或设置文件时间。参数 -a 修改读取时间，参数 -m 修改修改时间，参数 -d 修改读取时间和修改时间。

```
touch <参数> 文件名
```

示例，修改文件的读取时间。

```
touch -a "2017-05-04 15:44" anaconda-ks.cfg
```

### 创建目录 mkdir

创建空目录，如要创建多层目录，需使用 -p 参数递归执行。

```
mkdir <-p> 目录
```

### 复制文件 cp

复制文件或目录。如果目标文件是目录，则把源文件复制到目录内；如果目标文件是普通文件如果目标文件是普通文件，则询问是否覆盖；如果目标文件不存在，则正常复制。

参数 -p 保留源文件的属性，参数 -r 递归复制目录，参数 -i 当目标文件存在则询问是否覆盖，参数 -d 保留链接文件的属性，参数 -a 等价于 -pdr。

```
cp <参数> 源文件 目标文件
```

### 移动文件 mv

移动文件，如果目标文件与源文件同目录，相当于对源文件重命名。

```
mv 源文件 目标文件
```

### 删除文件 rm

删除文件，删除目录时需使用 -r 参数递归执行。Linux 在删除文件时，默认要进行二次确认，可使用 -f 参数强制执行，略去确认步骤。

```
rm <参数> 文件
```

### 文件类型 file

查看文件类型。Linux 的文件，无法从后缀判断其类型。

```
file 文件
```

### 内容拷贝 dd

按照指定大小和个数的数据块，复制或转换文件。参数 if 指定输入文件；参数 of 指定输出文件；bs 指定块的大小，单位可选 KB、M、G；count 指定块的数量。bs 和 count 组合指定容量，只要满足需求，可随意调整，如不指定，则拷贝输入文件的所有内容。

示例，创建指定大小的文件。设备文件 */dev/zero* 不占用存储空间，但能无限提供数据。

```
dd if=/dev/zero of=newFile count=1 bs=500M
```

示例，把光驱设备中的光盘制作为 iso 格式的镜像文件。

```
dd if=/dev/cdrom of=RHEL-server-7.0-x86_64.iso
```

## 文本文件编辑

### 查看文本 cat

直接显示文本文件全部内容。

```
cat 文件
```

### 按页读取 more

以全屏方式按页阅读。空格或 Ctrl+f 向下翻页，Ctrl+b 向上翻页，回车向下滚动一行，q 离开。读到末尾自动退出。

```
more 文本源
```

### 按页读取 less

以全屏方式按页阅读。pagedown 向下翻页，pageup 向下翻页，"/字串" 向下搜索关键字，"?字串" 向下搜索关键字，q 离开阅读。

```
less 文本源
```

### 头部内容 head

查看文本前 N 行，参数 -n 指定多少行。

```
head -n N 文件
```

### 尾部内容 tail

查看文本文件的尾 N 行，参数 -n 指定多少行，参数 -f 持续动态更新尾部内容。

```
tail -fn N 文件
```

### 内容替换 tr

把文件内的原始字符替换为指定字符。

```
tr 原始字符 目标字符
```

示例，把所有字母替换为大写。

```
cat anaconda-ks.cfg | tr [a-z] [A-Z]
```

### 文件信息 stat

查看文件属性，包括访问时间、修改时间等。

```
stat 文件
```

### 按行过滤 grep

根据关键字过滤匹配的行。参数 -i 忽略大小写，参数 -v 返回不匹配的行，参数 -n 显示行号，参数 -c 只返回匹配的行数，参数 -b 将可执行文件当作文本文件搜索。

```
grep <参数> 关键字 文本源
```

### 按列过滤 cut

按列提取文本，参数 -f 指定显示第几列，参数 -d 指定列的分隔符。

```
cut 参数 文本源
```

示例，查看第一列，以 : 作为分隔符。

```
cut -d: -f1 /etc/passwd
```

### 比较不同 diff

对比两个文本内容的差异，参数 --brief 只返回两文件是否不同，参数 -c 显示具体差异。

```
diff <参数> 文件 文件
```

### 管道命令符 |

把前一个命令原本要输出到屏幕的数据当作后一个命令的标准输入。

## 打包压缩和搜索

### 压缩解压 tar

压缩或解压。Linux 有多种压缩格式，主要使用 .tar 或 .tar.gz 或 .tar.bz2，它们都能使用 tar 命令。

| 参数 | 说明                             |
| ---- | -------------------------------- |
| -c   | 打包                             |
| -x   | 解压                             |
| -t   | 查看压缩包有哪些文件             |
| -z   | 使用 Gzip 格式                   |
| -j   | 使用 bzip2 格式                  |
| -v   | 显示过程                         |
| -f   | 打包或解压的文件名，必须放到最后 |
| -P   | 保留原始的权限和属性             |
| -p   | 使用绝对路径进行压缩             |
| -C   | 指定解压到的目录                 |

常见打包命令。

```
tar -czvf 压缩包名.tar.gz 打包目录
```

常见解压命令。

```
tar -xzvf 压缩包名.tar.gz -C 解压目录
```

### 压缩解压 zip

按 zip 格式压缩文件，参数 -r 递归压缩目录。

```
zip <-r> 文件或目录
```

按 zip 格式解压文件，参数 -d 指定解压目录。

```
unzip -d 解压目录 压缩包
```

### 查找文件 find

按指定条件查找文件并返回结果，默认从当前目录开始查找。

```
find 查找路径 查找条件
```

以下参数用于指定查找匹配条件。

| 参数               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| -name              | 文件名                                                       |
| -perm              | 权限，mode 完全匹配，-mode 包含即可                          |
| -user              | 所有者                                                       |
| -group             | 所属组                                                       |
| -mtime -n +n       | 修改内容的时间，-n 表示 n 天以内，+n 表示 n 天以前           |
| -atime -n +n       | 访问文件的时间，-n 表示 n 天以内，+n 表示 n 天以前           |
| -ctime -n +n       | 修改文件权限的时间，-n 表示 n 天以内，+n 表示 n 天以前       |
| -nouser            | 无所有者                                                     |
| -nogroup           | 无所属组                                                     |
| -newer F1 !F2      | 比文件 F1 新但比 F2 旧                                       |
| --type b/d/c/p/l/f | 文件类型，后面字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件 |
| -size              | 文件大小，+50KB 表示超过 50KB，-50KB 表示小于 50KB           |
| -prune             | 忽略指定目录                                                 |
| -exec …… {}\;      | 进一步处理搜索结果，{} 表示查找结果，\ 是结束符              |

示例，从 */etc* 开始查找名称匹配的文件。

```
find /etc -name "host*"
```

示例，将所有者为 tony 的文件拷贝到 */root/findresults/* 目录。

```
find / -user tony -exec cp -a {} /root/findresults/ \;
```

## 输入输出重定向

与许多系统相同，Linux 有 3 种标准输入输出流，如下表所示。

| IO 流      | 变量名 | 文件描述符 | 数据源/汇 |
| ---------- | ------ | ---------- | --------- |
| 标准输入流 | STDIN  | 0          | 键盘      |
| 标准输出流 | STDOUT | 1          | 屏幕      |
| 标准错误流 | STDERR | 2          | 屏幕      |

> 执行 Bash 命令，返回的错误信息，其实都是发送到标准错误流。

重定向就是重新定义流的源或汇，Bash 使用以下操作符进行重定向。尽管源和汇是泛指，但通常都是文件。

| 符号           | 说明                               | 示例                             |
| -------------- | ---------------------------------- | -------------------------------- |
| 命令 < 文件    | 重定向标准输入                     | wc -l < words.txt                |
| 命令 << 终止符 | 持续从键盘读入数据，直到遇见终止符 | mail -s "Subject" pochai << over |

| 符号            | 说明                                     | 示例           |
| --------------- | ---------------------------------------- | -------------- |
| 命令 [1]> 文件  | 重定向标准输出，清空原文件               | ls > tmp.txt   |
| 命令 [1]>> 文件 | 重定向标准输出，追加原文件               | ls >> tmp.txt  |
| 命令 2> 文件    | 重定向标准错误，清空原文件               | ls 2> tmp.txt  |
| 命令 2>> 文件   | 重定向标准错误，追加原文件               | ls 2>> tmp.txt |
| 命令 &>> 文件   | 同时重定向标准输出和标准错误，追加原文件 | ls &>> tmp.txt |

# 文本编辑器 vim

Linux 虽内置有 vi 文本编辑器，但 vim 更常用，它是 vi 的拓展，有三种模式，分别支持不同的操作和命令。

* 命令模式：控制光标移动，可对文本进行复制、粘贴、删除、查找等操作。
* 编辑模式：正常的文本编辑。
* 末行模式：保存或退出文档，以及设置编辑环境。

使用 vim 打开文件，初始为命令模式，模式的切换方法如下所示。其中，i 键在当前位置进入编辑，a 键在后一位进入编辑，而 o 键在下面新创建一行进入编辑。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-d98ca785.png)

命令模式常用命令。

| 命令        | 说明                             |
| ----------- | -------------------------------- |
| dd          | 剪切光标所在行                   |
| ndd         | 剪切从光标开始的 n 行            |
| yy          | 复制光标所在行                   |
| nyy         | 复制从光标开始的 n 行            |
| /<字符串>   | 从光标向后搜索关键字             |
| ?<字符串>   | 从光标向前搜索关键字             |
| n           | 定位到搜索匹配的下一个关键字     |
| N           | 定位到搜索匹配的上一个关键字     |
| u           | 撤销上一步操作                   |
| p           | 把剪切或复制的数据粘贴到光标后面 |
| gg          | 把光标移动到第一行               |
| G           | 把光标移动到最后一行             |
| n + Shift+g | 把光标移动到第 n 行              |

末行模式常用命令。

| 命令          | 说明                            |
| ------------- | ------------------------------- |
| w             | 保存                            |
| q             | 退出                            |
| !             | 强制执行                        |
| wq!           | 强制保存退出                    |
| set nu        | 显示行号                        |
| set nonu      | 不显示行号                      |
| :命令         | 执行该命令                      |
| :n            | 跳转到第 n 行                   |
| :s/one/two    | 把光标行的第一个 one 替换成 two |
| :s/one/two/g  | 把光标行的所有 one 替换成 two   |
| :%s/one/two/g | 把全文的所有 one 替换成 two     |

# 用户和文件权限

## 用户身份和能力

### 相关概念

Linux 支持多用户同时工作，具备较高的安全性。安装 Linux 时需设置 Root 用户密码，这是 Linux 的超级用户，拥有最高权限，能管理系统的各项功能。

用户编码 UID（User IDentification）是用户的标识符。Linux 把 UID 为 0 的用户看作管理员。为防止出现漏洞的服务被黑客提权至整台服务器，预设有 UID 为 1~999 的系统用户，默认服务程序将由系统用户负责运行，从而控制它们的破坏范围。管理员创建的用户，UID 从 1000 开始。

为统一管理多个用户，Linux 引入用户组概念。每创建一个用户，将自动创建一个同名的基本用户组，并通过用户组编码 GID（roup IDentification）把用户加入到基本组。所以，基本用户组只有一个同名的用户。此外，用户还能加入其它的拓展用户组。

### 查看用户 id

查看用户基本属性，包括 UID、GID、所属用户组。

```
id 用户名
```

### 创建用户 useradd

```
useradd <参数> 用户名
```

| 参数 | 说明                                        |
| ---- | ------------------------------------------- |
| -d   | 用户家目录，默认 */home/username*           |
| -e   | 用户过期时间，格式 YYYY-MM-DD，默认永久有效 |
| -u   | UID                                         |
| -g   | 用户基本组，这个组必须已存在                |
| -N   | 不创建基本用户组                            |
| -G   | 一个或多个扩展用户组                        |
| -s   | 默认 Shell 解释器，默认 */bin/bash*         |

### 删除用户 userdel

```
userdel <参数> 用户名
```

| 参数 | 说明                         |
| ---- | ---------------------------- |
| -f   | 强制删除                     |
| -r   | 同时删除用户家目录，默认保留 |

### 修改用户 usermod

修改用户属性。Linux 的一切皆文件，用户信息保存在 */etc/passwd* 文件，可以直接修改文件内容，但建议使用命令进行修改。

```
usermod 参数 用户名
```

| 参数  | 说明                                         |
| ----- | -------------------------------------------- |
| -c    | 备注信息                                     |
| -d -m | 两参数连用，重新设置用户家目录，并转移旧数据 |
| -e    | 用户过期时间，格式 YYYY-MM-DD                |
| -g    | 基本用户组                                   |
| -G    | 扩展用户组                                   |
| -L    | 锁定用户，禁止其登录系统                     |
| -U    | 解锁用户，允许其登录系统                     |
| -s    | 默认 Shell 解释器                            |
| -u    | UID                                          |

### 用户命令 passwd

修改用户的认证信息、过期时间等。默认修改当前用户，只有 Root 能修改其它用户，且不需验证旧密码。

```
passwd <参数> 用户名
```

| 参数    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| -l      | 锁定用户，禁止用户登录                                       |
| -u      | 解除锁定，允许用户登录                                       |
| -S      | 查看用户的密码是否被锁定，以及密码所采用的加密算法名称       |
| --stdin | 通过标准输入修改用户密码，比如 echo "NewPassWord" \| passwd username |
| -d      | 允许用户空密码登录                                           |
| -e      | 强制用户下次登录时修改密码                                   |

### 切换用户 su

减号 - 表示完全切换到新用户，即把环境变量信息也进行更新，默认将用旧环境的信息初始化新环境。

```
su <-> 用户名
```

### 创建用户组 groupadd

```
groupadd 组名
```

## 文件权限和归属

### 相关概念

Linux 的文件都有所属的用户和用户组，并对所有者、所属组、其它人分别设有可读、可写、执行权限。对于普通文件，可读、可写、执行没有理解难度，但对于目录文件，可读表示能读取目录内的文件列表，可写表示能在目录内新增、删除、重命名文件，可执行表示能进入目录。

可以使用 w、r、x 分别表示可读、可写、执行，若要使用数字表示权限，首先把字母序列转化为二进制序列，然后再转化为十进制数值。

Linux 的文件具有类型，使用字符进行区分，如下所示。ls -l 的返回信息，每行的首个字符就是文件类型。

| 文件类型字符 | 说明         |
| ------------ | ------------ |
| -            | 普通文件     |
| d            | 目录文件     |
| l            | 链接文件     |
| p            | 管道文件     |
| b            | 块设备文件   |
| c            | 字符设备文件 |

### 修改权限 chmod

参数 -R 表示对目录进行递归操作。权限参数是字母或数字，比如 rwxrw----、760。还能使用 +、- 增减某个权限，此处 u 表示所有者，g 表示所属组，o 表示其它人，a 表示全部，比如 g+w 将为所属组增加可写权限。

```
chmod 权限参数 文件
```

示例，使用数字修改文件权限。

```
chmod 777 filename
```

### 修改所属 chown

修改文件的所有者和所属组，参数 -R 表示对目录进行递归操作。用户和用户组能单独存在，此时只修改文件的所有者或所属组。

```
chown [用户][:用户组] 文件
```

示例，修改所有者。

```
chown username linuxprobe
```

示例，修改所属组。

```
chown :groupname linuxprobe
```

## 身份执行命令 sudo

通过 sudo 服务，使得当前用户能以其它用户的身份去执行某些操作，从而避免切换用户身份。

```
sudo <参数> <命令>
```

| 参数           | 说明                                   |
| -------------- | -------------------------------------- |
| -h             | 帮助信息                               |
| -l             | 查看当前用户可执行的命令               |
| -u 用户名或UID | 以指定的身份执行命令，默认 Root 用户   |
| -k             | 清空密码的有效时间，下次执行需重新验证 |
| -b             | 后台执行                               |
| -p             | 更改验证密码的提示语                   |

初始，只有 Root 用户有 sudo 的执行权限，其它用户需要进行配置，定义允许哪个用户以什么身份执行什么命令，配置文件是 */etc/sudoers*。除使用 vim 编辑配置，还能用 visudo 命令进行修改，该命令使用 vi 打开配置文件，禁止多个用户同时修改文件，并检查配置参数的语法。

> 只有 Root 用户有 */etc/sudoers* 的写权限和 visudo 命令的执行权限。

示例，允许用户 username 在任何主机，以任何身份，执行任何命令。

```
username ALL=(ALL) ALL
```

示例，允许用户 username 在任何主机，以任何身份，执行 */usr/bin/cat* 命令。

```
username ALL=(ALL) /usr/bin/cat
```

还能使用 NOPASSWD 参数，使用户使用 sudo 命令时不再需要密码验证。

```
username ALL=NOPASSWD: ALL
```

# 防火墙管理工具

## 相关概念

防火墙是公网与内网之间的保护屏障，旨在保障数据的安全，它根据定制的策略对穿越的流量进行过滤。

RHEL 7 新增 firewalld 服务，以取代之前的 iptables 服务，它们是定义防火墙策略的工具，iptables 把定义的策略交给内核层的 netfilter 网络过滤器处理，firewalld 则是交给内核层的 nftables 包过滤框架处理。防火墙是一种概念，内核层根据策略执行相关的过滤操作，以形成所谓的"墙"。如果需要，也可以使用其它的防火墙工具，反正最终目的，是快捷地定制合适的策略。

## 防火墙 firewalld

RHEL 7 集成有多款防火墙管理工具，其中 firewalld（Dynamic Firewall Manager of Linux systems）是默认服务，它有命令行 CLI 和图形界面 GUI 两种使用方式。

### 区域 zone

firewalld 支持动态更新，并引入区域 zone 的概念。区域是防火墙策略的集合，用户能随意切换区域，以适应不同场景。以下是常见区域的说明。

| 区域名称 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| trusted  | 允许所有的数据包                                             |
| home     | 拒绝流入的流量，除非与流出的流量相关；允许与 ssh、mdns、ipp-client、amba-client、dhcpv6-client 服务相关的流量 |
| internal | 等同 home 区域                                               |
| work     | 拒绝流入的流量，除非与流出的流量相关；允许与 ssh、ipp-client、dhcpv6-client 服务相关的流量 |
| public   | 默认。拒绝流入的流量，除非与流出的流量相关；允许与 ssh、dhcpv6-client 服务相关的流量 |
| external | 拒绝流入的流量，除非与流出的流量相关；允许与 ssh 服务相关的流量 |
| dmz      | 拒绝流入的流量，除非与流出的流量相关；允许与 ssh 服务相关的流量 |
| block    | 拒绝流入的流量，除非与流出的流量相关                         |
| drop     | 拒绝流入的流量，除非与流出的流量相关                         |

### 命令 firewall-cmd

> 开启 firewall 服务，RHEL 7 默认启动。
>
> ```
> systemctl start firewalld.service
> ```
>
> 关闭 firewall 服务。
>
> ```
> systemctl stop firewalld.service
> ```
>
> 禁止 firewall 服务自动启动
>
> ```
> systemctl disable firewalld.service
> ```

命令 firewall-cmd 设置的策略默认是临时的，重启后失效，若想让配置永久生效，需添加 --permanent 参数。永久的配置在系统重启后才能生效，可以使用 --reload 参数重新加载配置，使其立即生效。

| 参数                          | 说明                                                 |
| ----------------------------- | ---------------------------------------------------- |
| --state                       | 查看服务状态                                         |
| --get-default-zone            | 查看默认区域名称                                     |
| --set-default-zone=<区域名称> | 设置默认区域，永久生效                               |
| --get-zones                   | 查看可用区域                                         |
| --get-services                | 查看预先定义的服务                                   |
| --get-active-zones            | 查看当前正在使用的区域和网卡名称                     |
| --add-source=IP               | 将源自此 IP 或子网的流量导向指定区域                 |
| --remove-source=IP            | 不再将源自此 IP 或子网的流量导向某个区域             |
| --add-interface=<网卡名称>    | 将源自此网卡的流量导向指定区域                       |
| --change-interface=<网卡名称> | 将某个网卡与区域进行关联                             |
| --list-all                    | 查看当前区域的网卡配置参数、资源、端口以及服务等信息 |
| --list-all-zones              | 查看所有区域的网卡配置参数、资源、端口以及服务等信息 |
| --list-ports                  | 查看开放的所有端口                                   |
| --add-service=<服务名>        | 设置默认区域允许指定服务的流量                       |
| --remove-service=<服务名>     | 设置默认区域禁止指定服务的流量                       |
| --add-port=<端口号/协议>      | 设置默认区域允许指定端口的流量                       |
| --remove-port=<端口号/协议>   | 设置默认区域禁止指定端口的流量                       |
| --reload                      | 重新加载永久配置。                                   |
| --panic-on                    | 开启应急状况模式，阻断所有网络连接                   |
| --panic-off                   | 关闭应急状况模式                                     |

示例，设置默认区域。

```
firewall-cmd --permanent --set-default-zone=public
```

示例，查看 public 区域开放的所有端口。

```
firewall-cmd --zone=public --list-ports
```

示例，把 external 设为 eno101 网卡的默认区域。

```
firewall-cmd --permanent --zone=external --change-interface=eno101
```

示例，允许访问 8080 和 8081 端口的流量。

```
firewall-cmd --permanent --zone=public --add-port=8080-8081/tcp
```

示例，查看 public 区域是否允许 SSH 协议的流量。

```
firewall-cmd --zone=public --query-service=ssh
```

示例，把流向 80 端口并基于 TCP 协议的流量转发到 192.168.0.101:90 端口。

```
firewall-cmd --zone=public 
		--add-forward-port=port=80:proto=tcp:toport=90:toaddr=192.168.0.101
```

# 远程控制服务

## 相关概念

SSH 是应用层的文件传输协议，它将内容加密和压缩，是目前远程管理 Linux 的主流方式。在此之前，还曾使用过 FTP 和 Telnet 协议，但它们是明文传输，非常不安全。

OpenSSH 是 SSH 的开源实现，进程名为 sshd，它有两种安全验证方式：口令、密钥。Linux 和 Mac 默认安装该程序的服务端和客户端，Windows 常见的 SSH 实现有 XShell、PuTTY。

> 安装 OpenSSH 服务端、客户端软件包。
>
> ```
> yum -y install openssh-server|openssh-client
> ```

## 配置信息

相关配置文件。

| 配置文件               | 作用                                 |
| :--------------------- | :----------------------------------- |
| ~/.ssh/known_hosts     | 作为客户端，记录服务端的授权。       |
| ~/.ssh/authorized_keys | 作为服务端，保存客户端的公钥文件     |
| ~/.ssh/config          | 作为客户端，记录连接服务器配置的别名 |

服务 sshd 的配置信息保存在 */etc/ssh/sshd_config* 文件，下表是一些重要参数。

| 参数                   | 默认                      | 说明                                    |
| ---------------------- | ------------------------- | --------------------------------------- |
| Port                   | 22                        | SSHD 的服务端口                         |
| ListenAddress          | 0.0.0.0                   | 监听IP地址                              |
| Protocol               | 2                         | SSH 协议版本号                          |
| HostKey                | /etc/ssh/ssh_host_key     | SSH 协议版本为 1 时，DES 私钥的存放位置 |
| HostKey                | /etc/ssh/ssh_host_rsa_key | SSH 协议版本为 2 时，RSA 私钥的存放位置 |
| HostKey                | /etc/ssh/ssh_host_dsa_key | SSH 协议版本为 2 时，DSA 私钥的存放位置 |
| PermitRootLogin        | yes                       | 是否允许 Root 用户直接登录              |
| StrictModes            | yes                       | 远程用户的私钥改变时直接拒绝连接        |
| MaxAuthTries           | 6                         | 最大密码尝试次数                        |
| MaxSessions            | 10                        | 最大终端数                              |
| PasswordAuthentication | yes                       | 是否允许密码验证                        |
| PermitEmptyPasswords   | no                        | 是否允许空密码登录                      |

## 别名配置

使用 ssh 连接远程主机，需要显式设置连接端口、远程 IP、username、userpassword 等信息，较为繁琐。可以把这些连接参数打包保存到 *~/.ssh/config* 配置文件，如下所示。

> 文件 *config* 可能不存在，需要自己创建。

```
Host 别名
  HostName IP
  <User 用户名，默认Root>
  <Port 端口，默认22>
  <IdentityFile 密钥文件>
```

直接使用别名进行远程登录。

```
ssh 别名
```

## 口令验证 ssh

使用密码进行口令验证。参数 -p 指定连接端口，默认 22。username 可选，默认 root 用户。

```
ssh <参数> <username@>IP
```

示例。

```
ssh -p 22 username@192.168.200.101
```

## 密钥验证 ssh

加密是对信息进行编码和解码的技术，它使用指定算法，把明文转化为密文。密钥是密文的钥匙，有私钥和公钥之分。传输前，使用公钥对数据进行加密，得到密文。接收后，使用私钥对密文进行处理，得到明文。这样，即使网络包被截获，信息也不会泄露。密钥验证使得 sshd 的远程登录更加安全。以下是配置密钥验证的步骤。

客户端生成密钥对。参数 -t 指定加密算法，默认 RSA；参数 -C 设置注释，追加到密钥文件尾部；参数 -f 指定密钥文件，对于 RSA 算法，默认，私钥 *~/.ssh/id_rsa*，公钥 *~/.ssh/id_rsa.pub*。

```
ssh-keygen <参数>

#####
ssh-keygen -t rsa -b 2048  -C "rsa key"  -f "github" 
```

客户端把公钥传输给远程主机的某个用户。参数 -i 指定公钥文件，username 可选，默认 root 用户，此时要输入远程主机对应用户的密码。

```
ssh-copy-id <参数> <username@>IP
```

现在，客户端的当前用户就能直接以预设的用户身份登录远程主机。

```
ssh IP
```

## 远程传输 scp

服务 sshd 的命令 scp 基于 SSH 协议进行文件传输。参数 -v 显示传输进度，参数 -P 指定连接端口，参数 -r 递归传输目录，参数 -6 使用 IPv6 协议，参数 -i 指定公钥文件，username 可选，默认 root 用户。

> 执行 scp 时需要进行安全验证，若已经设有密钥，此步跳过。

把本地文件传输到远程目录。

```
scp <参数> 本地文件 <username@>IP:远程目录
```

把远程文件复制到本地目录。

```
scp <参数> <username@>IP:远程文件 本地目录
```

# 计划任务服务

## 定时任务 at

服务 atd 提供定时任务的功能，它把任务按执行时间组成队列，后台进程 atd 持续检查队头任务，如果到期，则将其弹出并执行。

命令 at 负责添加、删除、查看任务。默认添加，进入任务编辑，Ctrl+d 退出，设置完成。

```
at <选项> 时间
```

| 参数    | 说明                                   |
| ------- | -------------------------------------- |
| -f 文件 | 从指定文件而非标准输入读入任务内容     |
| -m      | 任务完成后，邮件通知用户               |
| -v      | 显示执行时间                           |
| -V      | 显示任务版本                           |
| -l      | 查看所有的未执行任务，等同 "atq"       |
| -d 序号 | 删除指定的未执行任务，等同 "atrm 序号" |

> **灵活的时间设置**
>
> 当天执行，直接 hh:mm 指定，若该时间已过，则放到第二天执行。
>
> ```
> at 23:30
> ```
>
> 具体日期，格式 yy-mm-dd、mm/dd/yy 等，日期放到时间后面。
>
> ```
> at 12:00 2022-12-30
> ```
>
> 支持 12 小时制，用 am、pm 表示上午、下午。
>
> ```
> at 11:30pm
> ```
>
> 可用 midnight、noon 等词模糊指定时间。
>
> ```
> at midnight
> ```
>
> 可用 today、tomorrow 等词指定日期。
>
> ```
> at 2pm tomorrow
> ```
>
> 相对计时，格式 time + count time-units，加号表示多久之后，单位 minutes、hours、days、weeks。
>
> ```
> at 2pm + 2days
> ```

## 周期任务 crontab

服务 crond 提供周期任务的功能。命令 crontab 负责编写、删除、查看任务。参数 -e 使用 vi 打开当前用户的任务集，在此增加、修改、删除任务。参数 -l 查看当前用户的任务集，参数 -r 清空当前用户的任务集。

```
crontab <参数>
```

不同用户的任务集不同，任务集包含多个任务，每个任务独占一行，格式 "分、时、日、月、星期 命令"，有些字段没有设置，可用 * 占位。但是，"分" 必须有数值，"日" 和 "星期" 不能同时设置。"星期" 的 0 和 7 都表示周日。

```
0 23 * * * /usr/bin/rm -rf /root/*
```

> 任务的命令必须使用完全路径，任务集支持用 # 注释行。

对于时间，除单个值，还能用 "," 连接多个时间段，比如 "1,2,3" 表示周一、周二和周三；用减号 "-" 表示一段连续时间，比如 "1-3" 表示一号到三号；用除号 "/" 表示间隔时间，比如 "/2" 表示每隔两分钟执行一次任务。

# 系统的相关配置

## 主机名称 hostname

查看、设置主机名称，这种是临时设置，重启失效。

```
hostname <新主机名>
```

修改文件 */etc/hostname*，删除原始名称后追加新主机名，永久生效。

## 网卡信息 ifcfg-ens33

RHEL 7 对每个检测到的网卡创建对应的配置文件，这些文件放在 */etc/sysconfig/network-scripts* 目录。文件名称以 "ifcfg-ens" 作为前缀，追加一个数字，比如 "ifcfg-ens33"。

常见配置参数。

| 参数      | 例值                      | 说明     |
| --------- | ------------------------- | -------- |
| TYPE      | Ethernet                  | 设备类型 |
| ONBOOT    | yes\|no                   | 自动启动 |
| NAME      | ifcfg-ens33               | 网卡名称 |
| BOOTPROTO | none\|dhcp\|static\|bootp | 地址分配 |
| IPADDR    | 192.168.200.101           | IP 地址  |
| NETMASK   | 255.255.255.0             | 子网掩码 |
| GATEWAY   | 192.168.200.1             | 网关地址 |
| DNS1      | 192.168.200.1             | DNS 地址 |

修改后，重启网络服务以重载配置。

```
systemctl restart network.service
```

## 域名映射 hosts

除 DNS 服务，操作系统还能在本地配置域名映射规则，RHEL 7 的本地域名映射文件是 */etc/hosts*。该文件支持自定义修改，单个 IP 可映射多个域名，格式如下。

```
IP name1 name2 ...

#####
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
```

> Windows 的本地域名映射文件是 *C:\Windows\System32\drivers\etc\hosts*。

# 存储结构和磁盘管理

## 文件系统的结构

不同于 Windows 磁盘分区+层次目录的结构，Linux 的所有文件都从根目录 / 开始，并组织为树形。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-b6112546.png)

| 目录路径          | 惯例用途                                           |
| ----------------- | -------------------------------------------------- |
| */boot*           | 系统启动需要的文件，比如内核、开机菜单、相关配置   |
| */dev*            | 系统对设备、接口抽象的文件                         |
| */etc*            | 配置文件                                           |
| */home*           | 用户目录                                           |
| */bin*            | 单用户模式能够使用的命令                           |
| */lib*            | 系统启动以及 */bin* 和 */sbin* 的命令需要的函数    |
| */sbin*           | 系统启动需要的命令                                 |
| */media*          | 挂载设备文件的目录                                 |
| */opt*            | 放置第三方软件                                     |
| */root*           | Root 用户目录                                      |
| */srv*            | 网络服务的数据文件目录                             |
| */tmp*            | 共享的临时目录                                     |
| */proc*           | 虚拟文件系统，比如内核、进程、外部设备、网络状态   |
| */usr/local*      | 用户安装的软件                                     |
| */usr/sbin*       | 系统启动不需要的命令、软件、脚本                   |
| */usr/share*      | 帮助和说明文件，也可放置共享文件                   |
| */var*            | 经常变化的文件，比如日志                           |
| */lost* + *found* | 文件系统发生错误时，会把一些丢失的文件片段放在这里 |

## 设备文件的命令

Linux 内核的 udev 设备管理器负责管理硬件，它会为检测到的设备创建文件并进行管理，规范命名的作用是让用户看到名称就能了解该设备的大致信息。

常见设备以及它们的文件名称。

| 硬件设备        | 文件名称                 |
| --------------- | ------------------------ |
| 软驱            | */dev/fd[0-1]*           |
| 光驱            | */dev/cdrom*             |
| 鼠标            | */dev/mouse*             |
| 打印机          | */dev/lp[0-15]*          |
| 磁带机          | */dev/st0* 或 */dev/ht0* |
| IDE 设备        | */dev/hd[a-d]*           |
| SCSI、SATA、U盘 | */dev/sd[a-p]*           |

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-6a0d4dde.png)

现在 IDE 设备已很少见，基本所有的存储设备文件都是 sd 开头。机器可能插多块硬盘，使用 a-p 表示 16 块不同的硬盘。硬盘还能进行分区，主分区或扩展分区的编号是 1-4，逻辑分区的编号从 5 开始。

关于 SCSI 等存储设备的文件名称，有几点需要注意：名称中的字母，由系统内核的识别顺序决定，而非硬盘的插槽位置；不能根据分区编号判断分区数量，因为这个编号可以在创建分区时手动指定。

> **磁盘分区相关知识**
>
> 磁盘由大量的扇区组成，每个扇区的容量是 512 字节，其中第一个扇区很重要，保存着主引导记录与分区表信息，前者占用 446 字节，后者占用 64 字节，还有一个结束符占用 2 字节。记录一个分区需要 16 字节，所以分区表最多记录 4 个分区，这些就是主分区。
>
> 分区是扇区的集合，它的好处很多，但主要还是为了数据的隔离和管理，也可以不分区。
>
> 如果分区数量超过 4 个，将使用一个主分区作为拓展分区，在其中创建多个逻辑分区，逻辑分区是指向另一个分区的指针。
>
> ![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-57ff43c4.png)

## 文件系统的实现

文件系统是操作系统最基本的功能，它把存储设备中的数据映射成文件、目录，用户通过操作文件读写底层的数据。Linux 支持数十种文件系统，以下是最常见的几种实现。

* Ext3：是一款日志文件系统，能在异常宕机时避免资料丢失，并自动修复数据的不一致和错误。但当硬盘容量较大时，修复时间会很长，且不能百分之百保证资料不丢失。它把整个磁盘的每个写入动作都预先记录，以便之后修复数据，类似 Redis 的 AOF 日志。
* Ext4：Ext3 的改进版本，是 RHEL 6 的默认文件系统，支持的存储容量高达 1EB，且能有无限多的子目录。另外，Ext4 能批量分配 block 块，从而极大地提高读写效率。
* XFS：高性能的日志文件系统，是 RHEL 7 的默认文件系统，最大支持 18EB 的存储容量。它的优势在发生异常宕机后尤其明显，即能够快速恢复可能被破坏的文件，而且强大的日志功能只花费极低的计算和存储性能。

> **Linux 数据的存储方式**
>
> Linux 使用 block 和 inode 存储数据，它有一个名为 super block 的"硬盘地图"，其由大量 inode 组成。
>
> inode 负责保存文件元数据，比如访问权限、所有者和所属组等，默认 128 字节，每个文件占用一个 inode 结点。block 负责保存文件内容，大小可以是 1KB、2KB 或 4KB。inode 还记录对应文件的 block 指针，每记录一个 block 消耗 4 字节，若 inode 写满，则分出一个 block 来保存溢出的记录，这就把表示文件内容的 block 串连起来。
>
> 所谓的硬盘格式化，就是清除 super block 的内容。
>

## 添加存储设备

主机插入一块新的硬盘，该硬盘需要先分区，然后格式化，最后挂载到目录才能正常使用。硬盘的分区取决于用户需求和物理容量，也可以不分区直接使用整个硬盘，但硬盘必须进行格式化处理，目的是清除原来的元数据，避免干扰。格式化后的硬盘或分区，需要与文件系统的目录进行关联，从而能通过文件访问数据，这就是挂载。

### 硬盘分区 fdisk

前面提过，内核会检测硬件并为其在 */dev* 目录创建对应的设备文件。假设主机原来只有一块硬盘 */dev/sda*，现在插入一块新硬盘，重启系统，新增的文件 */dev/sdb* 就是这块硬盘。现在对这块新硬盘进行分区。

命令 fdisk 负责管理硬盘，具有添加、删除、转换分区等功能。

```
fdisk 硬盘文件
```

命令 fdisk 比较特别，它会进入一个交互界面，使用参数进行各种管理操作，参数说明如下。添加分区时需要指定大小，可使用 "+\[数字][单位]" 格式，比如 "+2G" 指定分区大小为 2 G。

| 参数 | 说明                 |
| ---- | -------------------- |
| n    | 添加分区             |
| d    | 删除分区             |
| m    | 查看可用参数         |
| p    | 查看分区信息         |
| t    | 改变某个分区的类型   |
| l    | 列出所有可用分区类型 |
| w    | 保存退出             |
| q    | 直接退出             |

示例，创建大小为 2G 的主分区。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-770f188b.png)

### 格式化 mkfs

新建分区或新插入的硬盘需要进行格式化，以清理原来的元数据。不同的文件系统，格式化命令也不同，但它们的名字都是 mkfs，后缀是文件系统名称。

```
mkfs[.文件系统名称] 分区文件|硬盘文件
```

示例，使用 mkfs.xfs 命令格式化 XFS 文件系统的分区文件。

```
mkfs.xfs /dev/sdb1
```

### 挂载存储设备

#### 挂载 mount

把硬盘或分区与目录进行关联，然后就能在这个目录访问磁盘的数据。

```
mount <参数> 分区文件|硬盘文件 挂载目录
```

| 参数 | 说明                                               |
| ---- | -------------------------------------------------- |
| -a   | 检查 */etc/fstab* 目录，自动挂载其中疏漏的设备文件 |
| -t   | 指定文件系统类型，较新 Linux 发行版本能够自动识别  |

示例，挂载分区文件。

```
mount /dev/sdb2 /backup
```

命令 mount 只是临时挂载，重启后失效。若想永久挂载，需按以下格式在 */etc/fstab* 文件添加内容，系统启动时将根据该文件进行自动挂载。

```
设备文件 挂载目录 格式类型 权限选项 自检 优先级
```

| 字段     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 硬盘或分区的绝对路径或唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 挂载到的目录，需提前创建                                     |
| 格式类型 | 文件系统格式，比如 Ext3、Ext4、XFS、SWAP                     |
| 权限选项 | 若为 defaults，权限是 rw, suid, dev, exec, auto, nouser, async |
| 自检     | 若为 1 开机后进行磁盘自检，为 0 则不自检                     |
| 优先级   | 多块磁盘自检的优先级                                         |

示例，永久挂载设备文件。

```
/dev/sdb2 /backup XFS defaults 0 0
```

#### 卸载 umount

撤销已挂载的银盘或分区。

```
umount 挂载目录|分区文件|硬盘文件
```

### 查看挂载信息 df

查看硬盘和分区的挂载状态以及磁盘使用量。

```
df <参数>
```

| 参数 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -a   | 显示所有文件系统的磁盘使用情况，包括 0 块（block）的文件系统 |
| -h   | 以容易理解的格式输出文件大小，比如 1KB、2MB、3GB             |

### 统计文件大小 du

统计目录或文件所占磁盘空间的大小。

```
su <参数> 文件
```

| 参数 | 说明                                             |
| ---- | ------------------------------------------------ |
| -a   | 为指定文件或目录中的每个文件显示磁盘使用情况     |
| -s   | 仅显示总计，即目录的大小                         |
| -h   | 以容易理解的格式输出文件大小，比如 1KB、2MB、3GB |

## 添加交换分区

交换分区 SWAP 是特殊的硬盘分区，也称虚拟内存。当物理内存耗尽时，系统将把一些不常用的数据临时存放到硬盘的 SWAP 分区，以腾出足够的内存空间让更活跃的服务程序使用。不管怎样，交换分区始终是磁盘存储，速度自然无法与物理内存比较。通常，交换分区的大小是物理内存的 1.5～2 倍。

交换分区同样使用 fdisk 命令创建，但格式化和挂载使用其它的命令。

格式化交换分区。

```
mkswap 交换分区
```

挂载交换分区，注意，交换分区没有挂载目录。

```
swapon 交换分区
```

为永久挂载，同样在 */etc/fstab* 文件添加内容，其中挂载目录和格式类型都是 swap 字段。

```
设备文件 swap swap 权限选项 自检 优先级
```

## 磁盘容量配额

硬件资源是有限的，如果某个用户不断创建新文件，硬盘空间总会被占满。 为此，Root 用户可使用 quota 命令对其它用户进行磁盘容量配额管理，限制它们的硬盘可用容量或能创建的最大文件个数。限制分为两种类型：

* 软限制：当达到软限制时会提示用户，但仍允许用户在限定额度内继续使用。
* 硬限制：当达到硬限制时会提示用户，且强制终止用户的操作。

虽然 RHEL 7 预装 quota 磁盘容量配额服务程序包，但存储设备默认没有开启对 quota 的支持，此时需要修改文件 */etc/fstab* 进行开启，在需要配额的设备行添加 uquota 权限。

```
UUID=d25acbf0-9bf3-4730-b986-d62b76cd438b  /boot  xfs  defaults,uquota  0  0
```

### 服务配额 xfs_quota

命令 xfs_quota 专门针对 XFS 文件系统来管理 quota 磁盘容量配额服务。参数 -c 设置要执行的命令，参数 -x 开启专家模式，让用户能进行复杂配置。

```
xfs_quota <参数> 配额文件系统
```

示例，限制用户 tony 对目录 */boot* 的使用，硬盘使用量软限制和硬限制分别是 3MB 和 6MB，创建文件数量的软限制和硬限制分别是 3 个和 6 个。

```
xfs_quota -x -c 'limit bsoft=3m bhard=6m isoft=3 ihard=6 tony' /boot
```

### 修改配额 edquota

命令 edquota 将调用 vi 打开指定对象的配额文件，Root 用户可在此进行修改。参数 -u 指定用户，参数 -g 指定用户组。

```
edquota <参数> 用户
```

> 可能没有预装 edquota 命令。
>
> ```
> yum -y install edit quota
> ```

## 软硬文件链接

Windows 的"快捷方式"是指向原文件的一个链接，让用户能在不同位置访问原文件，原文件一旦被删除，链接将失效。Linux 也有类似的链接文件，分为两种类型：

* 硬链接 Hard Link：可理解为"指向原始文件 inode 的指针"，系统不为它分配独立的 inode 和文件，所以，硬链接与原文件是同一个文件，删除原文件，硬链接依然有效。只当文件的硬链接数为 0 时，才算彻底删除它。由于技术的局限，不能跨分区对目录进行链接。
* 软链接 Symbolic Link：仅包含链接文件的路径，因此可以链接目录，也能跨域。删除原文件，软链接失效，它的性质与 Windows 的"快捷方式"相同。

命令 ln 用于创建链接文件。默认创建硬链接，参数 -s 指定创建软链接，参数 -f 强制执行，参数 -i 覆盖前先询问，参数 -v 显示创建链接的过程。

```
ln <参数> 目标文件 链接文件
```

# Shell 脚本和流程控制

## 基本框架

命令解释器 Shell 有两种工作方式：交互式、批处理。交互式对用户输入的命令立即执行。批处理是一次执行多条命令，这些命令的集合就是 Shell 脚本。所以，脚本的本质是命令集合，它使用循环、分支以及参数等特性，把功能模块化，以此简化使用和增强服务。

脚本文件的名称任意，但常以 .sh 作为后缀进行标识。脚本的第一行是声明 "#!"，这告知系统应使用哪种 Shell 解释器来执行该脚本。剩余行，则是脚本的命令或注释。

```
#!/bin/bash
# this is annotation
echo `date` >> /dev/null
```

> 文件 */dev/null* 称为黑洞，它能接收无限多数据，但不占用空间，把输出信息重定向到它相当于删除数据。

脚本的执行有两种方式。第一种方式，调用 Shell 解释器命令，比如 "bash 文件"。第二种方式，直接输入脚本文件的路径，系统将调用对应的 Shell 解释器进行执行，用户需拥有该文件的可执行权限。

## 参数和输入

**参数变量**

Shell 脚本语言能够接收输入的参数，参数之间使用空格分隔，脚本将为这些参数内设各种变量。比如，$0 表示当前脚本程序的名称，$1、$2 等表示第 N 个位置的参数，$* 表示所有参数，$# 表示参数个数，$? 表示前一条命令执行后的返回。

**读取输入**

命令运行期间，可能需要向用户获取某些信息。可用 read 命令请求并读取输入信息，参数 -p 指定提示信息，参数 -s 隐藏输入内容，最后跟上存值的变量。

```
read -p "提示信息" 变量名称
```

## 条件测试

条件测试用于对参数进行判断，条件成立则返回 0 数字，格式 "[ 条件表达式 ]"，注意，表达式两边的空格必须存在。按测试对象划分，条件测试语句可分为 4 种。

**文件测试语句**

判断测试文件是否存在，或用户权限是否满足等。

| 运算符 | 说明                           |
| ------ | ------------------------------ |
| -e     | 文件是否存在                   |
| -d     | 文件是否为目录                 |
| -f     | 是否为普通文件                 |
| -r     | 当前用户是否有该文件的可读权限 |
| -w     | 当前用户是否有该文件的可写权限 |
| -x     | 当前用户是否有该文件的执行权限 |

示例，判断指定文件是否存在。

```
[-e /etc/hosts]
```

**逻辑测试语句**

逻辑运算符用于连接多个测试语句。

| 运算符 | 说明                                   |
| ------ | -------------------------------------- |
| &&     | 与，前一个条件正确，才执行后一个条件。 |
| \|\|   | 或，前一个条件错误，才执行后一个条件。 |
| !      | 非，取测试相反的结果。                 |

示例，检查当前是否为 Root 用户。

```
[ ! $USER = root ] && echo "user" || echo "root"
```

**整数值比较语句**

比较两个数字间的大小，不能将数字和字符串、文件等进行比较。

> 不要想当然地使用 =、>、< 等符号，它们有重定向、赋值等特殊含义。

| 运算符 | 说明     |
| ------ | -------- |
| -eq    | 等于     |
| -ne    | 不等于   |
| -gt    | 大于     |
| -lt    | 小于     |
| -le    | 小于等于 |
| -ge    | 大于等于 |

示例，判断 10 是否等于 10。

```
[ 10 -eq 10 ]
```

**字符串比较语句**

判断测试字符串是否为空，或两个字符串是否相同。

| 运算符 | 说明           |
| ------ | -------------- |
| =      | 字符串是否相同 |
| !=     | 字符串是否不同 |
| -z     | 字符串是否为空 |

示例，检查系统的语言是否为美国英语。

```
[ $LANG != "en.US" ] && echo "Not en.US"
```

## 分支和循环

### 条件执行 if

```
if 条件测试 then 命令序列
	elif 条件测试 then 命令序列
	elif 条件测试 then 命令序列
	else 命令序列
fi
```

> 如需把多条命令写在同一行，可使用分号 ; 分隔命令。

### 条件循环 for

```
for 变量 in 取值列表
	do 命令序列
done
```

示例，从文件取值，按行读取。

```
for VAR in ~/filename
```

也可以用 cat 命令读取文件，然后赋值给集合变量

```
VAR = `cat ~/filename`
```

### 条件循环 while

```
while 条件测试
	do 命令序列
done
```

> 满足条件时，可执行 exit 0 命令退出脚本运行。

### 条件分支 case

```
case 变量 in
	模式1) 命令序列
	;;
	模式2) 命令序列
	;;
	*) 默认命令序列
esac
```

示例，判断变量存储字符的类型。注意，这里用分号括起变量的值，以将它转化为字符串。

```
case "$VAR" in 
	[a-z]|[A-Z]) echo "字母。"
	;;
	[0-9]) echo "数字。"
	;;
	*) echo "空格、功能键或其它控制字符。"
esac
```

# VMware 网卡模式

**NAT 模式**

虚拟机网卡与宿主机的虚拟网卡 VMnet8 共同连接到 VMware 提供的虚拟交换机，虚拟机能通过虚拟的 NAT 服务和 DHCP 服务连接互联网，但无法连接局域网。

使用虚拟的 NAT 服务和 DHCP 服务连接互联网，但无法连接局域网。

**桥连接模式**

虚拟机网卡与宿主机的物理网卡共同连接到 VMware 提供的虚拟交换机，此时，虚拟机与宿主机是平等的，相当于局域网内的两台主机，虚拟机既能连接互联网，也能连接局域网。

**仅主机模式**

虚拟机网卡使用 VMware 提供的 VMnet1 虚拟网卡与宿主机进行通信，这种方式没有路由功能，虚拟机只能与宿主机通信，不能连接局域网、互联网。
