# Linux

# 初识 Linux

## Linux 的起源

20 世纪 60 年代，贝尔实验室的科学家 Ken Thompson 开发出 UNIX 计算机操作系统，该系统被流传使用并逐渐流行。直到 1979 年，AT&T 公司将 UNIX 商业化，开始收费。从此，源代码被当作商业机密，互筑堡垒。

> 有趣的是，为在 UNIX 更方便地编写程序，Ken Thompson 和同事设计出 c 语言，因此，c 语言与 UNIX 密切相关，其在内核开发领域有着无法替代的地位。

为了推动开源精神，Richard Stallman 发起 GNU 源代码开放计划，并制定 GPL 开源协议。1987 年，GNU 取得重大突破——发布 gcc 编译器，程序员可以基于这个编译器开发自己的软件。1991 年，芬兰赫尔辛基大学在校生 Richard Stallman 开发出类 UNIX 系统 Linux，因其高性能，以及完全开源，Linux 迅速发展。

初始 Linux 仅提供硬件抽象层、硬盘和文件系统控制、多任务等核心功能，算不上完整的操作系统，我们把这些称作内核 kernel。很多厂商基于 Linux 内核，集成众多软件，开发出自己的 Linux 发行版本，并出售服务。我们经常使用的 Linux 系统，其实是各个厂商的发行版本，而不是 Linux 内核。

## 常见发行版本

根据使用的目的和场景，全球开发有数百款 Linux 发行版本，下面介绍常用的几款。

**红帽企业版 Linux，RedHat Enterprise Linux，RHEL**

红帽公司是全球最大的开源技术厂商，RHEL 是使用最广泛的 Linux 系统。RHEL 具有极高的性能与稳定性，并且在全球范围内提供完善的技术支持。

**社区企业操作系统，Community Enterprise Operating System，CentOS**

通过把 RHEL 系统重新编译并发布给用户免费使用的 Linux 系统，有广泛的使用人群，当前已被红帽 "收编"。

**Fedora**

红帽公司发布的桌面版 Linux 系统，目前已不限于桌面内容。用户可在此免费体验最新的技术和工具，这些技术或工具成熟之后会被加到 RHEL 系统，因此 Fedora 也称为 RHEL "试验田"。

**Debian**

稳定性、安全性强，提供免费的基础支持，良好地支持各种硬件架构，同时提供近十万种不同的开源软件，国际上拥有很高的认可度和使用率。

**Ubuntu**

派生自 Debian，对新款硬件具有极强兼容能力，Ubuntu 与 Fedora 同时还是非常出色的 Linux 桌面系统，而且 Ubuntu 也能用于服务器领域。

**openSUSE**

源自德国，全球范围内拥有不错的声誉和市场占有率。

**Gentoo**

具有极高的自定制性，操作复杂，适合有经验的人员使用。

# 安装和管理

## 软件的管理和安装

### 红帽软件包管理器 RPM

最初，Linux 只能通过源码安装软件，需要自行编译和解决依赖，非常不便。RPM 类似 Windows 控制面板，内置数据库用于记录软件信息和分析依赖关系。RPM 包是经过编译的程序，可以直接运行，常以 *.rpm* 作为后缀。

以下是常用 RPM 命令

| 命令                    | 说明                        |
| ----------------------- | --------------------------- |
| rpm -ivh [filename].rpm | 安装软件                    |
| rpm -Uvh [filename].rpm | 升级软件                    |
| rpm -e [filename].rpm   | 卸载软件                    |
| rpm -qpi [filename].rpm | 查看软件描述信息            |
| rpm -qpl [filename].rpm | 列出软件文件信息            |
| rpm -qf [filename].rpm  | 查询指定文件属于哪个 RPM 包 |

> RPM 虽然源于红帽系统，许多 Linux 发行版本也对其支持，它已成为 Linux 软件管理的事实标准。

### 软件仓库 yum

尽管 RPM 机制能帮助分析依赖关系，但还需要自行安装依赖软件。使用 RPM 命令安装软件，将会返回提示信息告知还需安装哪些依赖。这对依赖较多的软件的安装非常不便，升级软件还需手动更新依赖的版本。

yum 是 RPM 的包管理器，它从远程仓库下载、安装软件及其依赖，把 RPM 包的安装自动化。yum 支持自定软件仓库，默认使用红帽官方软件源。

以下是常用 yum 命令

| 命令                                        | 说明                             |
| ------------------------------------------- | -------------------------------- |
| yum repolist all                            | 列出所有软件仓库                 |
| yum list [softname\|all\|installed\|kernel] | 列出一个或一组软件包             |
| yum install [softname]                      | 安装软件包                       |
| yum update [softname]                       | 升级软件包，不指定则升级所有软件 |
| yum upgrade                                 | 升级软件包，同时删除旧版本包     |
| yum remove [softname]                       | 删除软件包                       |
| yum reinstall [softname]                    | 重新安装软件包                   |
| yum info [softname]                         | 查看软件包信息                   |
| yum clean all                               | 清除软件仓库缓存                 |
| yum check-update                            | 检查可更新软件包                 |

## 初始化和服务管理

### 启动流程

Linux 系统开机启动大概流程：从 BIOS 开始，进入 Boot Loader；加载系统内核，内核进行初始化；启动初始化进程，这是系统的第一个进程，它会完成初始化工作，提供基本工作环境。

### 运行级别

RHEL 7 使用 systemd 服务进行初始化，原来使用 System V init 初始化进程，systemd 采用并发启动机制，显著提升开机速度。systemd 使用 target 替代原来运行级别的概念，两者对应关系如下。

| systemd                             | System V init | 说明           |
| ----------------------------------- | ------------- | -------------- |
| runlevel0.target, poweroff.target   | 0             | 关机           |
| runlevel1.target, rescue.target     | 1             | 单用户模式     |
| runlevel2.target, multi-user.target | 2             | 等同级别 3     |
| runlevel3.target, multi-user.target | 3             | 多用户文本界面 |
| runlevel4.target, multi-user.target | 4             | 等同级别 3     |
| runlevel5.target, graphical.target  | 5             | 多用户图形界面 |
| runlevel6.target, reboot.target     | 6             | 重启           |
| emergency.target                    | emergency     | 紧急 Shell     |

查看默认 Target

```
systemctl get-default
```

修改默认 Target，旧版本中是通过编辑 */etc/inittab* 文件来修改默认运行级别。

```
systemctl set-default runlevel3.target
```

临时变更 Target

```
systemctl isolate runlevel3.target
```

其实，RHEL 7 依然支持 init 命令临时切换运行级别。

```
init 级别序号
```

### 服务管理

RHEL 7 使用 systemctl 命令管理服务（进程），RHEL 6 则是使用 service、chkconfig 等命令。

**服务管理命令**

| 命令                                    | 说明                       |
| --------------------------------------- | -------------------------- |
| systemctl start [servicename].service   | 启动服务                   |
| systemctl restart [servicename].service | 重启服务                   |
| systemctl stop [servicename].service    | 停止服务                   |
| systemctl reload servicename].service   | 重新加载配置，但不终止服务 |
| systemctl status [servicename].service  | 查看服务状态               |

示例，关闭防火墙服务。

```
systemctl stop firewall.service
```

**开机启动服务**

| 命令                                       | 说明                                 |
| ------------------------------------------ | ------------------------------------ |
| systemctl enable [servicename].service     | 开机自动启动                         |
| systemctl disable [servicename].service    | 禁止开机启动                         |
| systemctl is-enabled [servicename].service | 查看指定服务是否开机启动             |
| systemctl list-unit-files --type=service   | 查看各个运行级别下服务的开机启动状态 |

示例，禁止防火墙自动启动。

```
systemctl disable firewall.service
```

## 系统环境变量

### 初步认识

变量是计算机系统保存的值可变的数据类型，可以使用 echo 命令查看变量的值。环境变量名一般都是大写，这是约定俗成的规范。Linux 定义有许多环境变量，它们可以反映或影响系统的运行状态，以下是常见系统环境变量。

| 变量名       | 说明                    |
| ------------ | ----------------------- |
| HOME         | 用户家目录              |
| SHELL        | 当前使用的 Shell 解释器 |
| HISTSIZE     | 输出的历史命令记录条数  |
| HISTFILESIZE | 保存的历史命令记录条数  |
| MAIL         | 邮件保存路径            |
| LANG         | 系统语言、语系名称      |
| RANDOM       | 生成一个随机数          |
| PS1          | 解释器的提示符          |
| PATH         | 用户命令文件路径        |

### 作用范围

根据作用域的范围，可以把 Shell 变量分为局部变量和全局变量。其中，局部变量仅在当前 Shell 进程有效，无法在子 Shell 或其它 Shell 中使用，直接申明或用 declare 命令申明的变量均是局部变量。退出或者切换 Shell，当前定义的所有局部变量都会失效。注意，赋值号 = 两边不要有空白。

```
FIRST=101
```

```
declare FIRST=101
```

全局变量在当前 Shell 以及派生的子 Shell 都会生效，并能一直传递下去，但是不能逆向传递，不管子 Shell 有没有使用 export 导出变量，它都无法影响父 Shell 的全局变量。

使用 export 命令把局部变量提升为全局变量，切换用户，子 Shell 会用父 Shell 的全局变量来初始化环境，这也就解释了为什么全局变量无法逆向传递。

```
export FIRST
```

### 配置变量

**临时设置**

前面提到 export 命令，这会声明一个全局变量，但这个变量不会在其它 Shell 生效，并且只是临时有效。

```
export PATH=$PATH:/usr/local/hadoop/bin
```

**永久设置**

常见的设置环境变量的配置文件，不同版本可能稍有差异，Linux 将会从上到下按序加载。

* */etc/environment*：开机时加载，用于定义与系统运行相关但与用户无关的环境变量，修改会影响系统全局。
* */etc/profile*：用户登录时加载
* */etc/bashrc*：打开终端时加载
* *~/.profile*：针对专门用户，用户登录时加载。
* *~/.bash_profile*：针对专门用户，用户登录时加载。
* *~/.bashrc*：针对专门用户，打开终端时加载。

根据需求选择配置文件进行修改，简单追加 export 命令即可，下例是配置 JDK 环境变量。

```
export JAVA_HOME=/opt/app/jdk1.8.0_321
export PATH=$PATH:$JAVA_HOME/bin
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
```

修改完毕，使用 source 命令使系统重新加载配置文件，使之立即生效。

```
source /etc/profile
```

注意，*environment* 使用 "var=..." 格式定义环境变量，修改完后需重启或注销才能在所有终端生效，source 命令只能使修改内容在当前终端生效。

### 命令执行过程

Linux 的一切皆文件，Linux 命令也不例外，**命令的执行过程**可以分为以下四步：

* 检查输入的命令是否是绝对路径或相对路径，如果是则直接执行那个脚本；

* 检查输入的命令是否是"别名命令"，如果是则直接执行；

  > 定义别名命令 "alias 别名=命令"，取消别名命令 "unalias 别名"，查看别名命令 "alias 别名"。

* 检查输入的命令是内部命令或外部命令，内部命令是 Shell 指令，直接执行，外部命令交给下一步处理；

  > 可以使用 "type 命令名称" 查看指定命令是什么命令。

* 系统将在多个路径查找匹配的命令文件，定义这些路径的变量名为 PATH，它告诉 Bash 待执行命令可能存在哪些位置。PATH 由多个路径值组成，值之间使用冒号 : 分隔，尾部没有冒号。

使用 echo 命令查看 PATH 变量，值为 */usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin*。哎！为什么不把当前目录 . 添加到 PATH 呢？因为如果黑客在常用目录放入与 ls、cd 等同名的木马文件，就极容易中招。这也就解释为什么，即使脚本位于相同目录，我们也得使用相对路径或绝对路径来执行，Bash 根本不会扫描当前目录。

# 基本操作命令

## 命令解释器 Shell

Linux 内核主要负责硬件资源的分配和管理，它使各个硬件能够良好协同工作，可见内核的重要性。直接修改内核参数来调整运行状态很容易造成安全问题，通常使用系统调用接口进行管理。

终端 Shell 是用户与内核交流的命令行工具，它的本质是解释器，解析输入的命令，然后调用相应的系统接口完成工作。包括 RHEL 在内的主流 Linux 发行版本默认都是使用 Bash 终端，RHEL 的 Bash 程序位于 */bin/bash*。

> 除了命令行工具，Linux 还会提供操作更简单的图形化工具，这种工具本质还是调用脚本，应用较狭窄，缺乏灵活性和可控性，而且，相较于命令行，图形工具更加消耗资源。

常见 Bash 命令使用格式如下所示。对象指要处理的文件、目录、用户等资源；参数有长格式、短格式两种，分别以 -- 和 - 作为前缀，短格式的多个字母可以合在一起，，比如 ps -aux；有些参数需要设值，可能是在参数后追加空格和值，或用等号 = 赋值。

```
命令名称 参数 对象
```

如果 Shell 正在执行某个命令，可以使用 Ctrl+C 终止这个进程。

如果某个执行期间会输出太多信息，搅乱屏幕，可在命令尾部追加 & 符号，后台执行命令。

## 帮助查看 man

遇到不熟悉的内部命令，可以使用 man 命令查看它的作用、参数等信息。

```
man 命令名称
```

命令 man 返回的信息非常多，按段落划分，以下是各段的说明。

| 名称        | 说明               |
| ----------- | ------------------ |
| NAME        | 命令名称           |
| SYNOPSIS    | 参数简介           |
| DESCRIPTION | 介绍说明           |
| EXAMPLES    | 使用演示           |
| OVERVIEW    | 基本概述           |
| DEFAULTS    | 默认功能           |
| OPTIONS     | 具体选项           |
| ENVIRONMENT | 环境变量           |
| FILES       | 涉及文件           |
| SEE ALSO    | 相关资料           |
| HISTORY     | 维护历史与联系方式 |

## 基本操作命令

### 关机和重启

shutdown 命令既能关机，也能重启，参数 -h 指定多少分钟后关机，参数 -r 指定多少分钟后重启。

```
shutdown -h now/1/3	# 立刻/1分钟后/3分钟后关机
```

立即关机

```
poweroff
```

立即关机

```
halt
```

立即重启

```
reboot
```

将内存数据同步至磁盘，shutdown、halt、reboot 都会先执行这个操作。

```
sync
```

### 终端打印 echo

打印字符串或变量值，字符串需用单引号或双引号括起。

```
echo 字符串|$变量名
```

若要打印命令的运行结果，命令需用 `` 括起。

```
echo `命令`
```

### 时间日期 date

查看或设置系统的时间和日期，使用  "+" 指定打印格式，默认打印时间，可用参数 -s 设置时间。

```
date 参数 "+指定格式"
```

| 打印格式占位符 | 说明         |
| -------------- | ------------ |
| %t             | 空格         |
| %H             | 小时，00～23 |
| %I             | 小时，00～12 |
| %M             | 分钟，00～59 |
| %S             | 秒，00～59   |
| %Y             | 年           |
| %m             | 月           |
| %d             | 日           |
| %j             | 今年第几天   |

示例，指定格式打印时间。

```
date "+%Y-%m-%d %H:%M:%S"
```

示例，设置新的系统时间。

```
date -s "20170901 8:30:00"
```

```
date -s "2020-11-03 8:30:00"
```

### 下载文件 wget

用于终端下载网络文件

```
wget 参数 资源地址
```

| 参数 | 说明                               |
| ---- | ---------------------------------- |
| -b   | 后台进行                           |
| -P   | 保存目录                           |
| -t   | 最大尝试次数                       |
| -c   | 断点续传                           |
| -p   | 下载页面所有资源，包括图片、视频等 |
| -r   | 递归下载                           |

### 编译和安装 make

现实中可能会遇到一些软件需要源码安装，软件源码包解压之后，解压目录通常有一个 configure 文件，其中配置编译参数，如果没有特殊要求，按序执行以下命令就能完成编译和安装。

```
./configure
```

```
make
```

```
sudo make install
```

软件默认会安装到 `/usr/local/` 目录，以下任意方法都能修改安装路径：

* 修改 configure 文件，添加 "prefix=安装目录"

* 或者，执行 configure 时指定安装目录

  ```
  ./configure --prefix=安装目录
  ```

* 或者，执行 make install 时指定安装目录

  ```
  make install DESTDIR=安装目录
  ```

## 进程状态检测

### 进程状态 ps

查看系统的进程状态，参数 -a 显示包括属于其它用户的所有进程；参数 -f 显示全格式，包括 PPID；参数 -u 显示进程的用户以及其它详细信息；参数 -x 显示没有控制终端的进程。

```
ps -aux
```

返回信息的每一行表示一个进程，各个字段的说明如下所示。

| 列项    | 说明                                                 |
| ------- | ---------------------------------------------------- |
| USER    | 所有者                                               |
| PID     | 进程 ID                                              |
| PPID    | 父进程 ID，0 表示原始进程                            |
| %CPU    | CPU占用率                                            |
| %MEM    | 内存占用率                                           |
| VSZ     | 虚拟内存使用量，单位 KB                              |
| RSS     | 真实内存使用量，单位 KB                              |
| TTY     | 所在终端缩写                                         |
| STAT    | 进程状态，R 运行、S 中断、D 不可中断、Z 僵死、T 停止 |
| START   | 启动时间                                             |
| TIME    | 实际使用 CPU 时长                                    |
| COMMAND | 启动的命令和参数                                     |

### 监视进程 top

动态监视进程活动和系统负载等信息

```
top
```

返回信息可按空行分成两段，后半段展示进程信息，与 ps 命令的返回相似。前半段展示系统状态，有五行，各行说明如下所示。

| 位置   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 第一行 | 系统时间、运行时长、登录终端数、平均系统负载（1、5、15 分钟） |
| 第二行 | 各种状态进程的数量：总数、运行、睡眠、停止、僵死             |
| 第三行 | CPU资源占用百分比：用户、内核、优先级变更过的进程、空闲等    |
| 第四行 | 物理内存：总量、使用量、空闲量、作为内核缓存的量             |
| 第五行 | 虚拟内存：总量、使用量、空闲量、已被提前加载的量             |

> **平均系统负载 load average**
>
> 单位时间内系统处于可运行或不可中断状态的平均进程数量，值越小系统压力越低，尽量不长期超过 1，生产环境不要超过 5。0.00 表示没有进程运行或等待，CPU 空闲。0.50 表示 CPU 正以 %50 负荷运行，新的进程可以立即申请到 CPU 时间片。1.00 表示 CPU 正以 %100 负荷运行，新的进程需等待另一个进程结束或 CPU 时间片过期。1.50 表示 CPU 正满负荷工作，若有 15 个进程请求运行，其中 5 个需要等待 CPU 时间片。
>
> 对于多处理器或多核心的系统，负载的含义取决于处理器、核心的数量。若有 4 个处理器，那么系统在负载达到 4.00 之前不会满负荷工作。文件 */proc/cpuinfo* 记录着 CPU 相关信息。

### 进程编号 pidof

根据服务名查找其所有进程的 PID 值，PID 是进程 ID，唯一且不可变。

```
pidof 服务名
```

### 关闭进程 kill

根据 PID 杀死指定进程，参数 -9 表示强制执行。

```
kill -9 进程PID
```

### 关闭服务 killall

根据服务名杀死进程及其子进程，支持通配符，复杂应用往往包含多个进程共同工作，比如 Redis。

```
killall 服务名
```

### 进程树 pstree

查看按父子关系而组成的进程树状图，参数 -p 显示进程 ID，参数 -u 显示进程所属用户，参数 -A 使用 ASCII 字符连接结点，参数 -U 使用 UTF-8 字符连接结点。

```
pstree -pu
```

> 安装 pstree 命令的软件包
>
> ```
> yum -y install psmisc
> ```

## 系统状态检测

### 网络信息 ifconfig

查看网卡配置、网络状态等信息，每个网卡的信息会单独组织为一个段落，并以网卡名开头。inet 和 ether 字段表示 IP 地址和 MAC 地址，RX 和 TX 表示接收、发送数据包的数量和累计流量。

```
ifconfig
```

### 负载信息 uptime

查看系统负载信息，它的返回信息与 top 命令返回信息第一行相似，即系统时间、运行时间、登录终端数、平均系统负载（1、5、15 分钟），值越小 CPU 使用率越低，系统压力越小。

```
uptime
```

### 内存信息 free

查看内存使用情况，参数 -h 表示以更加易读的格式显示信息，返回信息包括真实内存和交换内存，各个字段分别表示总量、已用量、可用量、进程共享使用量、磁盘缓存使用量、内存缓存使用量。

```
free -h
```

### 系统内核 uname

查看系统内核信息，参数 -a 表示显示详细的内容，包括内核名称、主机名、内核版本、节点名、系统时间、硬件名称、硬件平台、处理器类型、操作系统名称等。

```
uname -a
```

> 若要了解当前发行版本的版本信息，可以查看 */etc/redhat-release* 文件。

###  用户终端 who

查看当前登录的用户终端信息，包括用户名、终端设备、登录时间。

```
who
```

### 登录记录 last

查看登录记录，last 信息是以日志文件的形式保存，可能有被篡改。

```
last
```

### 命令历史 history

查看执行过的命令，默认记录 1k 条命令，可以修改 /etc/profile 中的 HISTSIZE 变量值来自定历史记录数量。可以使用 "!编号" 命令重复执行历史命令，参数 -c 清空历史记录。

```
history -c
```

> 命令历史保存在用户目录的 *.bash_history* 文件。

## 文件目录管理

### 当前路径 pwd

查看当前工作目录的绝对路径

```
pwd
```

### 切换目录 cd

切换工作目录，目标路径可以是绝对路径或相对路径。cd - 切换到上次所处目录，cd .. 切换到父目录，cd ~ 切换到用户家目录，cd ~username 切换到指定用户的家目录。

```
cd 目标路径
```

### 文件信息 ls

查看目录的文件信息，参数 -a 显示包括隐藏文件的所有文件，参数 -l 显示文件属性，参数 -d 显示目录属性，默认查看当前目录。

```
ls 参数 目录路径
```

示例，查看文件属性，返回信息按行描述文件，包含文件类型、所有者所属组其它人的权限、硬连接引用数、所有者名字、所属组名字、文件大小 KB、最近一次修改时间、文件名。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-8bd03018.png)

### 文件信息 stat

查看文件属性，包括访问时间、修改时间等

```
stat 文件
```

### 创建文件 touch

创建空白文件或设置文件时间，参数 -a 修改读取时间，参数 -m 修改修改时间，参数 -d 同时修改两个时间。

```
touch 参数 文件名
```

示例，修改文件的读取时间。

```
touch -a "2017-05-04 15:44" anaconda-ks.cfg
```

### 创建目录 mkdir

创建目录，若要创建多层目录，需用 -p 参数递归执行。

```
mkdir -p 目录
```

### 复制文件 cp

复制文件或目录，如果目标文件是目录，则把源文件复制到这个目录中，如果目标文件是普通文件，则会询问是否允许覆盖，如果目标文件不存在，则直接复制。

参数 -p 保留源文件的属性，参数 -r 递归复制目录，参数 -i 当目标文件存在时需询问是否覆盖，参数 -d 保留链接文件的属性，参数 -a 等效 -pdr。

```
cp 参数 源文件 目标文件
```

### 移动文件 mv

移动文件，如果目标文件与源文件同目录，相当于为源文件重命名。

```
mv 源文件 目标文件
```

### 删除文件 rm

删除文件，删除目录时需用 -r 参数递归执行。Linux 删除文件默认要进行二次确认，可用 -f 参数强制执行，跳过确认步骤。

```
rm 参数 文件
```

### 文件类型 file

查看文件类型，Linux 文件无法根据后缀判断其类型。

```
file 文件
```

### 分块拷贝 dd

根据指定的大小和数量分块拷贝文件内容，参数 if 指定输入文件，参数 of 指定输出文件，bs 指定块的大小，单位可选 KB、M、G，count 指定块的数量，bs 和 count 组合确定拷贝容量，默认会拷贝输入文件的全部内容。

示例，创建指定大小的文件，设备文件 */dev/zero* 可以提供无限空字符，但不占任何存储空间。

```
dd if=/dev/zero of=newFile count=1 bs=500M
```

示例，转换文件格式，把光驱设备中的光盘制为 iso 格式的镜像文件。

```
dd if=/dev/cdrom of=RHEL-server-7.0-x86_64.iso
```

## 文本内容命令

### 查看文本 cat

直接显示文本文件全部内容

```
cat 文件
```

### 按页读取 less

全屏方式按页阅读，pagedown 向下翻页，pageup 向上翻页，"/关键字" 向后搜索关键字，"?关键字" 则向前搜索关键字，q 离开。

```
less 文本源
```

### 头部内容 head

查看文本文件前 N 行内容，参数 -n 指定多少行。

```
head -n N 文件
```

### 尾部内容 tail

查看文本文件尾 N 行内容，参数 -n 指定多少行，参数 -f 表示动态显示尾部更新。

```
tail -fn N 文件
```

### 内容替换 tr

将文件内的原始字符替换为指定字符

```
tr 原始字符 目标字符
```

示例，替换所有字母为大写。

```
cat anaconda-ks.cfg | tr [a-z] [A-Z]
```

### 文本统计 wc

统计指定文本的行数、字数、字节数，参数 -l 显示行数，参数 -w 显示单词数，参数 -c 显示字节数。

```
wc 参数 文本
```

示例，统计当前系统有多少个用户，文件 */etc/passwd* 保存系统用户信息。

```
wc -l /etc/passwd
```

### 比较不同 diff

对比两个文本内容的差异，参数 --brief 只返回两文件是否不同，参数 -c 显示具体差异。

```
diff 参数 文件 文件
```

### 管道命令符 |

把前一个命令输出的内容当作后一个命令的输入

## 打包压缩和搜索

### 压缩解压 tar

压缩或解压，Linux 支持多种压缩格式，包括 `.tar`、`.tar.gz` 和 `.tar.bz2`，它们都能使用 tar 命令处理。

| 参数 | 说明                             |
| ---- | -------------------------------- |
| -c   | 打包                             |
| -x   | 解压                             |
| -t   | 查看压缩包有哪些文件             |
| -z   | 使用 Gzip 格式                   |
| -j   | 使用 bzip2 格式                  |
| -v   | 显示处理过程                     |
| -f   | 打包或解压的文件名，必须放在最后 |
| -P   | 保留原始的权限和属性             |
| -p   | 使用绝对路径进行压缩             |
| -C   | 指定解压存放目录                 |

常见打包命令

```
tar -czvf 压缩包名.tar.gz 打包目录
```

常见解压命令

```
tar -xzvf 压缩包名.tar.gz -C 解压目录
```

### 压缩解压 zip

按 zip 格式压缩文件，参数 -r 递归压缩目录。

```
zip -r 文件或目录
```

按 zip 格式解压文件，参数 -d 指定解压目录。

```
unzip -d 解压目录 压缩包
```

### 查找文件 find

根据条件查找文件并返回结果，默认从当前目录查找。

```
find 查找路径 查找条件
```

以下参数用于设置查找条件

| 参数               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| -name              | 文件名                                                       |
| -perm              | 权限，mode 完全匹配，-mode 包含即可                          |
| -user              | 所有者                                                       |
| -group             | 所属组                                                       |
| -mtime -n +n       | 修改内容的时间，-n 表示 n 天以内，+n 表示 n 天以前           |
| -atime -n +n       | 访问文件的时间，-n 表示 n 天以内，+n 表示 n 天以前           |
| -ctime -n +n       | 修改文件权限的时间，-n 表示 n 天以内，+n 表示 n 天以前       |
| -nouser            | 没有所有者                                                   |
| -nogroup           | 没有所属组                                                   |
| -newer F1 !F2      | 比文件 F1 新但比 F2 旧                                       |
| --type b/d/c/p/l/f | 文件类型，字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件 |
| -size              | 文件大小，+50KB 表示超过 50KB，-50KB 表示小于 50KB           |
| -prune             | 忽略指定目录                                                 |
| -exec …… {}\;      | 进一步处理搜索结果，{} 表示查找结果，\ 是结束符              |

示例，从 */etc* 目录查找名称匹配的文件。

```
find /etc -name "host*"
```

示例，把所有者为 tony 的文件拷贝到 */root/findresults/* 目录。

```
find / -user tony -exec cp -a {} /root/findresults/ \;
```

## 输入输出重定向

同许多操作系统相似，Linux 有 3 种标准输入输出流，如下所示。

| IO 流      | 变量名 | 文件描述符 | 数据源/汇 |
| ---------- | ------ | ---------- | --------- |
| 标准输入流 | STDIN  | 0          | 键盘      |
| 标准输出流 | STDOUT | 1          | 屏幕      |
| 标准错误流 | STDERR | 2          | 屏幕      |

> 执行 Bash 命令，返回的错误信息，其实都是发送到标准错误流。

重定向就是重新定义数据流的源或汇，Bash 使用以下操作符重定向，尽管源和汇是泛指，但通常都是文件。

| 符号           | 说明                               | 示例                             |
| -------------- | ---------------------------------- | -------------------------------- |
| 命令 < 文件    | 重定向标准输入                     | wc -l < words.txt                |
| 命令 << 终止符 | 持续从键盘读入数据，直到遇见终止符 | mail -s "Subject" pochai << over |

| 符号            | 说明                                     | 示例           |
| --------------- | ---------------------------------------- | -------------- |
| 命令 [1]> 文件  | 重定向标准输出，清空原文件               | ls > tmp.txt   |
| 命令 [1]>> 文件 | 重定向标准输出，追加原文件               | ls >> tmp.txt  |
| 命令 2> 文件    | 重定向标准错误，清空原文件               | ls 2> tmp.txt  |
| 命令 2>> 文件   | 重定向标准错误，追加原文件               | ls 2>> tmp.txt |
| 命令 &>> 文件   | 同时重定向标准输出和标准错误，追加原文件 | ls &>> tmp.txt |

# 文本处理命令

## 按行过滤 grep

筛选符合匹配条件的行，参数 -i 忽略大小写，参数 -v 返回不匹配的行，参数 -n 只显示行号，参数 -c 只返回匹配行数，参数 -b 指定文件为文本源。

```
grep 参数 匹配规则 文本源
```

## 按列过滤 cut

按列筛选文本，参数 -f 指定显示第几列，参数 -d 指定列的分隔符。

```
cut 参数 文本源
```

示例，查看第一列，以 : 作为分隔符。

```
cut -d: -f1 /etc/passwd
```

## 格式处理 awk

逐行处理内容，默认以空白分割文本，然后把分割字段赋给内置变量，最后按模式或条件执行编辑命令，执行过程可以通过 print 打印内容，另外还能使用逻辑运算符、数据运算符等功能。

```
awk 参数 '模式或条件 {操作命令}' 文本源
```

常用内置变量：RS 行的分隔符，默认 \n；FS 字段分隔符，默认空格或制表符；NF 当前行分割后的字段个数；NR 当前行的行号；$0 整行内容；$N 第 N 个分割字段；FILENAME 被处理的文件名。

"模式和条件"可以做很多操作，但最主要是定义条件，仅当条件满足或没有条件时才对当前行执行操作命令。

示例，逐行打印内容，默认 print 打印整行，所以 $0 可省。

```
awk '{print $0}' text
```

示例，打印 1 到 3 行。

```
awk 'NR==1,NR==3 {print}' text
```

```
awk '(NR>=1)&&(NR<=3) {print}' text
```

示例，打印第 1 和第 3 行。

```
awk 'NR==1;NR==3 {print}' text
```

```
awk 'NR==1||NR==3{print}' text
```

示例，打印奇数行。

```
awk '(NR%2)==1{print}' text
```

示例，打印所有非空行，第一句使用 IF 判断，第二句使用正则表达式条件。

```
awk '{if($0 != "") {print $0}}' text
```

```
awk '!/^$/ {print $NF}' text
```

示例，打印长度 8 以下单词。

```
awk -F" " '{for(i=1;i<=NF;i++){if(length($i) < 8){print $i}}}' text
```

示例，打印以 root 开头的行。

```
awk '/^root/{print}' /etc/passwd
```

示例，打印以 nologin 结尾的行。

```
awk '/nologin$/{print}' /etc/passwd
```

示例，打印每行第 1 个字段，参数 -F 指定字段分隔符。

```
awk -F ":" '{print $1}' /etc/passwd
```

示例，第 3 个字段小于 5 时打印第 1 和第 3 个字段。

```
awk -F ":" '$3<5{print $1,$3}' /etc/passwd
```

示例，使用内置变量 FS 指定字段分隔符，关键字 BEGIN 指定预先执行内容，END 指定稍后执行内容。

```
awk 'BEGIN {FS=":"};{{print}}' /etc/passwd
```

## 内容修改 sed



# 文本编辑器 vim

Linux 虽内置有 vi 文本编辑器，但 vim 更常用更好用，它是 vi 拓展，有三种模式，分别支持不同的操作和命令。

* 命令模式：控制光标移动，可以进行复制、粘贴、删除、查找等操作。
* 编辑模式：正常的文本编辑
* 末行模式：保存或退出文档，以及修改编辑环境。

使用 vim 打开文件，初始为命令模式，模式的切换方法如下所示。其中，i 键在当前位置进入编辑，a 键在后一位进入编辑，而 o 键在下面新建一行进入编辑。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-d98ca785.png)

命令模式常用命令

| 命令        | 说明                             |
| ----------- | -------------------------------- |
| dd          | 剪切光标所在行                   |
| ndd         | 剪切从光标开始的 n 行            |
| yy          | 复制光标所在行                   |
| nyy         | 复制从光标开始的 n 行            |
| /字符串     | 从光标向后搜索关键字             |
| ?字符串     | 从光标向前搜索关键字             |
| n           | 定位到搜索匹配的下一个关键字     |
| N           | 定位到搜索匹配的上一个关键字     |
| u           | 撤销上一步操作                   |
| p           | 把剪切或复制的内容粘贴到光标后面 |
| gg          | 移动光标到第一行                 |
| G           | 移动光标到最后一行               |
| n + Shift+g | 移动光标到第 n 行                |

末行模式常用命令

| 命令          | 说明                            |
| ------------- | ------------------------------- |
| w             | 保存                            |
| q             | 退出                            |
| !             | 强制执行                        |
| wq!           | 强制保存退出                    |
| set nu        | 显示行号                        |
| set nonu      | 隐藏行号                        |
| :命令         | 执行该命令                      |
| :n            | 跳转到第 n 行                   |
| :s/one/two    | 把光标行的第一个 one 替换成 two |
| :s/one/two/g  | 把光标行的所有 one 替换成 two   |
| :%s/one/two/g | 把全文的所有 one 替换成 two     |

# 用户和文件权限

## 用户身份和功能

### 相关概念

作为多用户操作系统，Linux 支持多用户同时工作，且有较高安全性。安装 Linux 时需设置 Root 用户密码，这是系统的超级用户，拥有最高权限，能够管理系统各项功能。

每个用户都有一个标识符——用户编码 UID（User IDentification），Linux 把 UID 为 0 的用户看作管理员。为了防止出现漏洞的服务被黑客提权至整个机器，系统会预设 UID 为 1~999 的系统用户，默认服务程序都由系统用户负责运行，以此控制它们的破坏范围。自定义用户，UID 从 1000 开始。

为了统一管理多个用户，Linux 引入用户组。每创建一个用户，默认会创建一个同名基本用户组，接着通过用户组编码 GID（roup IDentification）把新用户加入这个组。所以，基本用户组只有一个同名用户，当然，用户还可以加入其它拓展用户组。

### 查看用户 id

查看用户基本属性，包括 UID、GID、所属用户组。

```
id 用户名
```

### 创建用户 useradd

```
useradd 参数 用户名
```

| 参数 | 说明                                        |
| ---- | ------------------------------------------- |
| -d   | 用户家目录，默认 */home/username*           |
| -e   | 用户过期时间，格式 YYYY-MM-DD，默认永不过期 |
| -u   | UID                                         |
| -g   | 用户基本组，这个组必须已存在                |
| -N   | 不创建基本用户组                            |
| -G   | 加入一个或多个扩展用户组                    |
| -s   | Shell 解释器，默认 */bin/bash*              |

### 删除用户 userdel

```
userdel 参数 用户名
```

| 参数 | 说明                         |
| ---- | ---------------------------- |
| -f   | 强制删除                     |
| -r   | 同时删除用户家目录，默认保留 |

### 修改用户 usermod

修改用户属性，Linux 的一切皆文件，用户信息存放在 */etc/passwd* 文件，可以直接修改文件内容，但仍建议使用命令进行修改。

```
usermod 参数 用户名
```

| 参数  | 说明                                           |
| ----- | ---------------------------------------------- |
| -c    | 备注信息                                       |
| -d -m | 两个参数合用，重新设置用户家目录，并转移旧数据 |
| -e    | 用户过期时间，格式 YYYY-MM-DD                  |
| -g    | 基本用户组                                     |
| -G    | 扩展用户组                                     |
| -L    | 锁定用户，禁止登录                             |
| -U    | 解锁用户，允许登录                             |
| -s    | 默认 Shell 解释器                              |
| -u    | UID                                            |

### 用户密码 passwd

修改用户认证信息、过期时间等，默认修改当前用户，只有 Root 可以修改其它用户，且不需验证旧密码。

```
passwd 参数 用户名
```

| 参数    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| -l      | 锁定用户，禁止登录                                           |
| -u      | 解除锁定，允许登录                                           |
| -S      | 查看用户是否被锁定，以及密码采用的加密算法                   |
| --stdin | 通过标准输入修改用户密码，比如 echo "NewPassWord" \| passwd username |
| -d      | 允许用户空密码登录                                           |
| -e      | 强制用户下次登录时修改密码                                   |

### 切换用户 su

减号 - 表示完全切换到新用户，即把环境变量信息也进行更新，默认会用旧环境的信息初始化新环境。

```
su [-] 用户名
```

### 创建用户组 groupadd

```
groupadd 组名
```

## 文件权限和归属

### 相关概念

Linux 文件都有所属的用户和用户组，可以分别对所有者、所属组、其它人设置可读、可写、执行权限。对于普通文件，可读、可写、执行没有理解难度，但对于目录，可读表示允许读取目录的文件列表，可写表示允许在目录内增加、删除、重命名文件，可执行表示允许进入目录。

可用字符 w、r、x 表示可读、可写、执行，若要使用数字来表示权限，首先把字母序列转化为二进制序列，然后再转化为十进制数值。

Linux 文件都有类型，并且使用字符进行标识，如下所示。

| 文件类型字符 | 说明         |
| ------------ | ------------ |
| -            | 普通文件     |
| d            | 目录文件     |
| l            | 链接文件     |
| p            | 管道文件     |
| b            | 块设备文件   |
| c            | 字符设备文件 |

### 修改权限 chmod

参数 -R 会对目录进行递归操作，可以使用字母或数字设置所有权限，比如 rwxrw----、760，还可以用 +、- 增减某个角色的权限，比如 g+w 会为所属组增加可写权限，其中 u 表示所有者，g 所属组，o 其它人，a 全部。

```
chmod 权限参数 文件
```

示例，修改文件权限。

```
chmod 777 filename
```

### 修改所属 chown

修改文件的所有者或所属组，参数 -R 表示对目录进行递归操作，可以只修改所有者或所属组。

```
chown [用户][:用户组] 文件
```

示例，修改所有者。

```
chown username linuxprobe
```

示例，修改所属组。

```
chown :groupname linuxprobe
```

## 身份执行命令 sudo

通过 sudo 命令，用户能以其它用户的身份去执行某些操作，从而免去切换用户的步骤。

```
sudo 参数 执行命令
```

| 参数            | 说明                               |
| --------------- | ---------------------------------- |
| -h              | 帮助信息                           |
| -l              | 查看当前用户可以执行的命令         |
| -u 用户名或 UID | 以指定身份执行命令，默认 Root 用户 |
| -k              | 清空密码的有效时间，下次需重新验证 |
| -b              | 后台执行                           |
| -p              | 更改密码验证的提示语               |

初始，只有 Root 用户有 sudo 权限，它能以任何身份执行任何命令，至于其它用户，则需修改 */etc/sudoers* 指定允许以什么身份执行哪些命令。除了 vim 编辑器，可用 visudo 命令修改配置，它会使用 vi 打开配置文件，禁止多个用户同时修改文件，并能进行语法检查。

> 只有 Root 用户可以修改 */etc/sudoers* 文件，以及执行 visudo 命令。

示例，允许用户 tony 在任何主机，以任何身份，执行任何命令。

```
tony ALL=(ALL) ALL
```

示例，允许用户 tony 在任何主机，以任何身份，执行 */usr/bin/cat* 命令。

```
tony ALL=(ALL) /usr/bin/cat
```

参数 NOPASSWD 表示用户使用 sudo 命令时不再需要密码验证

```
tony ALL=NOPASSWD: ALL
```

# 防火墙管理工具

## 相关概念

防火墙是公网与内网之间的保护屏障，旨在保障数据的安全，它根据定制的策略对穿越的流量进行筛选。

RHEL 7 新增 firewalld 服务，以取代之前 iptables 服务，它们都是定义防火墙策略的工具。iptables 把定义的策略交给内核层 netfilter 网络过滤器处理，而 firewalld 是交给内核层 nftables 包过滤框架处理。防火墙只是一种概念，内核层根据策略执行相关的过滤操作，以形成所谓的"墙"。如果需要，也可以使用其它的防火墙工具，反正最终目的，是快捷地定制合适的策略。

## 防火墙 firewalld

RHEL 7 默认集成多款防火墙管理工具，其中 firewalld（Dynamic Firewall Manager of Linux systems）是默认服务，它有命令行 CLI 和图形界面 GUI 两种使用方式。

### 区域 zone

firewalld 支持动态更新，它有一个区域 zone 概念，区域是防火墙策略的集合，用户可以随意切换区域，以适应不同安全场景，以下是常见区域。

| 区域     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| trusted  | 允许任何流量                                                 |
| home     | 拒绝流入流量，除非与流出流量相关；而如果流量与 ssh、mdns、ipp-client、amba-client 和  dhcpv6-client 服务相关，则允许流量 |
| internal | 等效 home 区域                                               |
| work     | 拒绝流入流量，除非与流出流量相关；允许 ssh、ipp-client、dhcpv6-client 服务相关流量 |
| public   | 默认，拒绝流入流量，除非与流出流量相关；允许 ssh、dhcpv6-client 服务相关流量 |
| external | 拒绝流入流量，除非与流出流量相关；允许 ssh 服务相关流量      |
| dmz      | 拒绝流入流量，除非与流出流量相关；允许 ssh 服务相关流量      |
| block    | 拒绝流入流量，除非与流出流量相关                             |
| drop     | 拒绝流入流量，除非与流出流量相关                             |

### 命令 firewall-cmd

命令 firewalld-cmd 是 firewalld 防火墙配置管理工具 CLI（命令行界面）版本，它的参数基本都是长格式，但是支持自动补齐。

> 开启 firewall 服务，RHEL 7 默认启动
>
> ```
> systemctl start firewalld.service
> ```
>
> 关闭 firewall 服务
>
> ```
> systemctl stop firewalld.service
> ```
>
> 禁止 firewall 服务开机启动
>
> ```
> systemctl disable firewalld.service
> ```

命令 firewall-cmd 配置的策略默认临时有效，系统重启后失效，如果想让配置永久生效，需要添加 --permanent 参数。永久模式的策略重启之后才能生效，可以添加 --reload 参数重新加载配置，使其立即生效。

| 参数                        | 说明                                                 |
| --------------------------- | ---------------------------------------------------- |
| --state                     | 查看服务状态                                         |
| --get-default-zone          | 查看默认区域                                         |
| --set-default-zone=区域名称 | 设置默认区域，永久生效                               |
| --get-zones                 | 查看可用区域                                         |
| --get-services              | 查看预先定义的服务                                   |
| --get-active-zones          | 查看正在使用的区域和网卡名称                         |
| --add-source=IP             | 将源自此 IP 或子网的流量导向指定区域                 |
| --remove-source=IP          | 不再将源自此 IP 或子网的流量导向指定区域             |
| --add-interface=网卡名称    | 将源自此网卡的流量导向指定区域                       |
| --change-interface=网卡名称 | 将某个网卡与区域进行关联                             |
| --list-all                  | 查看当前区域的网卡配置参数、资源、端口以及服务等信息 |
| --list-all-zones            | 查看所有区域的网卡配置参数、资源、端口以及服务等信息 |
| --list-ports                | 查看开放的所有端口                                   |
| --add-service=服务名        | 设置默认区域允许指定服务的流量                       |
| --remove-service=服务名     | 设置默认区域禁止指定服务的流量                       |
| --add-port=端口号/协议      | 设置默认区域允许指定端口的流量                       |
| --remove-port=端口号/协议   | 设置默认区域禁止指定端口的流量                       |
| --reload                    | 重新加载永久配置                                     |
| --panic-on                  | 开启应急状况模式，阻断所有网络连接                   |
| --panic-off                 | 关闭应急状况模式                                     |

示例，设置默认区域。

```
firewall-cmd --set-default-zone=public
```

示例，查看 public 区域开放的所有端口。

```
firewall-cmd --zone=public --list-ports
```

示例，把 external 设为 eno101 网卡的默认区域。

```
firewall-cmd --permanent --zone=external --change-interface=eno101
```

示例，允许访问 8080 和 8081 端口的流量。

```
firewall-cmd --permanent --zone=public --add-port=8080-8081/tcp
```

示例，查看 public 区域是否允许 SSH 协议的流量。

```
firewall-cmd --zone=public --query-service=ssh
```

示例，把流向 80 端口并基于 TCP 协议的流量转发到 192.168.0.101:90 端口。

```
firewall-cmd --zone=public 
		--add-forward-port=port=80:proto=tcp:toport=90:toaddr=192.168.0.101
```

# 远程控制服务

## 相关概念

SSH 是应用层的文件传输协议，它会加密和压缩网络数据，是目前远程管理 Linux 主流方式。在此之前，还曾使用过 FTP 和 Telnet 协议，但它们都是明文传输，非常不安全。

OpenSSH 是 SSH 开源实现，进程名为 sshd，它有两种安全验证方式：口令、密钥。Linux 和 Mac 默认会安装该程序的服务端和客户端，Windows 常见 SSH 实现有 XShell、PuTTY。

> 安装 OpenSSH 服务端、客户端软件包
>
> ```
> yum -y install openssh-server|openssh-client
> ```

## 配置信息

相关配置文件

| 配置文件               | 作用                             |
| :--------------------- | :------------------------------- |
| ~/.ssh/known_hosts     | 客户端，记录服务端的授权信息     |
| ~/.ssh/authorized_keys | 服务端，保存客户端的公钥文件     |
| ~/.ssh/config          | 客户端，记录连接服务器配置的别名 |

服务 sshd 的配置信息保存在 */etc/ssh/sshd_config* 文件，以下是一些重要参数。

| 参数                   | 默认                      | 说明                                    |
| ---------------------- | ------------------------- | --------------------------------------- |
| Port                   | 22                        | SSHD 服务端口                           |
| ListenAddress          | 0.0.0.0                   | 监听 IP 地址                            |
| Protocol               | 2                         | SSH 协议版本号                          |
| HostKey                | /etc/ssh/ssh_host_key     | SSH 协议版本为 1 时，DES 私钥的存放位置 |
| HostKey                | /etc/ssh/ssh_host_rsa_key | SSH 协议版本为 2 时，RSA 私钥的存放位置 |
| HostKey                | /etc/ssh/ssh_host_dsa_key | SSH 协议版本为 2 时，DSA 私钥的存放位置 |
| PermitRootLogin        | yes                       | 是否允许 Root 身份远程登录              |
| StrictModes            | yes                       | 如果远程用户改变私钥，是否直接拒绝连接  |
| MaxAuthTries           | 6                         | 最大尝试登录次数                        |
| MaxSessions            | 10                        | 最大终端数                              |
| PasswordAuthentication | yes                       | 是否允许密码验证                        |
| PermitEmptyPasswords   | no                        | 是否允许空密码登录                      |

## 口令验证

使用密码进行口令验证登录，参数 -p 指定连接端口，默认 22；username 可选，默认 Root 用户。

```
ssh 参数 [username@]IP
```

示例

```
ssh -p 22 username@192.168.200.101
```

## 密钥验证 ssh

加密就是使用指定算法对信息进行编码和解码的技术，密钥是密文的钥匙，有私钥和公钥之分。传输前，服务端使用公钥加密数据，得到密文。客户端收到密文，再使用私钥对密文进行处理，得到明文。这样，即使数据包被黑客拦截，信息也不会泄露。密钥验证使得 sshd 远程连接更加安全，以下步骤配置 sshd 密钥验证。

客户端生成密钥对，参数 -t 指定加密算法，默认 RSA；参数 -C 设置注释，追加到密钥文件尾部；参数 -f 指定密钥文件，对于 RSA 算法，默认私钥 *~/.ssh/id_rsa*，公钥 *~/.ssh/id_rsa.pub*。

```
ssh-keygen 参数

#####
ssh-keygen -t rsa -b 2048  -C "rsa key"  -f "github" 
```

客户端把公钥文件传给远程主机某个用户，参数 -i 指定公钥文件，username 可选，默认 Root 用户，这时需输入远程主机对应的密码。

```
ssh-copy-id 参数 [username@]IP
```

现在，客户端当前用户就能以预设身份登录远程主机。

```
ssh IP
```

## 别名配置

通过 ssh 连接远程主机，需要显式指定连接端口、远程 IP、username、userpassword 等信息，比较繁琐，可以把这些连接信息打包到 *~/.ssh/config* 配置文件，如下所示。这个文件可能不存在，手动创建即可。

```
Host 别名
    Hostname 远程地址
    User 用户名
    Port 端口号
    IdentityFile 密钥文件
```

直接使用别名进行远程登录

```
ssh 别名
```

## 远程传输 scp

服务 sshd 含有命令 scp，用于基于 SSH 协议传输文件。参数 -v 显示传输进度，参数 -P 指定远程端口，参数 -r 递归传输目录，参数 -6 使用 IPv6 协议，参数 -i 指定公钥文件，username 可选，默认 Root 用户。

> 执行 scp 时需要进行安全验证，若已经设有密钥，这步跳过。

把本地文件传输到远程目录

```
scp 参数 本地文件 [username@]IP:远程目录
```

把远程文件复制到本地目录

```
scp 参数 [username@]IP:远程文件 本地目录
```

# 计划任务服务

## 定时任务 at

服务 atd 提供定时任务功能，它把任务按执行时间组成队列，后台进程 atd 持续检查队头任务，如果到期，则将其弹出队列并执行。

命令 at 用于添加、删除、查看任务，进入任务编辑窗口，Ctrl+d 退出，设置完成。

```
at 参数 时间
```

| 参数    | 说明                                 |
| ------- | ------------------------------------ |
| -f 文件 | 从指定文件而非标准输入读取任务命令   |
| -m      | 任务完成之后，邮件通知用户           |
| -v      | 显示执行时间                         |
| -V      | 显示任务版本                         |
| -l      | 查看所有未执行任务，等同 "atq"       |
| -d 序号 | 删除指定未执行任务，等同 "atrm 序号" |

> **灵活的时间设置**
>
> 当天执行，格式 hh:mm，若时间已过，则第二天执行。
>
> ```
> at 23:30
> ```
>
> 具体日期，格式 yy-mm-dd 或 mm/dd/yy，日期放在时间后面。
>
> ```
> at 12:00 2022-12-30
> ```
>
> 支持 12 小时制，用 am、pm 表示上午、下午。
>
> ```
> at 11:30pm
> ```
>
> 使用 midnight、noon 等词模糊指定时间
>
> ```
> at midnight
> ```
>
> 使用 today、tomorrow 等词指定日期
>
> ```
> at 2pm tomorrow
> ```
>
> 相对时间，格式 time + count time-units，加号表示多久之后，单位 minutes、hours、days、weeks。
>
> ```
> at 2pm + 2days
> ```

## 周期任务 crontab

服务 crond 提供周期任务功能，命令 crontab 用于编写、删除、查看任务，参数 -e 使用 vi 打开当前用户的任务集合，可在此增加、修改、删除任务；参数 -l 查看当前用户的任务集；参数 -r 清空当前用户的任务集；

```
crontab 参数
```

用户都有自己的任务集，任务集由多个任务组成，每个任务独占一行，格式 "分、时、日、月、星期 命令"。有些字段可以不设置，用 * 占位。但是，分必须有数值，日和星期不能同时设置，星期 0 和 7 都表示周日。

```
0 23 * * * /usr/bin/rm -rf /root/*
```

> 任务的命令必须使用完全路径，任务集可用 # 进行注释。

对于时间，除单个值，还能用 "," 连接多个时间段，比如 "1,2,3" 表示周一、周二和周三；用减号 "-" 表示一段连续时间，比如 "1-3" 表示一号到三号；用除号 "/" 表示间隔时间，比如 "/2" 表示每隔两分钟执行一次。

# 系统的相关配置

## 主机名称 hostname

查看、设置主机名称，这种只是临时设置，重启失效。

```
hostname 新主机名
```

永久设置需要修改文件 */etc/hostname*，删除原始名称然后添加新主机名。

## 网卡信息 ifcfg-ens33

RHEL 7 会为每个检测到的网卡创建对应的配置文件，这些文件都放在 */etc/sysconfig/network-scripts* 目录，文件名以 "ifcfg-ens" 作为前缀，然后追加一个数字，比如 "ifcfg-ens33"。

常见配置参数

| 参数      | 例值                      | 说明         |
| --------- | ------------------------- | ------------ |
| TYPE      | Ethernet                  | 设备类型     |
| ONBOOT    | yes\|no                   | 自动启动     |
| NAME      | ifcfg-ens33               | 网卡名称     |
| BOOTPROTO | none\|dhcp\|static\|bootp | 地址分配策略 |
| IPADDR    | 192.168.200.101           | 网卡地址     |
| NETMASK   | 255.255.255.0             | 子网掩码     |
| GATEWAY   | 192.168.200.1             | 网关地址     |
| DNS1      | 192.168.200.1             | DNS 地址     |

修改之后，需要重启网络服务以重载配置。

```
systemctl restart network.service
```

## 域名映射 hosts

除了 DNS 服务，操作系统还能在本地配置域名映射规则，RHEL 7 本地域名映射文件是 */etc/hosts*，这个文件允许自定义修改，单个 IP 可以映射多个域名，格式如下。

```
IP name1 name2 ...

#####
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
```

> Windows 本地域名映射文件是 *C:\Windows\System32\drivers\etc\hosts*

# 存储结构和磁盘管理

## 文件系统的结构

与 Windows 磁盘分区+层次目录的结构不同，Linux 所有文件都从根目录 / 开始，组织为树形。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-b6112546.png)

| 目录路径          | 惯例用途                                           |
| ----------------- | -------------------------------------------------- |
| */boot*           | 系统启动需要的文件，比如内核、开机菜单、相关配置   |
| */dev*            | 系统对设备、接口的抽象文件                         |
| */etc*            | 配置文件                                           |
| */home*           | 用户目录                                           |
| */bin*            | 单用户模式能够使用的命令                           |
| */lib*            | 系统启动以及 */bin* 和 */sbin* 中的命令需要的函数  |
| */sbin*           | 系统启动需要的命令                                 |
| */media*          | 挂载设备文件的目录                                 |
| */opt*            | 存放第三方软件                                     |
| */root*           | Root 用户目录                                      |
| */srv*            | 网络服务的数据文件目录                             |
| */tmp*            | 共享的临时目录                                     |
| */proc*           | 虚拟文件系统，比如内核、进程、外部设备、网络状态   |
| */usr/local*      | 用户安装的软件                                     |
| */usr/sbin*       | 系统启动不需要的命令、软件、脚本                   |
| */usr/share*      | 帮助和说明文件，也可放置共享文件                   |
| */var*            | 经常变化的文件，比如日志                           |
| */lost* + *found* | 文件系统发生错误时，会把一些丢失的文件片段放在这里 |

## 设备文件的命令

Linux 内核 udev 设备管理器负责管理硬件，它会为检测到的设备创建文件并进行管理，规范命名的作用是让用户看到名字就能知道这个设备的大致信息。

常见设备以及它们的文件名

| 硬件设备        | 文件名称                 |
| --------------- | ------------------------ |
| 软驱            | */dev/fd[0-1]*           |
| 光驱            | */dev/cdrom*             |
| 鼠标            | */dev/mouse*             |
| 打印机          | */dev/lp[0-15]*          |
| 磁带机          | */dev/st0* 或 */dev/ht0* |
| IDE 设备        | */dev/hd[a-d]*           |
| SCSI、SATA、U盘 | */dev/sd[a-p]*           |

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-6a0d4dde.png)

现在 IDE 设备已很少见，基本所有的存储设备文件都是 sd 开头。机器可能插多块硬盘，使用 a-p 表示 16 块不同硬盘。硬盘还能进行分区，主分区或扩展分区的编号是 1-4，逻辑分区的编号从 5 开始。

关于 SCSI 等存储设备的文件名字，有几点需要注意：名字中的字母，由系统内核的识别顺序决定，而非硬盘插槽位置；不能根据分区编号判断分区数量，因为这个编号可以在创建分区时手动指定。

> **磁盘分区相关知识**
>
> 磁盘由大量的扇区组成，每个扇区的容量是 512 字节，其中第一个扇区很重要，保存着主引导记录与分区表信息，前者占用 446 字节，后者占用 64 字节，还有一个结束符占 2 字节。记录一个分区需要 16 字节，所以分区表最多记录 4 个分区，这些就是主分区。如果分区数量超过 4 个，就用一个主分区作为拓展分区，其中创建多个逻辑分区，逻辑分区是指向另一个分区的指针。
>
> 分区是扇区的集合，它的好处很多，但主要还是为了数据的隔离与管理，当然也可以不分区。
>
> 
>
> ![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-57ff43c4.png)

## 文件系统的实现

文件系统是操作系统最基本的功能，它把存储设备中的数据映射成文件和目录，用户可以通过操作文件来读写底层数据。Linux 支持数十种文件系统，以下是最常见的几种实现。

* Ext3：是一款日志文件系统，可在异常宕机时避免资料丢失，并自动修复数据的不一致和错误。但当硬盘容量较大时，修复时间会很长，且不能百分之百保证资料不丢失。它把整个磁盘的每个写入动作都预先记录，以便之后修复数据，类似 MySQL 的 Redo 日志。
* Ext4：Ext3 改进版本，RHEL 6 默认文件系统，支持的存储容量高达 1EB，且能有无限多子目录。另外，它能批量分配 block 块，从而极大地提高读写效率。
* XFS：高性能的日志文件系统，是 RHEL 7 默认文件系统，最大支持 18EB 的存储容量。它的优势在发生异常宕机后尤其明显，能够快速恢复可能被破坏的文件，而且强大的日志功能只消耗极低的计算和存储资源。

> **Linux 数据的存储方式**
>
> Linux 使用 block 和 inode 存储数据，它有一个名为 super block 的"硬盘地图"，其由大量 inode 组成。
>
> inode 用于保存文件元数据，比如访问权限、所有者和所属组等，默认 128 字节，每个文件对应一个 inode 结点。block 用于保存文件内容，大小可以是 1KB、2KB 或 4KB。inode 记录有对应文件的 block 指针，每记录一个 block 消耗 4 字节，若 inode 写满，则分出一个 block 来保存溢出的记录，这就把所有 block 结点串联起来。
>
> 所谓硬盘格式化，其实只是清除 super block 内容。

## 添加存储设备

插入一块新的硬盘，这个硬盘需要先分区，然后格式化，最后挂载目录才能正常使用。硬盘的分区取决于用户需求和物理容量，当然也可以不分区直接使用整个硬盘，但硬盘必须进行格式化处理，目的是清除原来的元数据，避免干扰。格式化后的硬盘或分区，还需与文件系统的目录关联，从而可以通过文件访问数据，这就是挂载。

### 硬盘分区 fdisk

已经知道，内核会为检测到的硬件在 */dev* 目录创建对应的设备文件。假设主机原来只有一块硬盘 */dev/sda*，现在插入一块新硬盘，重启系统，新增文件 */dev/sdb* 表示新的硬盘，现在先对这块硬盘进行分区。

命令 fdisk 用于管理硬盘，具有添加、删除、转换分区等功能。

```
fdisk 硬盘文件
```

执行 fdisk 命令，用户将会进入一个交互界面，输入参数进行各种管理，各种参数说明如下。添加新分区需要指定大小，可用 "+\[数字][单位]" 格式，比如 "+2G" 表示分区大小 2G。

| 参数 | 说明               |
| ---- | ------------------ |
| n    | 添加分区           |
| d    | 删除分区           |
| m    | 查看可用参数       |
| p    | 查看分区信息       |
| t    | 修改某个分区的类型 |
| l    | 列出可用的分区类型 |
| w    | 保存退出           |
| q    | 直接退出           |

示例，创建大小为 2G 的主分区。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/linux-770f188b.png)

### 格式化 mkfs

新建分区或新插入的硬盘需要进行格式化，清理原来的元数据。不同的文件系统，格式化命令不同，但它们的名字都是 mkfs，后缀则是文件系统名称。

```
mkfs[.文件系统名称] 分区文件|硬盘文件
```

示例，使用 mkfs.xfs 命令格式化 XFS 文件系统的分区文件。

```
mkfs.xfs /dev/sdb1
```

### 挂载存储设备

#### 挂载 mount

把硬盘或分区与目录进行关联，然后就能通过整个目录访问这个硬盘的数据。

```
mount 参数 分区文件|硬盘文件 挂载目录
```

| 参数 | 说明                                               |
| ---- | -------------------------------------------------- |
| -a   | 检查 */etc/fstab* 目录，自动挂载其中遗漏的设备文件 |
| -t   | 指出文件系统类型，新 Linux 发行版本将会自动识别    |

示例，挂载分区文件。

```
mount /dev/sdb2 /backup
```

命令 mount 只是临时挂载，重启后失效。若想永久挂载，需按以下格式在 */etc/fstab* 文件添加内容，系统启动时将根据该文件进行自动挂载

```
设备文件 挂载目录 格式类型 权限选项 自检 优先级
```

| 字段     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 设备文件 | 硬盘或分区的绝对路径或唯一识别码（UUID，Universally Unique Identifier） |
| 挂载目录 | 挂载到的目录，需要提前创建                                   |
| 格式类型 | 文件系统格式，比如 Ext3、Ext4、XFS、SWAP                     |
| 权限选项 | 若为 defaults，则默认权限为 rw, suid, dev, exec, auto, nouser, async |
| 自检     | 若为 1 开机后会进行磁盘自检，为 0 则不自检                   |
| 优先级   | 多块磁盘自检的优先级                                         |

示例，永久挂载设备文件。

```
/dev/sdb2 /backup XFS defaults 0 0
```

#### 卸载 umount

撤销已挂载的磁盘或分区

```
umount 挂载目录|分区文件|硬盘文件
```

### 查看挂载信息 df

查看硬盘和分区的挂载情况以及磁盘使用量

```
df 参数
```

| 参数 | 说明                                                       |
| ---- | ---------------------------------------------------------- |
| -a   | 显示所有文件系统的磁盘使用情况，包括 0 块（block）文件系统 |
| -h   | 以更易读的格式显示文件大小，比如 1KB、2MB、3GB             |

### 统计文件大小 du

统计目录或文件占用的磁盘空间大小

```
su 参数 文件
```

| 参数 | 说明                                           |
| ---- | ---------------------------------------------- |
| -a   | 显示指定文件或目录的所有文件的磁盘使用情况     |
| -s   | 仅显示总计，即目录大小                         |
| -h   | 以更易读的格式显示文件大小，比如 1KB、2MB、3GB |

## 添加交换分区

交换分区 SWAP 是特殊的分区类型，亦称虚拟内存。当物理内存用光时，系统会把一些不常用的数据临时转存到硬盘 SWAP 分区，以腾出内存空间给其它服务运行使用。但不管怎样，交换分区本质是磁盘存储，速度自然无法与物理内存相比。通常，交换分区的大小是物理内存 1.5～2 倍。

交换分区同样使用 fdisk 命令创建，但它的格式化和挂载使用其它命令。

格式化交换分区

```
mkswap 交换分区
```

挂载交换分区，注意，交换分区没有挂载目录。

```
swapon 交换分区
```

永久挂载，同样是在 */etc/fstab* 文件添加内容，其中挂载目录和格式类型都是 swap 字段。

```
设备文件 swap swap 权限选项 自检 优先级
```

## 磁盘容量配额

因为存储资源有限，如果某个用户不断创建新文件，存储空间总被会用完。为此，Root 用户可以使用 quota 服务管理存储资源，限制普通用户的磁盘可用容量或文件创建数量，限制分为两种：

* 软限制：达到上限时会提示用户，但仍允许用户在指定额度内继续使用；
* 硬限制：达到上限时会提示用户，且强制终止用户的操作。

虽然 RHEL 7 集成 quota 程序包，但是存储设备默认不支持 quota 服务，需要修改文件 */etc/fstab* 开启支持，直接添加 uquota 权限到对应的设备的行即可。

```
UUID=d25acbf0-9bf3-4730-b986-d62b76cd438b  /boot  xfs  defaults,uquota  0  0
```

### 服务配额 xfs_quota

命令 xfs_quota 专门针对 XFS 文件系统进行 quota 磁盘容量配额管理，参数 -c 指定要执行的操作，参数 -x 开启专家模式以进行更复杂的配置。

```
xfs_quota 参数 配额文件系统
```

示例，限制用户 tony 对目录 */boot* 的使用，磁盘使用量软限制和硬限制分别是 3MB 和 6MB，创建文件数量软限制和硬限制分别是 3 个和 6 个。

```
xfs_quota -x -c 'limit bsoft=3m bhard=6m isoft=3 ihard=6 tony' /boot
```

### 修改配额 edquota

命令 edquota 将会用 vi 打开指定对象的配额文件，Root 用户可以在此进行修改，参数 -u 指定用户，参数 -g 指定用户组。

```
edquota 参数 用户
```

> 安装 edquota 软件包
>
> ```
> yum -y install edit quota
> ```

## 软硬文件链接

通过链接文件，用户可以访问原本存放在其它位置的文件，类似 "快捷方式"，Linux 链接文件分为两种类型：

* 硬链接 Hard Link：可以看作指向原文件的 inode 的指针，系统不为它分配 inode 和 block，硬链接与原文件是同一个文件，删除原文件硬链接依然可用。仅当硬链接数为 0 时，文件才算彻底删除。由于技术限制，无法跨分区对目录进行链接。
* 软链接 Symbolic Link：它仅包含原文件的路径，因此可以链接目录，也能跨域，删除原文件链接失效。

命令 ln 创建链接，参数 -s 表示创建软链接，默认硬链接；参数 -f 强制执行；参数 -i 覆盖前先询问；参数 -v 显示创建链接的过程。

```
ln 参数 目标文件 链接文件
```

# Shell 脚本和流程控制

## 基本框架

命令解释器 Shell 有两种使用方式：交互式、批处理，交互式对用户输入的命令立即执行，批处理是一次执行多条命令，这些命令的集合就是 Shell 脚本。所以，脚本的本质是命令集合，它使用循环、分支和参数等特性，把功能模块化，以此简化使用和增强服务。

脚本文件的名字任意，常以 .sh 作为后缀进行标识。脚本的第一行是声明 "#!"，这告知系统应使用哪种 Shell 解释器来执行该脚本，其余行则是脚本的命令和注释。

```
#!/bin/bash
# this is annotation
echo `date` >> /dev/null
```

> 设备文件 */dev/null* 可以接收无限数据，但不占任何存储空间，把输出信息重定向到它相当于删除数据。

脚本的执行有两种方式，第一种方式，调用 Shell 解释器的命令，比如 "bash 文件"。第二种方式，直接输入脚本文件的路径，系统会调用对应 Shell 解释器执行脚本，但用户需拥有该文件的可执行权限

## 命令参数

**参数变量**

Shell 脚本能够接收输入参数，参数之间使用空格分隔，脚本执行时会为这些参数设置对应变量，比如，$0 是当前脚本的名称，$1 是第 1 个输入参数，$* 是所有参数，$# 是参数个数，$? 是上一条命令的返回。

**读取输入**

脚本执行期间，可以用 read 命令向用户请求输入信息，参数 -p 设置提示信息，参数 -s 指示隐藏输入内容，最后命名一个变量存放输入内容。

```
read -p "提示信息" 变量名称
```

## 条件测试

条件测试用于对参数进行判断，条件成立返回数字 0，格式 "[ 条件表达式 ]"，表达式两侧的空格必须存在。根据测试对象划分，条件测试语句可分为 4 种。

**文件测试语句**

判断测试文件是否存在，或用户权限是否满足等。

| 运算符 | 说明                             |
| ------ | -------------------------------- |
| -e     | 文件是否存在                     |
| -d     | 文件是否为目录                   |
| -f     | 是否为普通文件                   |
| -r     | 当前用户是否有该文件的可读权限   |
| -w     | 当前用户是否有该文件的可写权限   |
| -x     | 当前用户是否有该文件的可执行权限 |

示例，判断指定文件是否存在。

```
[ -e /etc/hosts ]
```

**逻辑测试语句**

逻辑运算符用于连接多个测试语句

| 运算符 | 说明                                   |
| ------ | -------------------------------------- |
| &&     | 与，前一个条件正确，才执行后一个条件。 |
| \|\|   | 或，前一个条件错误，才执行后一个条件。 |
| !      | 非，取测试的相反结果                   |

示例，检查当前是否为 Root 用户。

```
[ ! $USER = root ] && echo "user" || echo "root"
```

**整数值比较语句**

比较两个数字间的大小，不能把数字和字符串、文件等进行比较。

> 别想当然地使用 =、>、< 等符号，它们有重定向等其它含义。

| 运算符 | 说明     |
| ------ | -------- |
| -eq    | 等于     |
| -ne    | 不等于   |
| -gt    | 大于     |
| -lt    | 小于     |
| -le    | 小于等于 |
| -ge    | 大于等于 |

示例，判断 10 是否等于 10。

```
[ 10 -eq 10 ]
```

**字符串比较语句**

| 运算符 | 说明           |
| ------ | -------------- |
| =      | 字符串是否相同 |
| !=     | 字符串是否不同 |
| -z     | 字符串是否为空 |

示例，检查系统的语言是否为美国英语。

```
[ $LANG != "en.US" ] && echo "Not en.US"
```

## 分支和循环

### 条件执行 if

```
if 条件测试 then 命令序列
	elif 条件测试 then 命令序列
	elif 条件测试 then 命令序列
	else 命令序列
fi
```

> 如果想把多条命令写在同一行，可用分号 ; 分隔命令。

### 条件循环 for

```
for 变量 in 取值列表
	do 命令序列
done
```

示例，按行输出文本文件内容

```
for item in ~/filename
	do echo $item
done
```

示例，依次输出列出的几个值

```
for item in 1 3 5 cat dog
	do echo $item
done
```

示例，依次输出 1 到 5 的值

```
for item in {1..5}
	do echo $item
done
```

```
for item in 5
	do echo $item
done
```

示例，依次输出 1 到 10 的值，间隔值为 2

```
for item in {1..10..2}
	do echo $item
done
```

示例，输出当前目录下的所有文件和文件夹

```
for file in $(ls)
	do echo $file
done
```

### 条件循环 while

满足条件之后，可以执行 exit 0 命令退出脚本。

```
while 条件测试
	do 命令序列
done
```

### 条件分支 case

```
case 变量 in
	模式1) 命令序列
	;;
	模式2) 命令序列
	;;
	*) 默认命令序列
esac
```

示例，判断变量存储字符的类别，这里使用分号括起变量的值，以把它转为字符串。

```
case "$VAR" in 
	[a-z]|[A-Z]) echo "字母。"
	;;
	[0-9]) echo "数字。"
	;;
	*) echo "空格、功能键或其它控制字符。"
esac
```

# VMware 网络模式

打开虚拟网络编辑器，可以发现有 3 个虚拟交换机，它们分别对应 VMware 的 3 种网络模式：

* VMnet0：用于桥连接模式的虚拟交换机
* VMnet1：用于仅主机模式的虚拟交换机
* VMnet8：用于 NAT 模式的虚拟交换机

与之对应，Windows 主机将会生成两个虚拟网卡（没有 VMware Network Adapter VMnet0 网卡）：

* VMware Network Adapter VMnet1
* VMware Network Adapter VMnet8

所以，加上物理网卡，物理主机应该会有 3 个 IP 地址。

## 桥连接模式

桥接模式下的所有虚拟机以及物理机都会连接到 VMnet0 虚拟交换机，网卡与网卡之间都是交换模式，它们以此进行相互通信，彼此都是平等关系，互不干扰。

另外，**虚拟机与物理机应该处于相同网段，如果虚拟机需要联网，网关和 DNS 还需与主机保持一致**。这些条件会限制桥接模式的虚拟机数量，因为网段 IP 数量有限。

## 仅主机模式

仅主机模式可以看作是 NAT 模式去除虚拟 NAT 设备，然后使用 VMware Network Adapter VMnet1 虚拟网卡连接 VMnet1 虚拟交换机从而与虚拟机通信。仅主机模式把虚拟机与外网隔开，使虚拟机成为一个独立系统，只与主机相互通信。

## NAT 模式

NAT 模式下的主机网卡将直接与虚拟 NAT 设备相连，然后虚拟 NAT 设备会与虚拟 DHCP 服务器一起连接到虚拟交换机 VMnet8。这样，虚拟机就能通过交换机使用主机真实 IP 访问互联网，主机在此扮演路由器的角色。

交换机 VMnet8 会为虚拟机分配地址，所以**虚拟机应与交换机处于相同网段**，而物理机则处于其它网段。可以把物理机理解为虚拟机的上级，这也解释为什么桥接模式没有 VMnet0 虚拟网卡，因为物理机与虚拟机平等，它们共用同一个路由器。

网卡 VMware Network Adapter VMnet8 用于物理机与虚拟机之间通信，但虚拟机与互联网通信时不是使用这个虚拟网卡。
