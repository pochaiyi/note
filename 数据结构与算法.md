# 排序的基本概念

为查找方便，将序列中的元素按关键字大小进行排序。根据排序过程中是否把所有元素加载到内存，排序可以分为内部排序和外部排序。

关键字相等的元素，如果排序后相对位置不变，这种排序算法就是稳定的。

## 插入排序

插入排序是一种简单直观的排序方法，它的思想是：每次从待排序列取出一个元素，将其按关键字大小插入前面已排序好的子序列，直到所有元素都被插入。由插入排序引申出：直接插入排序、折半插入、希尔插入。

**直接插入排序**

插入排序最纯粹的实现，将第一个元素看作已排序好的子序列，然后遍历后面的元素，将其插入已排序子序列。

时间复杂度为 *O(n^2)*，主要操作是查找插入位置，和对插入位置后面的元素移位。

**折半插入**

直接插入是边找插入位置，边移动元素。折半插入是使用二分查找，找到插入位置，再移位。它的优化只是使用二分查找来找插入位置，时间复杂度为 *O(n^2)*。

**希尔排序**

观察直接插入，发现如果序列基本有序，算法的时间复杂度将大幅度下降，最多能降到 *O(n)*。希尔排序使用分割增量将待排序列分成若干个部分，对这些子部分进行直接插入排序。然后使用一个更小的增量来拆分待排序列，反复迭代，直到分割增量为 1，此时序列整体有序。

分割增量的确定：d1 = n/2，d2 = d1/2，d3 = d4/2，...

希尔排序是不稳定的。它的时间复杂度很难计算，当 n 在某个范围时，*为 O(n^1.3)*，最坏时为 *O(n^2)*。

## 交换排序

通过比较关键字，交换序列中元素的位置。

**冒泡排序**

从前往后，依次遍历所有元素，将其中关键字最大的那个元素移动到序列尾部。每次都能确定一个元素的最终位置，已确定的元素不再参与之后的比较，n-1 次循环后，序列整体有序。

时间复杂度为 *O(n^2)*。

**快速排序**

基于分治的思想，每次选择一个元素作为分界点，关键字大于分界点的元素被移动到右边，比它小的元素被移动到左边。这样一趟排序后，这个分界点元素的最终位置就被确定，然后递归处理左右子序列，直到各个子序列只包含一个元素。

快排的时间复杂度与分界点的选择有关，划分的左右部分越平均，复杂度就越低。如果每次划分都是平衡的，时间复杂度为 *O(nlogn)*。如果每次划分都是极端不平衡的，即有一边只包含 0 个元素，时间复杂度为 *O(n^2)*。快排的平均时间复杂度接近最优情况，所以它是内部排序算法中平均性能最优的。

快排是不稳定的。

## 选择排序

选择排序思想：遍历序列，每次都从后面的 n-i+1 个待排元素选出最小项，作为有序子序列的第 i 个元素。n-1 次迭代后，序列整体有序。

**简单选择排序**

选择排序最纯粹的实现。它移动元素的次数很少，但比较元素的次数是固定的，时间复杂度为 *O(n^2)*。

简单选择排序是不稳定的。

**堆排序**

将数据组织为堆的树状结构，适合关键字较多的情况。

## 归并排序

基于分治思想。它将两个或以上的有序序列组成一个新的有序序列。首先将 n 个元素看作 n 个有序序列，然后两两归并，直到合并为一个序列。

它最好和最坏情况的时间复杂度都是 *O(nlogn)*，但需要占用 *O(n)* 的辅助空间。

## 基数排序

基数排序不是基于比较和移动进行排序，而是基于关键字各位的大小进行排序。它借助一种多关键字排序的思想对单逻辑关键字的元素进行排序。

对于混合关键字，可以按高位优先或低位优先的策略进行排序，每个关键字的排序，都要根据其值将所有元素进行分配，然后按序组合。最后得到整体有序的序列。

# 基础算法

## 快速排序（Quick）

快排基于分治思想。

**算法思想：**

1. 从待排序列中选择任意一个元素作为分界点，可以是左边界、右边界、中位数。
2. 将小于等于分界点的元素放在左边，大于等于的元素放在右边。
3. 对分界点两边元素递归进行第二步的操作，直至待排序列只有一个元素。

**模板：**

```
static void sort(int[] q, int l, int r) {
    if (l >= r) return; // 左边界=有边界，说明只有一个元素
    int i = l - 1, j = r + 1; // 双指针，为方便循环体中的计算先 +/-1
    int x = q[l + r >> 1]; // 中间位置
    while (i < j) {
        do i++; while (q[i] < x); // i 表示从左开始第一个 >= x 的数
        do j--; while (q[j] > x); // j 表示从右开始第一个 <= x 的数
        if (i < j) swap(q, i, j);
    }
    sort(q, l, j);
    sort(q, j + 1, r);
}

static void swap(int[] q, int i, int j) {
    int tmp = q[i]; q[i] = q[j]; q[j] = tmp;
}
```

边界问题：模板使用中间元素作为分界点，还可以选择左/右边界。但选择左/右边界时可能会出现边界问题，下面具体分析：

* 使用 `quicksort(q,l,j); quicksort(q,j+1,r);` 排序 {1,2}，如果选择 q[r] 作为分界点，会陷入 `quicksort(q,0,1)` 的无限循环。

* 使用 `quicksort(q,l,i-1); quicksort(q,i,r);` 排序 {1,2}，如果选择 `q[l]` 作为分界点，会陷入 `quicksort(q,0,1)` 的无限循环。

`quicksort(q,l,j); quicksort(q,j+1,r);` 和 `quicksort(q,l,i-1); quicksort(q,i,r);` 的 i 和 j 不能互换，否则会出现问题。

快排的思想很简单，但中间排序的步骤千差万别，还有各种边界问题，不如直接使用被千锤百炼过的模板。

***

**题目：排序后第 k 个数**

给定长度 n 的整数数列，以及整数 k，请求出数列从小到大排序后的第 k 个数。

**题解：**

可以使用普通的排序算法，如快排，复杂度为 *nlog(n)*。但本题与普通排序不同，它只是求排序后第 k 个数，而第 k 个数之后的数其实是不需要排序的。结合快速排序的思想，每次迭代根据分界点将序列分为两个部分，将左半部分的元素个数与 k 比较，如果大于等于 k，那么第 k 个数绝对在这边，否则在右半部分。下次计算，只对包含第 k 个数的那一半进行迭代。如果在右半部分，需要更新 k 的位次。

复杂度：*n + n/2 + n/4 + n/8 + ... < 2n*。

**模板：**

```
// 返回排序后第k位数
static int sort(int[] q, int l, int r, int k) {
    if (l >= r) return q[l];
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j) {
        do i++; while (q[i] < x);
        do j--; while (q[j] > x);
        if (i < j) swap(q, i, j);
    }
    // 关键
    if (j - l + 1 >= k) return sort(q, l, j, k);
    else return sort(q, j + 1, r, k - j + l - 1);
}
```

## 归并排序（Merge）

归并排序基于分治思想。

**算法思想：**

1. 选择待排序列中间位置作为分界点。
2. 递归排序左右区间。
3. 使用双指针合并排序好的两个区间。

**模板：**

```
static void sort(int[] q, int l, int r) {
    if (l >= r) return;
    
    int mid = l + r >> 1;
    sort(q, l, mid); // 线排序小集合，再逐步合并它们
    sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1; // i遍历左半部分，j遍历右半部分
    int[] t = new int[r - l + 1];
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) t[k++] = q[i++]; // 严格排序
        else t[k++] = q[j++];
    }
    // 处理剩余的元素
    while (i <= mid) t[k++] = q[i++];
    while (j <= r) t[k++] = q[j++];
    for (i = l, j = 0; i <= r; i++, j++) q[i] = t[j];
}
```

根据模板，可以这么理解归并排序：先将序列分割成只有一个元素的子集，此时，这些子集都是有序的。然后从小到大合并它们。使用双指针反复迭代遍历，直至全部元素排序完。可以将这个过程想象为从底到根遍历二叉树，至多有 *log(n)* 层，时间复杂度就是 *nlog(n)*。

## 二分查找（Binary）

> 只有按升序排列的序列才能使用二分查找。

二分的本质不是单调，而是查找某种性质的边界。比如，某序列按某种性质分为左右两部分，二分就是查找这两个部分的分界点。如果是整数二分，分界点有两个：左半部分的上界和右半部分的下界。如果是浮点数二分，分界点只有一个。

**算法思想：**

每次迭代都验证区间中位数的值，判断目标是在中间点左边还是右边，从而缩小查找区间。等到区间足够小时（整数二分是区间只有一个元素，浮点数二分是左右分界点之差小于精度），目标就是这个区间的边界。

**整数二分模板：**

```
// 大于等于，找右半部分的下界
static int searchL(int[] q, int l, int r, int x) {
    while (l < r) {
        int mid = l + r >> 1;
        if (q[mid] >= x) r = mid;
        else l = mid + 1;
    }
    if (q[l] != x) return -1;
    else return l;
}
```

```
// 小于等于，找左半部分的上界
static int searchR(int[] q, int l, int r, int x) {
    while (l < r) {
        int mid = l + r + 1 >> 1; // 注意需要+1
        if (q[mid] <= x) l = mid;
        else r = mid - 1;
    }
    if (q[l] != x) return -1;
    else return l;
}
```

**浮点数二分模板：**

```
static double INF = 1e5;
static double eps = 1e-8; // eps表示精度经验，经验：指数=目标精度+2

static bool check(double x) {/* 判断x是否满足某种性质 */}

static double search(double x) {
    double l = -INF, r = INF;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## 前缀和：快速求区间和

**一维前缀和**

对于一个数组，前缀和就是前 i 个元素之和。

前缀和有什么用呢？使用式子 `S(r)-S(l-1)` 可以快速求得数组某个区间的元素之和。

**公式：**

```
S[i] = a[1] + a[2] +...a[i];
a[l] +...+a[r] = S[r] - S[l - 1];
```

数组计算前缀和，下标通常从 1 开始，这样就不用特判 S[1]。

**二维前缀和**

将二维数组想象成矩阵，点 `(i,j)` 的前缀和就是 `(0,0) (0,j) (i,0) (i,j)` 四点围成的矩阵包含的元素之和。

**公式：**

```
// 求点a[i,j]的二维前缀和
S[i, j] = S[i-1, j] + S[i, j-1] - S[i-1, j-1] + a[i, j]
```

```
// 求以(x1,y1)为左上角，(x2,y2)为右下角的子矩阵的所有元素和
S[x2, y2] - S[x1-1, y2] - S[x2, y1-1] + S[x1-1, y1-1]
```

## 差分：快速对区间元素运算

**一维差分**

对于一维数组 A，它的前缀和数组是 B，那么 A 就是 B 的差分。差分是前缀和的逆运算。

差分有什么用呢？它能快速对数组某个区间的元素做相同的运算。比如，想对 `[l,r]` 区间的元素加 1，可以对它的差分数组第 l 个元素 +1，然后对第 r+1 个元素 -1 以消除对其它元素的影响。

**公式：**

```
// 区间[l,r]所有元素加c
b[l] += c; b[r+1] -= c;
```

构造数组的差分数组，也是使用上面的式子，只不过此时区间只有一个元素。

**二维差分**

对于二维数组，它的差分矩阵的前缀和等于对应点的值。

**公式：**

```
// 给以(x1,y1)为左上角，(x2,y2)为右下角的子矩阵的所有元素加上c
S[x1, y1] += c;
S[x2+1, y1] -= c;
S[x1, y2+1] -= c;
S[x2 + 1, y2+1] += c;
```

要构造二维数组的差分矩阵，可以使用上面的公式，相当于对只有一个元素的矩阵做运算。

## 双指针

双指针算法没有定式，它主要用于优化原始的暴力做法。常见的使用方式：

* 参考归并，使用 i 和 j 两个指针对数组遍历，以维护某种次序；
* 参考快排，使用 i 和 j 两个指针分别从头和尾向中遍历，维护一段区间。

**模板：**

```
for (int i = 0, j = 0; i < n; i++) {
    while (j < i && check(i, j)) j++;
    // 具体问题的逻辑
}
```

## 位运算

**模板：**

```
// 求n的二进制数第k位数字
n >> k & 1
```

```
// 返回n的最后一位1
n & -n
```

## 离散化

> 这里讨论整数的保序离散化，即映射后的顺序与映射前一致。

如果操作数值域非常大，而实际操作的数并没有这么多，不可能定义这么大的一个数组。比如，在 `[0,10^9]` 的范围内随机操作一个整数，难道要定义 *10^9* 这么大的一个数组么？此时可以使用离散化，只记录真正被操作的数，即存到数组，然后把它们映射为自然数。常用做法是排序去重，然后取其下标为映射数。

**问题：区间和**

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。

接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 `[l,r]` 之间的所有数的和。

**题解：**

为什么要使用离散化呢？因为操作数的范围实在太大了，开这么大的数组不现实。第二个原因，本文是数轴，要是采用下标的话，无法表示负值。有人可能会提出使用哈希表，但也是不行的。使用哈希表我们不能提前知道哪些数轴上的点存在哪些不存在，只能将区间所有值都枚举一遍，时间复杂度太高。

离散化的本质，是映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量。

实际操作的数轴点是零散的，如何将它们映射到连续的数组下标呢？此处的解决办法是使用一个单独的数组 `index` 存放所有被操作的数轴点。然后设计一个 `find` 方法，它能返回指定的数轴点在 `index` 中的下标。比如，`index[i]` 存放实际被操作的数轴点 x，`find(x)` 会返回 x 在 `index` 中的下标 i。

然后，再单独使用一个数组 `value` 存放数轴点的值。当然也是离散化，而且它应该与 `index` 一一对应，即 `index[i]` 储存的是数轴点 x，那么 x 点的值应该等于 `value[find(x)]`。`index` 数组从下标 0 开始存储，为了方便对 `value` 求前缀和，可以将 `find` 的返回值 +1，以减免对第一个元素的特判。

可以使用 `Arrays.binarySearch + 1` 替换 `find` 方法。

**代码：**

```
class Main {

    // 使用Arrays.binarySearch替代find方法
    static int find(Integer[] q, int x) {
        int l = 0, r = q.length - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if (q[l] == x) return l + 1; // 下标+1，方便计算前缀和
        return -1;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();
        int len = n + 2 * m; // 最多有n+2m个数轴点

        TreeSet<Integer> set = new TreeSet<>(); // 使用TreeSet储存所有下标，排序+去重

        int[] opIdx = new int[n]; // 添加操作
        int[] opNum = new int[n];
        for (int i = 0; i < n; i++) {
            opIdx[i] = in.nextInt();
            opNum[i] = in.nextInt();
            set.add(opIdx[i]);
        }

        int[] ql = new int[m]; // 查询操作
        int[] qr = new int[m];
        for (int i = 0; i < m; i++) {
            ql[i] = in.nextInt();
            qr[i] = in.nextInt();
            set.add(ql[i]);
            set.add(qr[i]);
        }

        Integer[] index = set.toArray(new Integer[0]); // 获得下标数组index

        // 给数轴点赋值
        int[] value = new int[len + 1];
        for (int i = 0; i < n; i++) value[Arrays.binarySearch(index, opIdx[i]) + 1] += opNum[i];

        // 前缀和
        int[] s = new int[len + 1];
        for (int i = 1; i <= len; i++) s[i] = s[i - 1] + value[i];

        // 处理查询
        for (int i = 0; i < m; i++) {
            int l = Arrays.binarySearch(index, ql[i]) + 1, r = Arrays.binarySearch(index, qr[i]) + 1;
            System.out.println(s[r] - s[l - 1]);
        }
    }
}
```

## 区间合并

顾名思义，是把有交集的区间合并为一个区间。区间合并不是一种算法，而是一类问题。

**问题：区间合并**

给定 n 个区间 `[li,ri]`，要求合并所有有交集的区间。

注意如果在端点处相交，也算有交集。

输出合并完成后的区间个数。

例如：`[1,3]` 和 `[2,6]` 可以合并为一个区间 `[1,6]`。

**代码：**

贪心思想合并区间。

```
class Main {

    static int INF = 0x3f3f3f3f;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        Seg[] ss = new Seg[n];
        for (int i = 0; i < n; i++) {
            int l = in.nextInt(), r = in.nextInt();
            ss[i] = new Seg(l, r);
        }

        Arrays.sort(ss); // 将所有区间按左端点从小到大排序
        int ans = 1;
        int ed = ss[0].r;
        for (int i = 1; i < n; i++) {
            Seg t = ss[i];
            if (t.l <= ed) ed = Math.max(ed, t.r); // 更新区间最右端点
            else {
                ed = t.r;
                ans++;
            }
        }
        System.out.print(ans);
    }
}

class Seg implements Comparable<Seg> {
	...
}
```

# 数据结构

## 数组单链表

使用两个数组，结合表示结点：一个储存结点的值，另一个储存下一个结点的位置（下标）。

**模板：**

```
int N = 100000;
int head; // 头结点位置
int[] e = new int[N]; // 结点值
int[] ne = new int[N]; // 下一个结点的位置
int idx; // 新结点位置

// 初始化
void init() {
    head = -1; idx = 0;
}

// 删除头结点
void del(int k) {
    head = ne[head];
}

// 向表头插入一个元素
void add2head(int x) {
    e[idx] = x; ne[idx] = head; head = idx++;
}

// 在第k个插入的元素后面插入x
void insert(int k, int x) {
    e[idx] = x; ne[idx] = ne[k]; ne[k] = idx++;
}
```

## 数组双链表

在数组单链表的基础上增加一个数组，存储上一个结点的位置。

**模板：**

```
int N = 100000;
int[] e = new int[N]; // 结点值
int[] l = new int[N]; // 下一个结点的位置
int[] r = new int[N]; // 上一个结点的位置
int idx; // 新结点位置

// 初始化，使用前两个位置表示链表端点，端点不是链表结点
void init() {
    r[0] = 1; l[1] = 0; idx = 2;
}

// 在链表的最左端插入x（在左端点右侧插入）
void add2l(int x) {
    insert2r(0, x);
}

// 在链表的最右端插入x（在右端点左侧插入）
void add2r(int x) {
    insert2l(1, x);
}

// 删除第k个插入的元素
void del(int k) {
    r[l[k]] = r[k]; l[r[k]] = l[k];
}

// 在第k个插入的元素左侧插入x
void insert2l(int k, int x) {
    insert2r(l[k], x);
}

// 在第k个插入的元素右侧插入x
void insert2r(int k, int x) {
    e[idx] = x;
    l[idx] = k;
    r[idx] = r[k];
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}
```

## 数组栈

使用数组模拟栈，用一个变量标记栈顶。

**模板：**

```
int N = 100000;
int[] stack = new int[N]; // 数组栈
int top = 0; // 栈顶元素位置，0表示栈空

// 向栈顶插入一个元素x
void push(int x) {
    stack[++top] = x;
}

// 从栈顶弹出一个元素
int pop() {
    if (!empty()) {
        return stack[top--];
    } else {
    ...
    }
}

// 判断是否栈空
boolean empty() {
    return top <= 0;
}

// 查询栈顶元素
int query() {
    if (!empty()) {
        return stack[top];
    } else {
    ...
    }
}
```

## 数组队列

使用数组模拟队列，用两个变量标记队头和队尾。

**模板：**

```
int N = 100000;
int[] queue = new int[N];
int head = 0; // 队头位置
int tail = -1; // 队尾位置，-1表示队空

// 向队尾插入x
void push(int x) {
    queue[++tail] = x;
}

// 弹出队头元素
int pop() {
    return queue[head++];
}

// 判断是否队空
boolean empty() {
    if (head > tail) {
        return true;
    } else {
        return false;
    }
}

// 查询队头元素
int query() {
    if (!empty()) {
        return queue[head];
    } else {
...
    }
}
```

## 单调栈：求每个数左边最近的小于数

**问题：单调栈**

给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。

**题解：**

观察双重循环的暴力做法，发现某些数字在某些时候永远都不会被选中：假设 a1 a2 相邻，a1 >= a2，且 a1 在 a2 的左边。那么 a1 就永远都不可能被选中。因为如果 a1 比目标小，那么 a2 也必然小于目标，a2 又是在 a1 的右边，它会优先被选中。所以当 a1 加入数列后就可以将 a2 删除，构成一个上升的单调栈。

每个数最多只有入栈和出栈各一次操作，时间复杂度是 *2n*。

**代码：**

```
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    int[] track = new int[n];
    int top = 0; // 栈顶上一个位置，0表示栈空

    for (int i = 0; i < n; i++) {
        int t = in.nextInt();
        while (top > 0 && track[top] >= t) top--;
        if (top <= 0)
            System.out.print(-1 + " ");
        else
            System.out.print(track[top] + " ");
        track[++top] = t;
    }
}
```

## 单调队列：求滑动窗口最值

**问题：滑动窗口**

给定一个大小为 n ≤ 10^6 的数组。有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 k 个数字。每次滑动窗口向右移动一个位置。你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

**题解：**

求最小值时，滑动窗口中的某些数字在某些时候永远都不会被选中：假设 a1 a2 都在窗口中，a1 >= a2，且 a1 在 a2 左侧。那么只要 a2 在窗口中，a1 就不可能被选中。而且 a1 还在 a2 的左边，它会先滑出窗口。所以当 a2 加入窗口时，就可以直接删除 a1，构成一个上升的单调队列。队头元素始终是当前窗口的最小数。

求最大值则使窗口维持一个递减的单调队列即可。

**代码：**

下例是求滑动窗口最大值的代码。

```
int[] res = new int[nums.length - k + 1]; // res存储滑动窗口最大值
Deque<Integer> q = new ArrayDeque<>(); // 使用队列模拟窗口，它存储的是元素下标

for (int i = 0, j = 0; i < nums.length; i++) {
    if (!q.isEmpty() && q.peek() < i-k+1) q.poll(); // 确保队头元素仍在窗口内
    while (!q.isEmpty() && nums[i] > nums[q.peekLast()]) q.pollLast(); // 删除可忽略元素
    q.offer(i); // 加入新元素
    if (i >= k - 1) res[j++] = nums[q.peek()]; // 存储最大值
}
return res;
```

## KMP：匹配子串

> *KMP* 可以快速匹配两个字符串。字符串哈希可以获取其子串的哈希值，所以能很快速找到相同的子串。

*KMP* 是一种改进的字符串匹配算法，由 *D.E.Knuth*，*J.H.Morris* 和 *V.R.Pratt* 提出。*KMP* 算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的，具体通过一个 `next()` 函数实现。

**题目：KMP 字符串**

给定一个主串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 P 在主串 S 中多次作为子串出现。

求出模式串 P 在主串 S 中所有出现的位置的起始下标。

**题解：**

观察双重循环的暴力做法，将 P 串想象为滑动窗口，它是一个字符一个字符的向后移动来尝试匹配的。如果当前字符匹配失败，P 串就整体向后移动一位从头开始匹配，直至滑动到主串尾部。但我们发现，在匹配失败的字符前面的那部分子串，是主串与 P 串完全相同的一部分。是否可以利用这段子串，优化后续的匹配呢？

如果我们知道 P 串的一些性质：它所有从第一个字符出发的子串，前缀和后缀的最长共有元素的长度。就能优化匹配。

什么是 "前缀和后缀的最长共有元素的长度"？假如 P 串为 *"abababb"*，*"abab"* 是它的从 0 出发，长度为 4 的子串。这个子串的前缀 *"ab"* 与后缀 *"ab"* 相同，长度为 2。那么子串 *"abab"* 的 "前缀和后缀的最长共有元素的长度" 就是 2。

知道这个有什么用呢？假如 P 串已经与主串匹配到第 5 个字符，如果这个字符匹配失败，暴力做法是 P 整体向后滑动一位然后从头开始匹配。但现在我们知道已匹配子串 *"abab"* 的这个性质，就可以将 P 串多滑动 1 位，且从第 3 个字符开始匹配。参看下图示意：

```
S 串：	x x	a b a b x x x x
P 串：		a b a b (第5个字符匹配失败)
向后滑动：	      a b (滑动2位，并从第3位开始匹配，前两位字符根据性质已知相等)
```

我们用 `next` 数组储存 "前缀和后缀的最长共有元素的长度"。`next[i]` 的值表示当 P 串前 i 个字符匹配，而第 *i+1* 个字符不匹配时，我们可以将 P 串向后滑动 `next[i]` 位，然后从第 `next[i] + 1` 位字符重新与主串匹配。

`next` 的计算是用 P 串与自己匹配。i 表示后缀结尾，j 表示前缀结尾。什么意思呢？假如匹配到 i 和 j+1，说明在 P 串中，它的 `[1,j]` 与 `[i-j-1,i-1]` 是相等的，而 `[1,j]` 是子串 `[1,i-1]` 的前缀，`[i-j-1,i-1]` 是它的后缀，这不就是我们要找的 "前缀和后缀的最长共有元素的长度" 么。如下图所示：

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/algorithm-4a6d8a0d.png)

**代码：**

```
public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(in.readLine());
        String P = in.readLine();
        int m = Integer.parseInt(in.readLine());
        String S = in.readLine();

        char[] p = new char[n + 1], s = new char[m + 1];
        for (int i = 1; i <= n; i++) p[i] = P.charAt(i - 1);
        for (int i = 1; i <= m; i++) s[i] = S.charAt(i - 1);

        // 计算next数组
        int[] next = new int[n + 1];
        for (int i = 2, j = 0; i <= n; i++) { // next[1] = 0，跳过
            while (j != 0 && p[i] != p[j + 1]) j = next[j]; // next[0]=0，会死循环
            if (p[i] == p[j + 1]) j++;
            next[i] = j;
        }

        for (int i = 1, j = 0; i <= m; i++) { // i遍历主串，j遍历模板串，S[i]与P[j+1]比较
            while (j != 0 && s[i] != p[j + 1]) j = next[j]; // 利用next数组，重设匹配位置
            if (s[i] == p[j + 1]) j++;
            if (j == n) {
                out.print(i - n + " "); // 通常计算起始下标是i-n+1，但i从1开始，需要-1，抵消
                j = next[j];
            }
        }
        in.close();
        out.close();
    }
}
```

## Trie 树：字符串集合的存储和查找

*Trie* 树能在字符串集合中高效地存储和查找字符串。

**算法思想：**

使用树结构储存字符串，一个结点存放一个字符，前后字符表现为父子结点。所以一个长度为 n 的字符串，在 *Trie* 树中表现为一条深度为 *n+1* 的路径（根结点作为起点，不存放字符）。

单个字符串的存储并不会节省空间，但在之后存储其它字符串时，如果新字符串与已储存的字符串具有相同的前缀，那么这些前缀结点就可以被新字符串共享。因此，*Trie* 树能节约许多空间，并快速存储字符串。

*Tire* 树查询字符串就更简单了。只需从根结点开始按顺序遍历字符串的字符，检查是否存在这么一段路径。相当于遍历一遍字符串的所有字符，如果不存在这样的字符串，在第一个无法匹配的字符就能直接返回，复杂度是 *n*。

不是所有的字符串都表现为从根结点到叶结点的路径，某条字符串可能是另一条字符串的子串。因此，需要额外标记字符串的尾结点。

**问题：Trie 字符串统计**

维护一个字符串集合，支持两种操作：

1. `I x` 向集合中插入一个字符串 x；
2. `Q x` 询问一个字符串在集合中出现了多少次。

共有 N 个操作，输入的字符串总长度不超过 100000，字符串仅包含小写英文字母。

**代码：**

```
static int N = 100010; // 一条字符串最多有10万个字符
static int[][] node = new int[N][26]; // 存放各结点的子结点，小写字母子结点最多只有26个
static int idx = 0;
static int[] cnt = new int[N]; // cnt[i]表示以node[i]结点结尾的字符串个数

// 储存
static void insert(String s) {
    char[] c = s.toCharArray();
    int p = 0; // 存和查都从根结点开始
    for (char value : c) {
        int u = value - 'a';
        if (node[p][u] == 0) node[p][u] = ++idx;
        p = node[p][u];
    }
    cnt[p]++;
}

// 查找
static int query(String s) {
    char[] c = s.toCharArray();
    int p = 0;
    for (char value : c) {
        int u = value - 'a';
        if (node[p][u] == 0) return 0;
        p = node[p][u];
    }
    return cnt[p];
}
```

## 并查集：合并集合，判断是否同集

并查集可以快速处理这类问题：合并两个集合，判断两个元素是属于同一个集合。

**算法思想：**

并查集使用多棵树存储元素，相同集合的元素存放在同一棵树。每个元素会记忆自己的父结点，设计根结点的父结点等于自己，根结点会储存集合的信息。所以，判断两个元素是否属于同一个集合，只需要检查它们的根结点是否相同。怎么合并两个集合呢？只需将一个集合的根结点的父结点修改为另一个集合的根结点。

**路径压缩：**

一个元素结点与它的根结点之间可能存在许多祖先结点，如果要频繁查找这个元素属于哪个集合，每次都要遍历这么长的路径。可以进行路径压缩优化：结点在查找它的根结点时，会自动更新它的父结点为根结点。而且，它还会递归地更新路径中其它结点的父结点为根结点。这样，在遍历一次长路径后，这个结点以及路径中的祖先结点都会直接指向根结点。之后的查询便会一步到位，复杂度从 *O(n)* 优化为 *O(1)*。

**问题：合并集合**

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 m 个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

**代码：**

```
static int N = 100010;
static int[] p = new int[N]; // p[i]=i点的父结点编号

// 返回x的根结点
static int find(int x) {
    if (p[x] != x) p[x] = find(p[x]); // 回调，路径压缩优化
    return p[x];
}
```

## 堆排序：快速获取最值

堆（*heap*），在 *Java* 中实现为优先队列 `PriorityQueue`。它满足以下两点：

* 堆总是一棵完全二叉树；

- 堆的结点的值总是不大于或不小于其父结点的值（小根堆，大根堆），此性质可以快速查找最值。

一维数组实现堆：下标 1 元素表示根结点；结点 x 的左孩子结点是 2x，右孩子结点是 2x+1。

堆有两个基本操作，分别将 x 向下或向上调整：

* `down(x)`：将 x 反复与其最小/最大的一个孩子结点交换位置，直至它比两个孩子结点都小/大。
* `up(x)`：将 x 反复与其父结点交换位置，直至它比父结点大/小。

**题目：堆排序**

输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。

输入：第一行包含整数 n 和 m。第二行包含 n 个整数，表示整数数列。

**代码：**

```
static int N = 100010;
static int[] heap = new int[N];
static int n, m, size;

// 向下调整
static void down(int x) {
    int min = x;
    if (2 * x <= size && heap[2 * x] < heap[min]) min = 2 * x;
    if (2 * x + 1 <= size && heap[2 * x + 1] < heap[min]) min = 2 * x + 1;
    if (min != x) {
        int t = heap[x]; heap[x] = heap[min]; heap[min] = t;
        down(min);
    }
}

// 向上调整
static void up(int x) {
    if (x / 2 != 0 && heap[x / 2] > heap[x]) {
        int t = heap[x]; heap[x] = heap[x / 2]; heap[x / 2] = t;
        up(x / 2);
    }
}

public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    n = in.nextInt();
    m = in.nextInt();
    size = n;
    
    // 堆添加操作：在尾部添加元素，然后up
    for (int i = 1; i <= n; i++) {
        heap[i] = in.nextInt();
        up(i);
    }

	// 堆删除操作：用尾元素覆盖头元素，然后down
    for (int i = 1; i <= m; i++) {
        System.out.print(heap[1] + " ");
        heap[1] = heap[size--];
        down(1);
    }
}
```

## 哈希

> 离散化是一种非常特殊的哈希。

什么时候用哈希？当需要将繁多的数据映射为精简的数据时。

哈希的核心是哈希函数 `hash(x)`，它根据 x 返回一个哈希值 h。h 就是 x 在散列表中的的存储位置，可能还需要再处理一下，比如取模。可能有不同的元素映射到相同的位置，这就是哈希冲突。有两种方式解决哈希冲突：

* 拉链法：使用链表存储哈希值相同的元素。*Java* 的 `HashMap` 便是如此。
* 随机寻址法：如果发生哈希冲突，则进行二次哈希寻找下一个位置。

**问题：模拟散列表**

维护一个集合，支持如下几种操作：

1. `I x`，插入一个数 x；
2. `Q x`，询问数 x 是否在集合中出现过；

现在要进行 N 次操作，对于每个询问操作输出对应的结果。

**代码（拉链法）：**

```
static int N = 100010;
static int[] h = new int[N], e = new int[N], ne = new int[N];
static int idx = 0;

// 插入元素
static void insert(int x) {
    int p = hash(x);
    e[idx] = x;
    ne[idx] = h[p]; // 头插法
    h[p] = idx++;
}

// 查询元素
static boolean query(int x) {
    int p = hash(x);
    for (int i = h[p]; i != -1; i = ne[i]) {
        if (e[i] == x) return true;
    }
    return false;
}

// 返回哈希值
static int hash(int x) {
    return (x % N + N) % N; // 消除负数
}
```

## 字符串哈希：判断相同子串

全称字符串前缀哈希，把字符串变成一个 P 进制数字（哈希值），实现不同的字符串映射到不同的数字。经验值为 131，13331。哈希值通常还要取模，模的经验值为 *2^64*。使用经验值可以避免大部分冲突。

怎么将只包含字母和数字的字符串映射为 P 进制的数呢？

*"abc"* 的哈希值等于 `a*P^2 + b*P^1 + c*P^0`，越靠左的字符，位越高。`hash[i]` 表示前缀 `[0,i]` 的哈希值。对于 `[i,j]` 子串，它的哈希值等于 `hash[j] - hash[i-1] * P^j-i+1`。这样就能得到一个字符串的任意子串的哈希值，根据哈希值可以判断两个子串是否相等。

哈希值不能映射为 0。如果 *"a"* 的哈希值为 0，那么 *"aaa"* 的哈希值也为 0。

**问题：字符串哈希**

给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 *l1 r1 l2 r2*，请你判断 *[l1,r1]* 和 *[l2,r2]* 这两个区间所包含的字符串子串是否相同。

字符串中只包含大小写英文字母和数字。

**代码：**

```
static int N = 100010, P = 131; // P进制
static long[] h = new long[N]; // 字符串哈希值
static long[] p = new long[N]; // p[i]=p^i，方便计算
static char[] s;

static long get(int l, int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
}

public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt(), m = in.nextInt();

    String t = " " + in.next(); // 计算哈希值有i-1，所以加一个" "前缀
    s = t.toCharArray();

    // 计算哈希值
    p[0] = 1;
    for (int i = 1; i <= n; i++) {
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + s[i];
    }

    while (m-- > 0) {
        int l1 = in.nextInt(), r1 = in.nextInt(), l2 = in.nextInt(), r2 = in.nextInt();
        if (get(l1, r1) == get(l2, r2)) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

## 回文

**问题：最大长度的回文子串**

如果一个字符串正着读和倒着读是一样的，则称它是回文的。给定一个长度为 N 的字符串 S，求他的最长回文子串的长度是多少。

**题解：**

* 字符串哈希，太麻烦，不学也罢。

* 动态规划：https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/

**代码：**

```
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    char[] cs = br.readLine().toCharArray();

    int len = cs.length;
    if (len < 2) {
        System.out.print(1);
        return;
    }
    // 最长回文子串的长度和起始位置
    int maxLen = 1, begin = 0;
    
    // dp[i][j]表示[i,j]子串是否为回文
    boolean[][] dp = new boolean[len][len];
    
    // 初始化所有长度为1的子串都是回文
    for (int i = 0; i < len; i++) {
        dp[i][i] = true;
    }

    // 遍历子串长度
    // 之所以遍历子串长度，而非遍历 i+j，是因为回文串的判段必须根据更短的子串来进行
    for (int l = 2; l <= len; l++) {
        // 遍历左端点
        for (int i = 0; i < len; i++) {
            // 计算右端点
            int j = i + l - 1;
            if (j >= len) {
                break;
            }
            if (cs[i] != cs[j]) {
                dp[i][j] = false;
            } else {
                if (j - i + 1 < 3) {
                    dp[i][j] = true; // 只有两个字符的子串，i、j 相等即回文
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }
            // 更新最长回文子串的长度和起始位置
            if (dp[i][j] && j - i + 1 > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    System.out.print(maxLen);
}
```

# 搜索与图论

## 深度/宽度优先搜索

| 算法 | 数据结构    | 耗费空间         | 性质                               |
| ---- | ----------- | ---------------- | ---------------------------------- |
| DFS  | 栈，Stack   | O(n)             | 结果是任意通路                     |
| BFS  | 队列，Queue | O(2^h)，h 是层数 | 结果是最短路，每次都拓展最近的点。 |

### DFS（Depth First Search）

**算法思想：**

尽可能地沿着当前路径搜索，如果当前点无法继续拓展，则回溯到上一个点，并检查该点是否通往其它未搜索的点，如果可以则进入搜索，没有则继续回溯。*DFS* 搜索相当于在维护一个栈，依次压入当前路径的点。其重点在于：合适的终止条件，回溯时要恢复为之前的状态。

**题目：排列数字**

给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

**代码：**

```
class Main {

    static int N = 10000010;
    static int n;
    static int[] stack = new int[N];
    static boolean[] tag = new boolean[N];

    static void dfs(int c) { // 当前搜索到第c个数，c从0开始
        if (c == n) { // 终止条件
            for (int i = 0; i < n; i++) System.out.print(stack[i] + " ");
            System.out.println();
            return;
        }

        for (int i = 1; i <= n; i++) {
            if (!tag[i]) {
                stack[c] = i;
                tag[i] = true;
                dfs(c + 1); // 继续向后搜索
                tag[i] = false; // 回溯时恢复状态
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        dfs(0);
    }
}
```

***

**题目：N 皇后**

N−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

现在给定整数 n，请你输出所有的满足条件的棋子摆法。

**代码：**

```
public class Main {
    static int n;
    static char[][] map; // 棋盘
    static boolean[] row, dg, udg; // 列，对角线，反对角线

    static void dfs(int c) { // 逐行搜索，当前搜索到第c行
        if (c == n) {
            for (int i = 0; i < n; i++) System.out.println(map[i]);
            System.out.println();
            return;
        }

        for (int i = 0; i < n; i++) {
            if (!row[i] && !dg[c - i + n] && !udg[c + i]) { // 对角线：x=y+z，x=-y+z，使用z映射下标
                map[c][i] = 'Q';
                row[i] = dg[c - i + n] = udg[c + i] = true;
                dfs(c + 1); // 向下搜索
                row[i] = dg[c - i + n] = udg[c + i] = false; // 恢复状态
                map[c][i] = '.';
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        map = new char[n][n];
        row = new boolean[n];
        dg = new boolean[2 * n];
        udg = new boolean[2 * n];
        for (int i = 0; i < n; i++) Arrays.fill(map[i], '.');
        dfs(0);
    }
}
```

### BFS（Breadth First Search）

**算法思想：**

一层一层地向外拓展。将所有点分为已搜索和待搜索两个集合，每一轮搜索都遍历已搜索的点，然后搜索距离这些点最近的待搜索点。

BFS 可用于求无权图的最短路问题。BFS 只能搜索最短路，DFS 能搜索到所有路径。

**题目：走迷宫**

给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 *(1,1)* 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 *(n,m)* 处，至少需要移动多少次。

数据保证 *(1,1)* 处和 *(n,m)* 处的数字为 0，且一定至少存在一条通路。

**代码：**

```
public class Main {

    static int n, m;
    static int[][] map, d; // 图，到源点的距离
    static ArrayDeque<Pair> q = new ArrayDeque<>(); // 队列

    static void bfs() {
        q.offer(new Pair(0, 0));
        d[0][0] = 0;

        int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};
        while (!q.isEmpty()) {
            Pair t = q.poll();
            for (int i = 0; i < 4; i++) {
                int x = t.x + dx[i], y = t.y + dy[i];
                if (x >= 0 && x < n && y >= 0 && y < m && map[x][y] != 1 && d[x][y] == -1) {
                    d[x][y] = d[t.x][t.y] + 1;
                    q.offer(new Pair(x, y));
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt(); m = in.nextInt(); map = new int[n][m]; d = new int[n][m];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                map[i][j] = in.nextInt(); d[i][j] = -1; }
        bfs();
        System.out.print(d[n - 1][m - 1]);
    }
}

class Pair {
    int x, y;
    Pair(int x, int y) { this.x = x; this.y = y; }
}
```

***

**题目：八数码**

在一个 3×3 的网格中，1∼8 这 8 个数字和一个 x 恰好不重不漏地分布在 3×3 的网格中。例如：

```
1 2 3
x 4 6
7 5 8
```

在游戏过程中，可以把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

```
1 2 3
4 5 6
7 8 x
```

现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

**题解：**

使用字符串模拟表格状态。用哈希表存储各种状态	和这种状态最少需要的调整次数。

**代码：**

```
public class Main {

    static ArrayDeque<String> q = new ArrayDeque<>(); // 队列
    static HashMap<String, Integer> map = new HashMap<>(9); //状态和步数
    static String end = "12345678x"; // 终止状态

    static int bfs(String s) {
        q.offer(s);
        map.put(s, 0);

        int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};
        while (!q.isEmpty()) {
            String t = q.poll();
            int st = map.get(t); // 步数
            if (end.equals(t)) return st;

            int k = t.indexOf('x');
            int kx = k / 3, ky = k % 3;
            for (int i = 0; i < 4; i++) {
                int x = kx + dx[i], y = ky + dy[i];
                if (x >= 0 && x < 3 && y >= 0 && y < 3) {
                    t = swap(t, k, x * 3 + y);
                    if (map.get(t) == null) {
                        map.put(t, st + 1);
                        q.offer(t);
                    }
                    t = swap(t, k, x * 3 + y);
                }
            }
        }

        return -1;
    }

    static String swap(String s, int i, int j) { // 使用StringBuilder构建字符串
        StringBuilder b = new StringBuilder(s);
        b.setCharAt(i, s.charAt(j));
        b.setCharAt(j, s.charAt(i));
        return b.toString();
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String s = "";
        for (String c : in.nextLine().split(" ")) s += c;
        System.out.print(bfs(s));
    }
}
```

## 图和树的存储和遍历

树相当于无环连通图，所以只学习图。图分为有向图和无向图。无向图可以看作特殊的有向图，无向图的 `a-b` 等于有向图的 `a->b` + `a<-b`。

**有向图的存储：**

* 邻接矩阵，`g[a,b]` 存储 a 到 b 的信息，这种方式无法存储重边；
* 邻接表（链表数组），每个链表存一个点的所有出点，链表结点的先后顺序没有意义。

**模板（图的深度优先遍历）：**

```
int dfs(int u) {
    tag[u] = true; // tag[u]表示点u已被搜索过
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

**模板（图的宽度优先遍历）：**

```
void bfs() {
	ArrayDeque<Integer> q;    
    st[1] = true; // 表示1号点已经被遍历过
    q.offer(1);

    while (!q.isEmpty) {
        int t = q.poll();
        for (int i = h[t]; i != -1; i = ne[i]) { // 遍历所有邻点
            int j = e[i];
            if (!st[j]) {
                st[j] = true;
                q.push(j);
            }
        }
    }
}
```

## 拓扑排序

> 什么是拓扑序列？
>
> 若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。

**问题：有向图的拓扑序列**

给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。

**题解：**

有向无环图一定存在拓扑序列，存在自环的图不可能存在拓扑序列。

维护一个序列。

首先选择一个入度为 0 的点加入序列，如果不存在这样的点，说明这个图不存在拓扑序列。

然后循环处理，每次将序列中的点到外面点的出边删除，再从序列外的点中选择入度为 0 的点加入序列。

因为是求任意的拓扑序列，*BFS* 和 *DFS* 都可以使用。

**代码：**

```
public class Main {

    static int N = 100010, M = 2 * N, idx = 0, size = 0, n, m;
    static int[] h = new int[N], e = new int[M], ne = new int[M], d = new int[N]; // d表示入度
    static int[] ans = new int[N];
    static ArrayDeque<Integer> q = new ArrayDeque<>();

    static void bfs() {
    	// 先添加所有入度0的点
        for (int i = 1; i <= n; i++) if (d[i] == 0) q.offer(i);
        // 遍历序列的点，同时添加新的入度为 0 的点
        while (!q.isEmpty()) {
            int t = q.poll();
            ans[size++] = t;
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                d[j] -= 1;
                if (d[j] == 0) q.offer(j);
            }
        }
    }

    static void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        Arrays.fill(h, -1);
        for (int i = 0; i < m; i++) {
            int a = in.nextInt(), b = in.nextInt();
            add(a, b);
            d[b]++;
        }
        bfs();
        if (size == n)
            for (int i = 0; i < n; i++) System.out.print(ans[i] + " ");
        else
            System.out.print("-1");
    }
}
```

## 最短路问题

最短路问题的难点往往是建图，而不是模板的使用。

```
// n：结点数量；m：边数

|-- 单源最短路
	|-- 正权边
    	|-- 朴素 Dijkstra，O(n^2)
        |-- 堆优化 Dijkstra，O(mlog(n))
    |-- 存在负权边
    	|-- Bellman-Ford，O(mn)
        |-- SPFA，通常是 O(n)，最坏时 O(mn)
|-- 多源汇最短路
	|-- Floyd，O(n^3)
```

### 朴素 Dijkstra：正边，稠密图

> *Dijkstra 迪杰斯特拉*。

询问单个源点到其它点的最短距离，复杂度为 *O(n^2)*。

**算法思想：**

这是一种贪心的思想，每次都选择距离最小的一条边，它和求最小生成树的 Prim 算法在思想、结构上非常相像。

```
将所有点分为两个集合：已确定最短距离S、其它R，可以使用一个数组d记录各点到源点的距离

初始时源点到自己的距离为0，其它点到源点的距离为无穷大

遍历R中的点（这里其实是遍历与S邻近的点）：
	选择距离S最近的点t
    将点t从R移动到S
    用点t更新R其它点到S的距离

最后数组d的数据就是各点到源点的最短距离
```

*Dijkstra* 不适用于包含负权边的图，这是因为在上面的循环中，每次都是求距离最小的、邻近 S 的、R 中的点。如果包含负权边，那么很有可能发生已经确定最短距离的点，可以通过另一条负权边获得更短的路径，但 S 中点的距离又是不能更新的。

**模板：**

```
static int INF = 0x3f3f3f3f, N = 510, n, m;
static int[][] map = new int[N][N]; // 图
static int[] d = new int[N]; // 所有点到源点的距离
static boolean[] tag = new boolean[N]; // 标记是否确定距离

static void dijkstra() {
    // 初始化
    Arrays.fill(d, INF);
    d[1] = 0;

    for (int i = 1; i <= n; i++) {
        int t = -1;
        // 选择距离最小的未确定距离的点
        for (int j = 1; j <= n; j++) {
            if (!tag[j] && (t == -1 || d[j] < d[t]))
                t = j;
        }
        // 更新其它点的距离
        tag[t] = true;
        for (int j = 1; j <= n; j++) {
            d[j] = Math.min(d[j], d[t] + map[t][j]);
        }
    }
}

public static void main(String[] args) {
    ...
    // 读图
    for (int i = 0; i < n; i++) Arrays.fill(map[i], INF);
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        map[a][b] = Math.min(map[a][b], c); // 只存距离最小的边
    }
    dijkstra();
    // 点n可能与源点不连通
    if (d[n] != INF) System.out.print(d[n]);
    else System.out.print(-1);
}
```

### 堆优化 Dijkstra：正边，稀疏图

询问单个源点到其它点的最短距离，复杂度为 *O(mlogn)*。适合边较少的稀疏图。

**分析朴素 Dijkstra 的模板：**

观察 *Dijkstra* 的模板，其主要操作在循环体内：

* 遍历R的所有点，循环n次
  * 每次都要遍历 R 来寻找距离 S 最近的点 t，时间复杂度为 *O(n)*
  * 然后，使用点 t 更新 R 中的点到 S 的距离，总的计算量为 m，相当于遍历所有边

所以朴素 *Dijkstra* 的时间复杂度为 *O(n^2  + m)*。

又因为边数 m 受限于点数：*m < = n^2*，所以复杂度可化为：*O(n^2)*。此时，复杂度与边数无关，所以朴素的 *Dijkstra* 适合计算边数较多的稠密图。

**堆优化算法思想：**

朴素 *Dijkstra* 每次从 R 中找出距离 S 最近的点，计算量为 *n*。如果使用小根堆存储 R 中点到 S 的距离，那么求最近点的计算量将降为 1。但堆更新数据的复杂度为 *log(n)*，这会使第二步的更新距离的总计算量升为 *mlog(n)*。所以，堆优化 *Dijkstra* 的复杂度为：*O(n+n+mlogn) = O(mlogn)*。它的复杂度与边数有关，所以堆优化版本适合计算边数较少的稀疏图。

稀疏图和稠密图都是点数和边数的相对说法。有时候点数非常多，导致边数虽然也很多，但远远小于 *n^2*，那么这就是一个稀疏图。这时如果还使用朴素 *Dijkstra* 计算，很可能会超时。

**模板：**

```
static int INF = 0x3f3f3f3f, N = 150010, idx = 0, n, m;
static int[] h = new int[N], e = new int[N], ne = new int[N], w = new int[N];
static int[] d = new int[N];
static boolean[] tag = new boolean[N];
// 使用小根堆存R集点的距离，使用数组 [结点,距离] 表示结点编号和距离
static PriorityQueue<int[]> q =
        new PriorityQueue<>((a, b) -> {return a[1] - b[1];});

static void dijkstra() {
    // 初始化
    Arrays.fill(d, INF);
    d[1] = 0;
    q.offer(new int[]{1, 0});

    while (!q.isEmpty()) {
        int[] arr = q.poll(); // R中距离最小的点
        int t = arr[0], dt = arr[1]; // 获取编号和距离
        if (!tag[t]) {
            tag[t] = true; // 将t加入S
            // 更新距离
            for (int i = h[t]; i != -1; i = ne[i]) {
                int j = e[i];
                if (d[j] > dt + w[i]) {
                    d[j] = dt + w[i];
                    q.offer(new int[]{j, d[j]});
                }
            }
        }
    }
}

static void add(int a, int b, int c) {
    e[idx] = b; ne[idx] = h[a]; w[idx] = c; h[a] = idx++;
}

public static void main(String[] args) {
    ...
    Arrays.fill(h, -1);
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        add(a, b, c);
    }
    dijkstra();
    // 点n可能与源点不连通
    if (d[n] != INF) System.out.print(d[n]);
    else System.out.print(-1);
}
```

### Bellman-Ford：负边，不能有负环

> *Bellman-Ford* 贝尔曼-福特

询问单个源点到其它点的最短距离，复杂度为 *O(nm)*。图可以含有负权边，但如果有负回路，计算的最短距离可能是负无穷。

**算法思想：**

```
使用数组d记录各点到源点的距离

初始化源点到自己的距离为0，其它点的距离为无穷大

循环k次：
	遍历所有边(a,b,w)：
		d[b] = min(d[b], d[a]+w)
```

循环 k 次后，d[i] 表示从源点到 i 点的不超过 k 条边的最短路径长度。所以，此算法可用于求解 “不超过 n 条边的最短距离”。

此算法还能判断图是否有负环，如果可以计算出有 n 条边的最短路径，说明这条路径一定含有负环，因为总共只有 n 个点，而 n 条边连接了 n+1 个点，有两个点重合，然而这条路径的长度居然比 n-1 条边要短，说明路径中存在负环。不过更多时候是使用 *SPFA* 算法来判断负环。

*Bellman-Ford* 只是简单的遍历所有边，所以这里只需要储存 (a,b,w) 信息即可。

**模板：**

```
static int INF = 0x3f3f3f3f, N = 510, M = 10010, idx = 0, n, m;
static int[][] side = new int[M][3]; // side[a][b][c]表示点a到点b的距离为c
static int[] d = new int[N], copy;

// 计算源点到各点的不超过k条边的最短距离
static void bellmanFord(int k) {
    // 初始化
    Arrays.fill(d, INF);
    d[1] = 0;
    for (int i = 0; i < k; i++) {
        copy = Arrays.copyOf(d, d.length); //备份，避免循环中使用刚更新的数据
        for (int j = 0; j < m; j++) {
            int a = side[j][0], b = side[j][1], w = side[j][2];
            d[b] = Math.min(d[b], copy[a] + w);
        }
    }
}

public static void main(String[] args) {
    ...
    // 读边
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        side[idx++] = new int[]{a, b, c};
    }
    bellmanFord(k);
    // 
    if (d[n] < INF / 2) System.out.print(d[n]);
    else System.out.print("impossible");
}
```

此时不能再用 *!=INF* 判断 d[n] 是否存在，因为如果两个无穷点之间存在负边，`Math.min(d[b], copy[a] + w)` 会更新距离。此时，这个与源点不连通的无穷点的距离会小于 INF。

### SPFA：负边，不能有负环，判断负环，对 Bellman-Ford 的优化

询问单个源点到其它点的最短距离，复杂度通常为 *O(n)*，最差为 *O(nm)*。图可以含有负权边，但如果有负回路，计算的最短距离可能是负无穷。

**算法思想：**

*SPFA* 是对 *Bellman-Ford* 的优化。*Bellman-Ford* 的语句 `dist[b] = min(dist[b], dist[a]+w)` 并不总是会修改 `dist[b]`，只有当 `dist[a]` 变小时，它才有可能更新。而 *SPFA* 只在点 a 的距离变小时，才会使用它尝试更新其它点的距离。模板的做法是把距离变小的点放入队列，然后只使用队列中的点更新距离。

```
使用数组d记录各点到源点的距离。

初始化源点到自己的距离为0，其它点的距离为无穷大

将源点加入队列

while(队列不空){
	t = 弹出队头
	遍历t点的所有出边{
		if(dist[i] > dist[t]+w[t,i]{
        	更新 dist[i]
			if (i点不在队列内) { 将i点入队 }
		}
	}
}
```

**模板：**

```
static int INF = 0x3f3f3f3f, N = 100010, idx = 0, n, m;
static int[] h = new int[N], e = new int[N], ne = new int[N], w = new int[N], d = new int[N];
static boolean[] tag = new boolean[N];
static ArrayDeque<Integer> q = new ArrayDeque<>();

static void spfa() {
    Arrays.fill(d, INF);
    d[1] = 0;
    q.offer(1);
    tag[1] = true;

    while (!q.isEmpty()) {
        int t = q.poll();
        tag[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[j] > d[t] + w[i]) {
                d[j] = d[t] + w[i];
                if (!tag[j]) {
                    q.offer(j);
                    tag[j] = true;
                }
            }
        }
    }
}

static void add(int a, int b, int c) {
    e[idx] = b; ne[idx] = h[a]; w[idx] = c; h[a] = idx++;
}

public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    n = in.nextInt();
    m = in.nextInt();
    Arrays.fill(h, -1);
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        add(a, b, c);
    }
    spfa();
    if (d[n] != INF) System.out.print(d[n]);
    else System.out.print("impossible");
}
```

这里可以使用 *!=INF* 判断，因为只有与队列中的点相连的点，才有可能被更新。初始化时将源点加入队列，所以队列中的点都是与源点连通的。那种存在负边的无穷点永远不可能被更新。

**SPFA 与 Bellman-Ford 的区别**

*Bellman-Ford* 算法的模板中，有一个需要自定义的 k 值，它使得计算的结果是从源点到其它点的不超过 k 条边的最短距离。

而 *SPFA* 算法没有边数的限制，它会不断寻找最短的路径，如果源点到某点之间的最短路径存在负环，程序在遇到这个负环点时会陷入死循环。当然，也可以限制不计算连接到自己的边，这样就会跳过负环。

#### 判断负环

基于 *SPFA* 求负环的常用方法：

* 统计每个点入队的次数，如果某个点入队 n 次，则说明存在负环。
* 统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于 n，则说明存在负环。

**模板：**

此模板使用第二种方法判断负环。增加一个数组 `cnt`，记录源点到各点的最短距离所经过的边数。循环内每次更新 `dist[i]` 都要进行相应的 `cnt[i]++` 操作。

此外，这里的 `spfa` 方法没有对 `d` 数组的初始化。可以这样理解：如果要判断全图是否存在负环，需要依次将每个点作为源点来进行 `spfa` 计算，但这样做的复杂度太高。不如假设一个虚拟的点，该点与全图的每个点都有一条权值为 0 的出边连接。如果原图存在负环，那么新图也会存在负环。此时在新图上做 `spfa` 计算，一次循环后，所有的点会加入队列，它们到源点的距离都更新为 0。此时，新图的状态就是模板的初始状态。

```
static int INF = 0x3f3f3f3f, N = 2010, M = 10010, idx = 0, n, m;
static int[] h = new int[N], e = new int[M], ne = new int[M], w = new int[M], cnt = new int[N], d = new int[N];
static boolean[] tag = new boolean[N];
static ArrayDeque<Integer> q = new ArrayDeque<>();

static boolean spfa() {
    // 将所有点加入队列，考虑可能存在不连通的块
    for (int i = 1; i <= n; i++) {
        q.offer(i);
        tag[i] = true;
    }
    while (!q.isEmpty()) {
        int t = q.poll();
        tag[t] = false;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[j] > d[t] + w[i]) { // 此时，初始化d[i]=0，只有存在负边，负环才会更新
                d[j] = d[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!tag[j]) {
                    q.offer(j);
                    tag[j] = true;
                }
            }
        }
    }
    return false;
}

static void add(int a, int b, int c) {
    e[idx] = b; ne[idx] = h[a]; w[idx] = c; h[a] = idx++;
}

public static void main(String[] args) {
    ...
    Arrays.fill(h, -1);
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        add(a, b, c);
    }
    if (spfa()) System.out.print("Yes");
    else System.out.print("No");
}
```

### Floyd：多源汇，不能有负环

询问多个源点到其它点的最短距离，复杂度为 *O(n^3)*。图可以含有负权边，但如果有负回路，计算的最短距离可能是负无穷。

**算法思想：**

```
使用邻接矩阵d储存图

三重循环
	for k in n
    	for i in n
        	for j in n{
            	d[i,j] = min(d[i,j], d[i,k]+d[k,j])
            }

最后d[i,j]表示从i到j的最短距离
```

**模板：**

```
static int INF = 0x3f3f3f3f, N = 210, n, m, k;
static int[][] d = new int[N][N];

// 计算任意点到其它点的最短距离
static void floyd() {
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);
}
```

## 最小生成树

最小生成树问题通常是无向图。

> **什么是最小生成树？**
>
> 给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。
>
> 由 V 中的全部点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。

### 朴素 Prim：稠密图

复杂度为 *O(n^2)*，不依赖于边，所以它适合计算稠密图。

**算法思想**

与 *Dijkstra* 的算法思想非常相似。

```
将图的所有点分为两个集合：表示最生成树的S、其它R。初始时所有点都属于R
可以使用一个数组d记录R中各点到S的距离

从R中任取一点，作为S的第一个点
遍历R中的点：
	从R中找到离S点集最近的点t，将这个点和相应的边加入S，S的点数+1
	使用新加入的点t更新R中的点到S的距离
	直到所有点都加入S，此时S中包含n-1条边
```

**模板：**

```
static int INF = 0x3f3f3f3f, N = 510, n, m, ans;
static int[] d = new int[N];
static int[][] map = new int[N][N];
static boolean[] tag = new boolean[N];

static void prim() {
    Arrays.fill(d, INF);
    ans = 0;
    for (int i = 0; i < n; i++) {
        // 选出距离S集最近的点
        int t = -1;
        for (int j = 1; j <= n; j++)
            if (!tag[j] && (t == -1 || d[t] > d[j]))
                t = j;
        // 如果最近的点距离都是正无穷，表示这个点不连通，无法生成树
        if (i != 0 && d[t] == INF) { // i!=0 用于排除第一个点
            ans = -INF;
            return;
        }
        tag[t] = true;
        if (i != 0) ans += d[t];
        // 更新距离
        for (int j = 1; j <= n; j++) {
            d[j] = Math.min(d[j], map[t][j]);
        }
    }
}

public static void main(String[] args) {
    ...
    for (int i = 1; i <= n; i++) {
        Arrays.fill(map[i], INF);
        map[i][i] = 0;
    }
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        map[a][b] = map[b][a] = Math.min(map[a][b], c);
    }
    prim();
    if (ans == INF) System.out.print("impossible");
    else System.out.print(ans);
}
```

**堆优化 Prim**

适用于稀疏图，复杂度为 *O(nlogm)*。不常用，因为对于稀疏图有更好的 *Kruskal* 算法，而且使用堆有点麻烦。

它的优化思想与 *Dijkstra* 堆优化完全一样：使用小根堆存储各点到 S 的最短距离，使得获取最近点的复杂度降为 *O(1)*。当然，更新距离的复杂度也会升为 *log(n)*。

### Kruskal：稀疏图

适用于稀疏图，复杂度为 *O(mlogn)*。

**算法思想**

与 Prime 从点拓展最小生成树的思想不同，Kruskal 是一种按权值的递增次序选择合适的边来构造最小生成树的方法。

Kruskal 使用贪心的思想，尽可能地使用小权边构造生成树。

```
默认生成树已经包含所有的点，它初始时由n个连通分量构成，现在我们需要确定边集，将所有点连在一起

将所有边根据权值按升序排列，可以使用小根堆实现

从小到大遍历每条边：
	如果这条边的两个端点在树内还不连通，即属于不同的连通分量，则将这条边加入生成树
```

**模板：**

实现中，可以使用并查集的思想，判断两个点是否属于同一个连通分量。

```
static int N = 100010, n, m, ans, cnt;
static int[] p = new int[N]; // p[i]表示i点属于哪个连通块，所有点属于同一个连通块，表示成功构建生成树
static PriorityQueue<int[]> q 
	= new PriorityQueue<>((a, b) -> {return a[2] - b[2];}); // 使用[a, b, w]存边

static void kruskal() {
    ans = 0; // 生成树权值和
    cnt = 0; // 生成树结点数量
    while (!q.isEmpty()) {
        int[] t = q.poll();
        int a = t[0], b = t[1], c = t[2];
        int fa = find(a), fb = find(b);
        if (fa != fb) { // a 和 b 不连通
            p[fa] = fb;
            ans += c;
            cnt++;
        }
    }
}

static int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

public static void main(String[] args) {
    ...
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
        q.offer(new int[]{a, b, c});
    }
    for (int i = 1; i <= n; i++) p[i] = i; // 初始时没有边，各点自成一个连通块
    kruskal();
    if (cnt != n - 1) System.out.print("impossible");
    else System.out.print(ans);
}
```

## 二分图

> **什么是二分图？**
>
> 如果图的所有点可以分成两个集合，所有边的两个端点都不属于同一个集合，这个图就是二分图。

### 染色法：判断二分图

根据二分图定理判断是否为二分图，复杂度为 *O(m+n)*。

> **二分图定理：**当且仅当图中不含有奇数环，这是一个二分图。

**算法思想：**

```
遍历所有点，将其染色为 1 或 2
	for i in n
		if i 未染色
   			将其染色，并使用 dfs 或 bfs 将其领点染为其它颜色

如果某个点已经被染色，而它的邻点与它同色，则发生矛盾，说明这个图不是二分图
```

**模板：**

```
static int N = 200010, idx = 0, n, m;
static int[] h = new int[N], e = new int[N], ne = new int[N], tag = new int[N]; // tag标记颜色，1或2

// 将x点染为c色，并遍历它的邻点
    static boolean dfs(int x, int c) {
        tag[x] = c;
        for (int i = h[x]; i != -1; i = ne[i]) {
            int j = e[i];
            if (tag[j] == 0)
                if (!dfs(j, 3 - c)) return false;
            if (tag[j] == c)
                return false;
        }
        return true;
    }

static void add(int a, int b) {
        e[idx] = b; ne[idx] = h[a]; h[a] = idx++;
}

public static void main(String[] args) {
    ...
    Arrays.fill(h, -1);
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt();
        add(a, b);
        add(b, a);
    }
    // 不想开队列，所以用dfs
    boolean succeed = true;
    for (int i = 1; i <= n; i++)
        if (tag[i] == 0)
            if (!dfs(i, 1)) {
                succeed = false;
                break;
            }
    if (succeed)
        System.out.print("Yes");
    else
        System.out.print("No");
}
```

### 匈牙利算法：求最大匹配数

求二分图的最大匹配数量，复杂度为 *O(mn)*，但实际远小于理论值。

需要使用并查集。

> 二分图匹配：给定一个二分图 G，在 G 的子图 M 中，M 的边集 E 中的任意两条边都不依附于同一个点，则称 M 是一个匹配。也就是说，一个点最多被一条边连接。
>
> 二分图的最大匹配：边数最多的匹配，其边数就是最大匹配数。

**算法思想：**

```
已知二分图两边的点集 s1，s2

遍历 s1 的所有点
	for t in s1
		for i in t的邻点
            if i未连接其它点
                连接 t-i
            else i已经连接j点
                for z in j的领点
                    尝试让j点重新连接z点
                        成功，连接 t-i
                        失败，放弃 i 点
```

**模板：**

```
static int N = 510, M = 100010, n1, n2, m, idx = 0, ans = 0;
static int[] h = new int[N], e = new int[M], ne = new int[M], match = new int[N];
match[i] = s1的点i匹配的点编号
static boolean[] tag = new boolean[N]; // 标记已经考虑过的点

// 尝试让x点连接某个邻点
static boolean link(int x) {
    for (int i = h[x]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!tag[j]) {
            tag[j] = true;
            if (match[j] == 0 || link(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

static void add(int a, int b) {
    e[idx] = b; ne[idx] = h[a]; h[a] = idx++;
}

public static void main(String[] args) {
    ...
    Arrays.fill(h, -1);
    for (int i = 0; i < m; i++) {
        int a = in.nextInt(), b = in.nextInt();
        add(a, b); // 只存s1到s2的出边
    }
    // 依次尝试让s1的点匹配s2的点
    for (int i = 1; i <= n1; i++) { // 遍历s1
        Arrays.fill(tag, false);
        if (link(i)) ans++;
    }
    System.out.print(ans);
}
```

# 动态规划（Dynamic Programming，DP）

DP 问题没有固定的代码模板，但 *ACWing* 总结有：**DP 问题经验理解方式：**

从两方面思考 DP 问题：

* 状态表示（集合的角度）：需要多少维（未知量）表示问题的答案。

  * 一个状态表示什么集合。
  * 状态的属性：最大值，最小值，数量等。就是问题的答案。

* 状态计算：将一个状态集合划分为若干个子集，使得当前子集可以通过前面已知的子集推导出来。

  划分原则：不重不漏，不一定非要满足，比如求最大值就不需要满足“不重”。

DP 问题的时间复杂度通常 = 状态数量 * 状态计算量。

## 背包问题

### 0 1 背包

**特点：**每件物品只能选择一次。

**问题：01背包问题**

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**题解：**

* 状态表示：`f[i,j]`，使用两个变量表示状态，物品种类和体积上限。

  * 集合：从前 i 个物品选择，总体积不超过 j 的所有选择方案。
  * 属性：集合中最大价值方案的价值，即最大值。

* 问题答案为 `f[N,V]`。

* 状态计算：划分 `f[i,j]`

  根据是否选第 i 件物品，将 `f[i,j]` 表示的集合划分为两个子集：

  * 不选择 i 物品，那么 `f[i,j] = f[i-1,V]`，`f[i-1,V]` 是前面已知的子集。

  * 选择 i 物品，尝试利用前面已知的状态进行计算：

    所有元素同时加减一个相同的数，不改变这些数的相对大小。所以对于 `f[i,j]`，可以预先选择物品 i，然后忽略 i 物品的价值和体积，转而求 `f[i-1,V-vi]` 的最大值，最后用这个值加回 i 物品的价值，其结果就是选择第 i 个物品且总体积不超过 j 的最大价值。

  状态转移方程：`f[i,j] = max(f[i-1,j], f[i-1,j-vi] + wi)`。

  为什么叫状态转移方程？根据上面的解题思想，`f[i,j]` 其实是由 `f[i-1][j]`、`f[i-1,j-vi]` 推导过来的，可以说当前的状态是由前面已知状态转移过来的。

**代码（朴素）**

```
static int M = 1010, N, V;
static int[] v = new int[M], w = new int[M];
static int[][] f = new int[M][M];

// 状态计算。i=0时不能选择任何物品，最大值只能为0，其它所有状态都基于这个初始状态演变而来
for (int i = 1; i <= N; i++)
    for (int j = 0; j <= V; j++) {
        f[i][j] = f[i - 1][j];
        if (j >= v[i]) // 只有体积上限大于vi时，才能预先选择i
            f[i][j] = Math.max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }
```

**代码（优化）：**

观察朴素模板，循环内 `f[i]` 层的更新只用到 `f[i-1]` 层数据，可以使用滚动数组。

而对于 `j`，`f[i,j]` 的计算只用到 `f[i-1,j-v[i]]`，可以继续优化为一维数组：

```
for (int i = 1; i <= N; i++)
    for (int j = V; j >= v[i]; j--)
        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
```

模板中第二个循环让 j 从后往前遍历，是因为 `j-v[i] <= j`。如果从小到大遍历 j，`f[i-1,j-v[i]]` 会先于 `f[j]` 计算，那么计算 `f[j]` 时使用的 `f[j - v[i]]` 就是第 `i` 层的数据，而非上一层 `i-1` 层的数据。优化不能改变朴素模板的原始逻辑。

### 完全背包

**特点：**每件物品可以选择无限次。

**问题：完全背包问题**

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**题解：**

* 状态表示：`f[i,j]`

  * 集合：从前 i 个物品选择，总体积不超过 j 的所有选择方案。
  * 属性：集合中最大价值方案的价值。

* 状态计算：

  根据物品 i 的选择个数，将 `f[i,j]` 划分为若干个子集。

  如果物品 i 一次都不选，`f[i,j] = f[i-1,j]`。
  
  状态转移方程：`f[i,j] = max(f[i-1,j-k*vi] + k*wi), k=0,1,2,...`。

**代码（朴素）：**

```
for (int i = 1; i <= N; i++)
    for (int j = 0; j <= V; j++)
        for (int k = 0; k * v[i] <= j; k++) // k表示物品i选择的次数
            f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
```

**代码（优化）**

比较 `f[i,j]` 与 `f[i,j-v]` 的计算式：

```
f[i,j]   = max(f[i-1][j]), f[i][j-v]+w, f[i][j-2v]+2w, f[i][j-3v]+3w, ...)

f[i,j-v] = max(            f[i-1][j-v], f[i-1][j-2v]+w, f[i-1][j-3v]+2w, ...)
```

可以发现重合部分，据此简化 `f[i,j]` 的计算：

```
f[i,j] = max(f[i-1,j], f[i,j-vi]+w)
```

朴素代码便可以优化为：

```
for (int i = 1; i <= N; i++)
    for (int j = 0; j <= V; j++) {
        f[i][j] = f[i - 1][j];
        if (j >= v[i]) f[i][j] = Math.max(f[i][j], f[i][j - v[i]] + w[i]);
    }
```

继续优化为一维数组，`f[i,j] = max(f[i-1,j], f[i,j-vi]+w)` 使用同一层数据，可以从小到大遍历：

```
for (int i = 1; i <= N; i++)
    for (int j = v[i]; j <= V; j++)
        f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
```

### 多重背包

**特点：**每件物品的选择次数有限。

**问题：多重背包问题**

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

**题解：**

* 状态表示：`f[i,j]`

  * 集合：从前 i 个物品选择，总体积不超过 j 的所有选择方案。
  * 属性：集合中最大价值方案的价值。

* 状态计算：

  它的集合划分与完全背包相同，只不过这里有各个物品的选择次数上限。

  根据第 i 个物品选择的次数 `0~si`，将 `f[i,j]` 划分为 `si` 个子集。
  
  状态转移方程：`f[i,j] = max(f[i-1,j-k*vi] + k*wi) k=0,1,2,...,si`。

**代码（朴素）：**

与完全背包模板相比，k 多了层 `s[i]` 的限制。

```
for (int i = 1; i <= N; i++)
    for (int j = 0; j <= V; j++)
        for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
            f[i][j] = Math.max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
```

**代码（优化）：**

虽然多重背包的朴素模板与完全背包非常相似，但它无法使用完全背包那样的优化方式。比较多重背包 `f[i,j]` 和 `f[i,j-v]` 的计算式：

```
f[i,j] =   max(f[i-1,j]), f[i-1,j-v]+w, f[i-1,j-2v]+2w, ..., f[i-1,j-sv]+sw)

f[i,j-v] = max(f[i-1,j-v], f[i-1,j-2v]+w, ..., f[i-1,j-sv]+(s-1)w, f[i-1,j-(s+1)v]+sw)
```

发现，这里的重合比完全背包的情况还多了一项 `f[i-1,j-(s+1)v]+sw)`，此时就无法将 `f[i,j-v]` 的值用于计算 `f[i,j]`。

现在选择使用**二进制优化**。将物品 i 的 si 种选择方案，转化为 *logs(si)* 件新物品。这里先不考虑 0 次。

> 什么是二进制优化？
>
> 如果需要 *0~200* 的某些数字，不一定非要枚举所有。可以将 200 拆分为多个 2 的整数次幂：*2^0，2^1，2^2，...，2^k*。这 k 个数字之和 *sum* 等于 200。如果 *sum* 小于 200，但再加上 *2^(k+1)* 又大于 200 时，就补充一个数 c，使得 *sum + c = 200*。这 *k(+1)* 个数字可以组合求和得到 0~200 的任意数字，每个数最多选择一次。

假如物品 i 有 200 件。那么就创建 k 件新物品，分别表示 2^0，2^1，2^2，...，2^k（，c）。这样，物品 i 的 si 种选择方案就转化为 k（+1） 件新物品的 01 背包问题。如果要选择 5 次物品 i，那么就在 01 背包中选择 *2^0* 和  *2^2* 物品各一次。*k = logs(si)*。

```
public class Main {

    // 每件物品都转化为logs(si)件新物品
    static int M = 2010, L = M * (int) Math.log(M) + 10, N, V;
    static int[] v = new int[L], w = new int[L];
    static int[] f = new int[M];

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        N = in.nextInt();
        V = in.nextInt();

        int idx = 0; // 新物品下标
        for (int i = 1; i <= N; i++) {
            int a = in.nextInt(), b = in.nextInt(), c = in.nextInt();
            int k = 1; // 质数从1开始
            while (k <= c) {
                idx++;
                v[idx] = k * a;
                w[idx] = k * b;
                c -= k;
                k *= 2;
            }
            if (c != 0) {
                idx++;
                v[idx] = c * a;
                w[idx] = c * b;
            }
        }
        N = idx; // 转化后共有idx件物品
        // 01 背包优化模板
        for (int i = 1; i <= N; i++)
            for (int j = V; j >= v[i]; j--)
                f[j] = Math.max(f[j], f[j - v[i]] + w[i]);
        System.out.print(f[V]);
    }
}
```

### 分组背包

**特点：**物品分成多个组，每组只能选择 1 件物品。

**问题：分组背包问题**

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

**题解：**

把一组物品看作一件物品，将问题转化为 01 背包问题。

* 状态表示，`f[i,j]`

  * 集合：从前 i 组物品选择，总体积不超过 j 的所有选择方案。
  * 属性：集合中最大价值方案的价值。

* 状态计算：

  根据选择哪个物品，将 `f[i,j]` 划分为 k+1 个子集，k 为第 i 组的物品编号。

  如果一件物品都不选，`f[i,j] = f[i-1,j]`。
  
  状态转移方程：`f[i,j] = max(f[i-1,j-vik] + wik), k = 0, 1, 2, ..., k`。

**代码：**

```
public class Main {

    static int M = 103, N, V;
    static int[][] v = new int[M][M], w = new int[M][M];
    static int[] s = new int[M], f = new int[M];

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        N = in.nextInt();
        V = in.nextInt();
        for (int i = 1; i <= N; i++) {
            s[i] = in.nextInt();
            for (int j = 1; j <= s[i]; j++) {
                v[i][j] = in.nextInt();
                w[i][j] = in.nextInt();
            }
        }

		// 01 背包优化模板，i遍历组，j遍历体积上限，k遍历组内物品
        for (int i = 1; i <= N; i++)
            for (int j = V; j >= 0; j--)
                for (int k = 1; k <= s[i]; k++)
                    if (v[i][k] <= j)
                        f[j] = Math.max(f[j], f[j - v[i][k]] + w[i][k]);

        System.out.print(f[V]);
    }
}
```

## 线性 DP

状态转移方程有明显线性关系的 DP 问题。比如 01 背包问题，它表示的二维状态 `f(i,j)` 都由前一个状态 
`f(i-1,j)` 推导得到。

### 问题：数字三角形

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
		7
	  3   8
	8   1   0
  2   7   4   4
4   5   2   6   5
```

**题解：**

使用二维数组储存数字三角形，每行都从下标 1 开始。

* 状态表示 ：`f[i,j]`
  * 集合：从源点 `(1,1)` 到 `(i,j)` 的所有路径。
  * 属性：最大和。

* 状态计算：

  `(i,j)` 只可能来自其左父结点或右父结点，据此划分 `f[i,j]`。

  左父结点：`f[i,j] = f[i-1,j-1] + a[i,j]`。

  右父结点：`f[i,j] = f[i-1,j] + a[i,j]`。

  状态转移方程：`f[i,j] = max(f[i-1,j-1]，f[i-1,j]) + a[i,j]`。

**代码：**

```
for (int i = 1; i <= n; i++) {
    Arrays.fill(f[i], -INF); // 消除原本不存在左/右父结点
    for (int j = 1; j <= i; j++)
        f[i][j] = Math.max(f[i - 1][j - 1], f[i - 1][j]) + g[i][j];
}
```

### 问题：最长上升子序列

给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

**题解：**

* 状态表示：`f[i]`

  * 集合：所有以第 i 个数字结尾的单调子序列。
  * 属性：最大长度。

* 状态计算：

  `f[i]` 表示的子序列都以第 i 个数字结尾，可以先忽略这个数。根据倒数第二个数字可能是 `null`，`a[1]`，`a[2]`，...，`a[i-1]`，将 `f[i]` 划分为 i 个子集。

  当子序列只有 `a[i]` 一个数时，长度为 1。
  
  状态转移方程：`f[i] = max(f[j]) + 1, j = 0, 1, 2, ..., i-1, a[j] < a[i]`。

**代码：**

```
for (int i = 1; i <= n; i++) {
    f[i] = 1;
    for (int j = 1; j < i; j++)
        if (a[j] < a[i])
            f[i] = Math.max(f[i], f[j] + 1);
}
```

**代码（优化）：**

上面代码的复杂度是 *O(n^2)*，数据量较大时会超时。

朴素代码中，计算 `f[i]` 之前需要先计算 `f[k], k<i`，然后选择结尾数小于 `a[i]` 的最长子序列进行拓展。

如果两个子序列都在 `a[i]` 之前且长度相等，那么应该选择结尾数小的那个。因为结尾数越小，它就越容易被拓展。所以可以忽略结尾数大的子序列，只保留各种长度下，结尾数最小的那个子序列和它的结尾数。而且，随着子序列长度的增加，这些结尾数是严格递增的。

```
public class Main {

    static int INF = 0x3f3f3f3f, N = 100010, n;
    static int[] a = new int[N], q = new int[N]; // q[i]表示长度为i的上升子序列最小的结尾数

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        for (int i = 1; i <= n; i++) a[i] = in.nextInt();

        q[0] = -INF; // 使二分一定能找到比a[i]小的数
        int len = 0; // 最长子序列的长度
        for (int i = 1; i <= n; i++) { // i遍历数列，计算q[i]时，q内保存的都是a[i]之前的子序列
            // 找到结尾数比a[i]小的最长子序列
            int l = 0, r = len;
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (q[mid] < a[i]) l = mid;
                else r = mid - 1;
            }
            len = Math.max(len, l + 1); // l+1=以a[i]结尾的最长子序列长度
            q[l + 1] = a[i]; // l是小于等于a[i]的上边界，所以q[l+1]大于等于a[i]，可以直接赋值
        }

        System.out.print(len);
    }
}
```

二分查找的复杂度为 *log(n)*，所以优化代码的复杂度为 *nlog(n)*。

### 问题：最长公共子序列

给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。

**题解：**

此时是比较两个字符串，状态应该将它们都包含进去。

* 状态表示：`f[i,j]`

  * 集合：所有在字符串 A 前 i 个字符中出现，又在字符串 B 前 j 个字符中出现的子串。
  * 属性：最长子串的长度。

* 状态计算：

  根据公共子串是否以 A 的第 i 个和 B 的第 j 个字符结尾来划分 `f[i,j]`，有 4 种情况：00，10，01，11。

  00 情况，`f[i,j] = f[i-1,j-1]`。

  11 情况，`f[i,j] = f[i-1,j-1] + 1`。

  10，01 两种情况难以精确表示，所以使用 `f[i,j-1]` 和 `f[i-1,j]` 覆盖表示。`f[i,j-1]` 是考虑前 
  `[i, j-1]` 个字符，而 10 表示 A 的子串必须以第 i 个字符结尾，所以 `f[i,j-1]` 表示的集合大于 10。而且 `f[i,j-1]` 和 `f[i-1,j]` 还覆盖了 00 情况，不必再单独考虑 00。
  
  状态转移方程：`f[i,j] = max(f[i,j-1], f[i-1,j], f[i-1,j-1]+1)`。

**代码：**

```
static int N = 1010, n, m, idx = 0;
static char[] a = new char[N], b = new char[N];
static int[][] f = new int[N][N];

for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        f[i][j] = Math.max(f[i][j - 1], f[i - 1][j]);
        if (a[i] == b[j])
            f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);
    }
```

### 问题：编辑距离

给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

1. 删除–将字符串 A 中的某个字符删除。
2. 插入–在字符串 A 的某个位置插入某个字符。
3. 替换–将字符串 A 中的某个字符替换为另一个字符。

现在请你求出，将 A 变为 B 至少需要进行多少次操作。

**题解：**

* 状态表示：`f[i,j]`

  * 集合：所有将 `A[1~i]` 变为 `B[1~j]` 的操作方式。
  * 属性：操作步骤最少的次数。

* 状态计算

  假设现在 `A` 串以字符 `A[i]` 结尾，根据最后一步的操作方式划分 `f[i,j]`：

  1. 删除 `A[i]`，前面操作将 `A[0~i-1]` 变为 `B[0~j]`，`f[i,j] = f[i-1,j] + 1`。

  2. 插入字符，前面操作将 `A[0~i]` 变为 `B[0~j-1]`，`f[i,j] = f[i,j-1] + 1`。

  3. 替换 `A[i]`，前面操作将 `A[0~i-1]` 变为 `B[0~j-1]`，如果 `A[i]` 与 `B[j]` 相等，就不需要替换操作。`f[i,j] = f[i-1,j-1] + 1|0`。

  状态转移方程：`f[i,j] = min(f[i-1,j]+1, f[i,j-1]+1, f[i-1,j-1]+1|0)`。

**代码：**

```
public class Main {

    static int N = 1010, n, m, idx = 0;
    static char[] a = new char[N], b = new char[N];
    static int[][] f = new int[N][N];

    public static void main(String[] args) {
        ...

        for (int i = 0; i <= m; i++) f[0][i] = i; // A串为空时只有增加操作
        for (int i = 0; i <= n; i++) f[i][0] = i; // B串为空时只有删除操作

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++) {
                f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + 1;
                if (a[i] == b[j])
                    f[i][j] = Math.min(f[i][j], f[i - 1][j - 1]); // a[i]==b[j]时不需要替换操作
                else
                    f[i][j] = Math.min(f[i][j], f[i - 1][j - 1] + 1);
            }
        System.out.print(f[n][m]);
    }
}
```

## 区间 DP

**问题：石子合并**

设有 N 堆石子排成一排，其编号为 1，2，3，…，N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 4 堆石子分别为 `1 3 5 2`， 我们可以先合并 1、2 堆，代价为 4，得到 `4 5 2`， 又合并 1，2 堆，代价为 9，得到 `9 2` ，再合并得到 11，总代价为 4+9+11=24；

如果第二步是先合并 2，3 堆，则代价为 7，得到 `4 7`，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

**题解：**

状态应该包含一段区间。

* 状态表示：`f[i,j]`

  * 集合：将区间 `[i,j]` 的石子堆在一起的所有方式。
  * 属性：最小代价。
  
* 状体计算：

  无论 `f[i,j]` 表示哪段区间的合并，它最后一步都是合并两堆石子，且代价等于 `[i,j]` 区间所有石子的质量之和。那么现在就可以忽略最后一步的合并，转而考虑这两小堆石子的合并方式。根据最后一步石子的分界点来划分 `f[i,j]`。

  状态转移方程：`f[i,j] = min(f[i,k] + f[k+1,j]) + sum(i...k), k = 1, 2, 3, ..., N-1`。
  
  K 表示左半堆最右那堆石子的序号，K = 1，2，3，...，N-1。

**代码：**

模板使用前缀和计算区间石子总质量。

```
for (int len = 2; len <= n; len++)
    for (int i = 1; i + len - 1 <= n; i++) {
        int l = i, r = i + len - 1;
        f[l][r] = INF;
        for (int k = l; k < r; k++) {
            f[l][r] = Math.min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);
        }
    }
```

## 计数类 DP

**问题：整数划分**

一个正整数 n 可以表示成若干个正整数之和，形如：*n = n1 + n2 + … + nk*，其中 *n1 ≥ n2 ≥ … ≥ nk, k ≥ 1*。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。

由于答案可能很大，输出结果请对 *10^9+7* 取模。

**题解1：**

这道题可以看作 01 背包问题。

* 状态表示：`f[i,j]`

  * 集合：从整数 `1~i` 中选择，使得和恰好等于 j 的所有方案。
  * 属性：方案数量。

* 状态计算：

  根据数字 i 被选择的次数，将 `f[i,j]` 划分为若干个子集。

  状态转移方程：
  
  ​		`f[i,j] = count(f[i-1,j] + f[i-1,j-i] + f[i-1,j-2*i] + ... + f[i-1,j-s*i])`。

**代码1：**

```
static int N = 1010, M = 1000_000_000 + 7, n;
static int[][] f;

f[0][0] = 1; // 由0个数字组成和为0的方案只有一个
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= n; j++)
        for (int k = 0; k * i <= j; k++)
            f[i][j] = (f[i][j] + f[i - 1][j - k * i]) % M;
```

观察 `f[i,j]` 与 `f[i-1,j]`

```
f[i,j] = f[i-1,j] + f[i-1,j-i] + f[i-1,j-i*2] + ... + f[i-1,j-i*s]
f[i,j-i] = 			f[i-1,j-i] + f[i-1,j-i*2] + ... + f[i-1,j-i*s]
```

`f[i,j]` 的计算式可以化为：

```
f[i,j] = f[i-1,j] + f[i,j-i] (j >= i)
```

那么，上面的代码可以优化为：

```
for (int i = 1; i <= n; i++)
    for (int j = 0; j <= n; j++) {
        f[i][j] = f[i - 1][j] % M;
        if (j >= i) f[i][j] = (f[i][j] + f[i][j - i]) % M;
    }
```

继续优化为一维数组：

```
for (int i = 1; i <= n; i++)
    for (int j = i; j <= n; j++) {
        f[j] = (f[j] + f[j - i]) % M;
    }
```

**题解2：**

* 状态表示：`f[i,j]`
  * 集合： 所有和为 i，由 j 个数字组成的方案。
  * 属性：数量。

* 状态计算：

  根据方案中最小数字是否为 1 将 `f[i,j]` 划分为两个子集：

  * 最小数等于 1 时，省略 1 得到 `f[i-1,j-1]`，其表示的方案数量与 `f[i,j]` 相等。
  * 最小数大于 1 时，所有数同时减 1 得到 `f[i-j,j]`，其表示的方案数量与 `f[i,j]` 也相等。

  状态转移方程：
  
  ​	`f[i,j] = f[i-1,j-1] + f[i-j,j]`，
  
  ​	`answer = f[n,1] + f[n,2] + ... + f[n,n]`。

**代码2：**

```
f[0][0] = 1; // 和为0，由0个数字组合的方案有一个
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++) {
        f[i][j] = f[i - 1][j - 1] % M;
        if (i >= j) f[i][j] = (f[i][j] + f[i - j][j]) % M;
    }

int ans = 0;
for (int i = 0; i <= n; i++) ans = (ans + f[n][i]) % M;
```

## 数位统计 DP

**问题：计数问题**

给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。

例如，a=1024，b=1032，则 a 和 b 之间共有 9 个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 10 次，`1` 出现 10 次，`2` 出现 7 次，`3` 出现 33 次 ...

**题解：**

分类讨论。首先简化问题，函数 `count(n,x)` 返回 `1~n` 之间 `x` 的出现次数，那么 `a~b` 之间 `x` 的出现次数就等于 `count(b,x) - count(a-1,x)`。

设 `x` 值为 `abcdefg`，求数字 1 出现在 d 位置的次数，即 `1 <= xxx1yyy <= abcdefg` 这类数字的个数：

* 当 `xxx = 0~abc-1`，`yyy` 可以取值 `0~999`。这类数字有 `abc * 10^3` 个。
* 当 `xxx = abc`：
  * 若 `d < 1`，无法遍历到 `abc1...`，这类数字有 `0` 个。
  * 若 `d = 1`，`yyy` 可以取值 `0~efg`，这类数字有 `efg+1` 个。
  * 若 `d > 1`，`yyy` 可以取值 `0~999`，这类数字有 `1000` 个。

然后对每一位都是这么讨论，最后累加起来，得到 `0~abcdefg` 中 `x` 的出现次数。

还有一些特殊情况：

* 当 `x` 出现在最高位 `x...` 时，`xxx = 0~abc-1` 的情况便不存在，直接讨论下一种情况。

* 如果 `x = 0`，`x` 不能在第一位，只能从第二高位开始枚举。而且 `x` 前面的数不能全是 0，此时第一种情况的 `xxx` 只能取值 `1~abc-1`。


**代码：**

```
public class Main {

    // 返回数字n的位数
    static int dgt(int n) {
        int res = 0;
        while (n != 0) {
            res++;
            n /= 10;
        }
        return res;
    }

    // 计算1~n中，数字x出现的次数
    static int count(int n, int x) {
        int res = 0, d = dgt(n);
        for (int i = 1; i <= d; i++) { // 从右向左遍历每一位数字
            int p = (int) Math.pow(10, i - 1); // p是当前位数10的倍数
            // dx是第i位数，l是dx左边的数，r是dx右边的数
            int l = n / p / 10, r = n % p, dx = n / p % 10;
            
            // 计算xxx小于l的情况
            if (x != 0) res += l * p;
            else if (x == 0 && l != 0) res += (l - 1) * p;
            
            // 计算xxx等于x的情况。要么x不为0，要么0左边数字不为0，如果 x=0 && l=0，直接跳过
            if (dx > x && (x != 0 || l != 0)) res += p;
            if (dx == x && (x != 0 || l != 0)) res += r + 1;
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (true) {
            int a = in.nextInt(), b = in.nextInt();
            if (a == 0 && b == 0) break;
            if (a > b) {
                int tmp = a; a = b; b = tmp;
            }
            for (int i = 0; i <= 9; i++)
                System.out.print(count(b, i) - count(a - 1, i) + " ");
            System.out.println();
        }
    }
}
```

## 状态压缩 DP

**问题：蒙德里安的梦想**

求把 N×M 的棋盘分割成若干个 1×2 的的长方形，有多少种方案。

例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。

**题解：**

长方形可以是横向或纵向，先只考虑横向的放置方案，当把所有横向长方形放好，纵向长方形就只能依次添满。所以，横向长方形的放置方案数 = 纵向长方形的放置方案数 = 长方形放置方案数。

* 状态表示：`f[i,j]`

  * 集合：j 是一个二进制数，它表示 i-1 列各行的放置状态。`f[i,001]` 表示当第 i-1 列的前两行空白，第 3 行被一个横向长方形的尾格子填充时，第 i 列所有横向格子放置方案的数量。放置方式是将横向长方形的头格子放在 i-1 列，尾格子放在 i 列。
  * 属性：数量。

* 状态计算：

  现在计算 `f[i,j]`，上一列的状态 `f[i-1,k]` 已知。可以遍历 j 的所有可能状态，有两个限制：

  1. `j & k = 0`：放在 i-1 列的头格子不能与在 i-2 列已经放置的长方形的尾格子冲突。
  2. `j | K` 不存在连续奇数个 0，不然没办法填充纵向长方形。

  这里使用一个 n 位的二进制数表示一条列的状态，这就是状态压缩。

**代码：**

```
public class Main {

    static int N = 12, M = 1 << N, n, m;
    static long[][] f = new long[N][M]; // 第一维表示列， 第二维表示所有可能的状态
    static boolean[] st = new boolean[M]; // 存储各种状态是否有连续奇数个0

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        while (true) {
            n = in.nextInt();
            m = in.nextInt();
            if (n == 0 && m == 0) break;

            // 计算st，不同行数的棋盘，它的st数组都不同
            for (int i = 0; i < 1 << n; i++) {
                st[i] = true;
                int cnt = 0; // 连续0的个数
                for (int j = 0; j < n; j++) {
                    if ((i >> j & 1) == 1) {
                        if ((cnt & 1) == 1) st[i] = false;
                        cnt = 0;
                    } else cnt++;
                }
                if ((cnt & 1) == 1) st[i] = false;
            }

            for (int i = 0; i < N; i++) Arrays.fill(f[i], 0);

            f[0][0] = 1; // 第0列只有一种放置方案：什么都不放
            for (int i = 1; i <= m; i++) // 遍历每一列
                for (int j = 0; j < 1 << n; j++) // 遍历当前列的状态j
                    for (int k = 0; k < 1 << n; k++) // 遍历第i-1列的状态k
                        if ((j & k) == 0 && st[j | k])
                            f[i][j] += f[i - 1][k]; // 当前列的方案数等于i-1列所有满足条件的状态累加
            // f[m][0]表示前m-1列都处理完，并且m-1列没有伸出格子的所有方案数
            // 列从下标0开始，所以前m-1列处理完就是说整个棋盘都摆完
            System.out.println(f[m][0]);
        }
    }
}
```

**问题：最短 Hamilton 路径**

给定一张 n 个点的带权无向图，点从 0∼n−1 标号，求起点 0 到终点 n−1 的最短 *Hamilton* 路径。

*Hamilton* 路径的定义是从 0 到 n−1 不重不漏地经过每个点恰好一次。

输出一个整数，表示最短 *Hamilton* 路径的长度。

**题解：**

* 状态表示：`f[i,j]`
  * 集合：从源点走到 j 点，经过的所有点都存在于 i 当中的所有路径。i 是一个二进制数，表示点的集合。
  * 属性：最小值。

* 状态计算：

  根据路径中倒数第二个点将 `f[i,j]` 划分为若干个子集，`f[i,j] = f[i-j,k] + d[k,j]`。

  状态转移方程：`f[i,j] = min(f[i-j,0]+d[0,j], f[i-j,1]+d[1,j], ..., f[i-j,k]+d[k,j])`。

**代码：**

```
public class Main {

    static int INF = 0x3f3f3f3f, N = 21, M = 1 << N, n;
    static int[][] g = new int[N][N], f = new int[M][N];

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();

        for (int i = 0; i < n; i++) 
        	for (int j = 0; j < n; j++) 
        		g[i][j] = in.nextInt();
        		
        for (int i = 0; i < M; i++) Arrays.fill(f[i], INF); // 初始所有路径长度为正无穷

        f[1][0] = 0; // 从0经过0到达0的路径长度为0
        for (int i = 0; i < 1 << n; i++)
            for (int j = 0; j < n; j++)
                if ((i >> j & 1) == 1) // i首先要包含点j
                    for (int k = 0; k < n; k++)
                        if ((((i - (1 << j)) >> k) & 1) == 1) // i减去j点还包含k点
                            f[i][j] = Math.min(f[i][j], f[i - (1 << j)][k] + g[k][j]);
        System.out.print(f[(1 << n) - 1][n - 1]);
    }
}
```

## 树形 DP

**题目：没有上司的舞会**

*Ural* 大学有 N 名职员，编号为 1∼N。

他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

每个职员有一个快乐指数，用整数 Hi 给出，其中 *1 ≤ i ≤ N*。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

**题解：**

这道题就是找若个点，这些点在树形图中互不连接，使得所有点的权值之和最大。

* 状态表示：`f[i,j]`
  * 集合：以 i 点为根的子树的所有选择方案。`j = 1|0`，表示是否选择 i 点。
  * 属性：最大权值和。

* 状态计算：

  每个结点都有两种状态：选或不选。

  状态转移方程：

  ​	不选 i 点，可以选或不选其子结点：`f[i,j] = sum(max(f[k,0],f[k,1])), k=i的所有子结点`

  ​	选 i 点，不能再选其子结点：`f[i,j] = sum(f[k,0]) + h(i), k=i的所有子结点`

  ​	`answer = max(f[1,0], f[1,1])`

**代码：**

```
public class Main {

    static int N = 6010, n, idx = 0;
    static int[] h = new int[N], e = new int[N], ne = new int[N], w = new int[N];
    static int[][] f = new int[N][2];
    static boolean[] hasfa = new boolean[N]; // 记录是否有直接上司

	// 求以u作为根结点的的最大值
    static void dfs(int u) {
        f[u][1] = w[u];
        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            dfs(j); // 递归处理子树
            f[u][0] += Math.max(f[j][0], f[j][1]);
            f[u][1] += f[j][0];
        }
    }

    static void add(int a, int b) {
        e[idx] = b; ne[idx] = h[a]; h[a] = idx++;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        for (int i = 1; i <= n; i++) {
            w[i] = in.nextInt();
        }
        Arrays.fill(h, -1);
        for (int i = 0; i < n - 1; i++) {
            int a = in.nextInt(), b = in.nextInt(); // b是a的直接上司
            add(b, a);
            hasfa[a] = true;
        }
        // 找到根结点
        int root = 1;
        while (hasfa[root]) root++;
		
        dfs(root);

        System.out.print(Math.max(f[root][0], f[root][1]));
    }
}
```

## 记忆化搜索

前面 DP 问题的代码都使用循环的实现方式，但还能使用递归实现。递归的可读性更高，代码复杂度更低，易于维护。当然，记忆化搜索也有缺点。它的运行比循环实现要慢，且递归层次较多时可能会爆栈。

**问题：滑雪**

给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。

在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25 个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度（可经过最大区域数）。

**题解：**

* 状态表示：`f[i,j]`

  * 集合：所有从 `[i,j]` 点开始滑雪的路径。
  * 属性：路径长度最大值。

* 状态计算：

  根据初始滑动的方向，将 `f[i,j]` 分为 4 个子集。当然，滑向的点的高度必要要低于出发点。

  状态转移方程：`f[i,j] = max(f[i-1,j], f[i+1,j], f[i,j-1], f[i,j+1]) + 1`。

**代码：**

```
public class Main {

    static int N = 303, r, c;
    static int[][] g = new int[N][N], f = new int[N][N];

    // 计算从[i,j]点出发的最长路径
    static int dfs(int i, int j) {
        if (f[i][j] != -1) return f[i][j];

        int[] dx = {1, -1, 0, 0}, dy = {0, 0, 1, -1};

        f[i][j] = 1; // 源点+1
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 1 && x <= r && y >= 1 && y <= c && g[i][j] > g[x][y])
                f[i][j] = Math.max(f[i][j], dfs(x, y) + 1); // +1是加上当前点
        }
        return f[i][j];
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        r = in.nextInt();
        c = in.nextInt();

        for (int i = 1; i <= r; i++)
            for (int j = 1; j <= c; j++)
                g[i][j] = in.nextInt();

        for (int i = 1; i <= r; i++) Arrays.fill(f[i], -1);

        int ans = 0;
        for (int i = 1; i <= r; i++)
            for (int j = 1; j <= c; j++)
                ans = Math.max(ans, dfs(i, j));

        System.out.print(ans);
    }
}
```

# 贪心

贪心比 DP 还难，DP 问题没有模板，但有固定的套路。而贪心问题连套路都没有，而且很难证明算法的正确性。

贪心是逐步求取局部最优解，它只适合单峰问题。

## 区间问题

**问题：区间选点**

给定 N 个闭区间 `[ai,bi]`，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

**题解：**

* 将所有区间按右端点从小到大排序。

* 选择第一个区间的右端点作为标记，然后从前往后枚举所有区间

  如果当前区间包含标记，则跳到下一个区间。否则，将这个区间的右端点作为新的标记。

* answer = 标记点的数量

**代码：**

```
public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        Range[] rs = new Range[n];
        for (int i = 0; i < n; i++) {
            int a = in.nextInt(), b = in.nextInt();
            rs[i] = new Range(a, b);
        }
        
        Arrays.sort(rs); // 按右端点排序
        
        int cnt = 1, tag = rs[0].r;
        for (int i = 1; i < n; i++) {
            if (rs[i].l <= tag) continue; // 重合，跳过
            else {
                tag = rs[i].r; // 补充和，更新端点，标记数+1
                cnt++;
            }
        }
        System.out.print(cnt);
    }
}

class Range implements Comparable<Range> {
    int l, r;
    Range(int l, int r) { this.l = l; this.r = r; }
    public int compareTo(Range o) { return this.r - o.r; }
}
```

***

**问题：区间分组**

给定 N 个闭区间 `[ai,bi]`，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

**题解：**

* 将所有区间按左端点从小到大排序。

* 从前往后枚举所有区间

  尝试将其放入某个分组，即比较各组的右端是否与当前区间左端重合，并更新这个组的右端，如果有多个组可以放，随机挑一个。如果不存在这样的组，则创建新组。


**代码：**

这里使用小根堆存放各组的最右端点，很巧妙。

```
public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        Range[] rs = new Range[n];
        for (int i = 0; i < n; i++) {
            int a = in.nextInt(), b = in.nextInt();
            rs[i] = new Range(a, b);
        }

        Arrays.sort(rs); // 按左端点排序

        PriorityQueue<Integer> heap = new PriorityQueue<>(); // 小根堆存放各组的最右端点

        for (int i = 0; i < n; i++) {
            Range t = rs[i];
            // 为当前区间分组，如果连最小的分组右端点都和当前区间左端点相交，那只能创建新租。
            if (heap.isEmpty() || heap.peek() >= t.l)
                heap.offer(t.r); // 创建新组
            else {
            	// 加入组并更新最右端点
                heap.poll();
                heap.offer(t.r);
            }
        }

        System.out.print(heap.size());
    }
}

class Range implements Comparable<Range> {
    int l, r;
    Range(int l, int r) { this.l = l; this.r = r;
    }
    public int compareTo(Range o) { return this.l - o.l; }
}
```

***

**问题：区间覆盖**

给定 N 个闭区间 `[ai,bi]` 以及一个线段区间 `[s,t]`，请你选择尽量少的区间，将指定线段区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

**题解：**

* 将所有区间按左端点从小到大排序。
* 枚举所有区间，从所有能够覆盖 [s,t] 左端点的区间中选择右端点最大的那个，然后将 s 更新为这个区间的右端点。反复迭代，直至 s >= t。 

**代码：**

```
public class Main {

    static int INF = 0x3f3f3f3f;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int st = in.nextInt(), ed = in.nextInt();
        int n = in.nextInt();
        Range[] rs = new Range[n];
        for (int i = 0; i < n; i++) {
            int a = in.nextInt(), b = in.nextInt();
            rs[i] = new Range(a, b);
        }

        Arrays.sort(rs); // 按左端点排序

        int cnt = 0;
        for (int i = 0; i < n; i++) {
            int j = i, R = -INF;
            // 选择能覆盖st的右端点最大的区间
            while (j < n && rs[j].l <= st) {
                R = Math.max(R, rs[j].r);
                j++;
            }
            if (R < st) break; // 没有可以覆盖st的区间
            cnt++;
            st = R;
            i = j - 1;
            if (R > ed) break;
        }
        if (st >= ed) System.out.print(cnt);
        else System.out.print(-1);
    }
}

class Range implements Comparable<Range> {
    int l, r;
    Range(int l, int r) {this.l = l; this.r = r; }
    public int compareTo(Range o) { return this.l - o.l; }
}
```

## Huffman 树（最优二叉树）

> 给定 N 个有权值的叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称哈夫曼树（*Huffman Tree*）。特点：权值较大的结点离根较近。

**问题：合并果子**

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 1，2，9。

可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力 = 3+12=15。

可以证明 15 为最小的体力耗费值。

**题解：**

和区间 DP 的**石子合并**问题有点相似，但此问题不受位置的限制，任意两堆果子都可以合并，自由度更大。

这是一个典型的哈夫曼树问题。设计一颗二叉树，叶子结点表示果堆，权值为搬运耗费的力气。父结点表示两个子结点合并在一起的果堆，它的权值是两个子结点之和。题目就是求一颗除叶子结点权值之和最小的树。

哈夫曼树的构造是基于贪心的思想：

* 将 n 个结点分别作为 n 棵仅有一个结点的二叉树，构成森林 F。

* 构造新结点，并从 F 中选择两棵权值最小的树作为新结点的左右子树，新结点权值 = 子树权值之和。

  从 F 中删去前面选择的两棵子树，将新树加入 F。

* 重复上一步，直至 F 只含有一棵树，这棵树就是哈夫曼树。

**代码：**

小根堆非常方便。

```
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    int sum = 0;
    PriorityQueue<Integer> heap = new PriorityQueue<>(n);
    for (int i = 0; i < n; i++) heap.offer(in.nextInt());

    while (heap.size() > 1) {
        int a = heap.poll(), b = heap.poll();
        sum += a + b;
        heap.offer(a + b);
    }
    System.out.print(sum);
}
```

## 排序不等式

**题目：排队打水**

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

输出一个整数，表示最小的等待时间之和。

**题解：**

将所有人按打水时间从小到大排序，然后累加求和。

假如第一个人的打水时间是 t1，那么所有人等待他打水的时间之和是 `(n-1)*t1`，第二个人打水被等待的时间之和是 `(n-2)*t1`。所以，将打水快的人排前面，这样才能使得等待时间之和最小。

**代码：**

```
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    long[] ts = new long[n];
    for (int i = 0; i < n; i++) ts[i] = in.nextInt();
    Arrays.sort(ts);
    
    long sum = 0;
    for (int i = 0; i < n; i++) sum += ts[i] * (n - i - 1);
    
    System.out.print(sum);
}
```

## 绝对值不等式

**问题：货仓选址**

在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

输出一个整数，表示距离之和的最小值。

**题解：**

直觉是中位数，正确答案也是如此，如果商店有偶数个，放中间两点中任意一个位置都可。

**代码：**

```
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    int[] a = new int[n];
    for (int i = 0; i < n; i++) a[i] = in.nextInt();
    Arrays.sort(a);

    int sum = 0;
    for (int i = 0; i < n; i++) sum += Math.abs(a[n >> 1] - a[i]);
    System.out.print(sum);
}
```

## 推公式

**问题：耍杂技的牛**

农民约翰的 N 头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

输出一个整数，表示最大风险值的最小可能值。

**题解：**

将所有牛按 wi+si 的结果从小到大排序，前面的牛叠在下面。

**代码：**

```
class Main {

    static int INF = 0x3f3f3f3f;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        Cattle[] cs = new Cattle[n];
        for (int i = 0; i < n; i++) {
            int w = in.nextInt(), s = in.nextInt();
            cs[i] = new Cattle(w, s);
        }
        Arrays.sort(cs);
        int ans = -INF, sum = 0;
        // 从上往下计算，sum是当前牛它上面所有牛的重量，ans是最大风险值
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, sum - cs[i].s);
            sum += cs[i].w;
        }
        System.out.print(ans);
    }
}

class Cattle implements Comparable<Cattle> {
    int w, s;
    public Cattle(int w, int s) { this.w = w; this.s = s; }
    public int compareTo(Cattle o) { return (this.w + this.s) - (o.w + o.s); }
}
```
