# 运行时数据区域

与 C++ 不同，Java 拥有内存自动管理机制，不需手动回收对象的内存，这让 Java 编码更加简单和安全。但当发生内存溢出等错误时，如果不了解 JVM 如何管理内存，将很难分析和解决问题。

JVM 运行 Java 程序的过程中会把它管理的内存划分为若干个区域，这些区域有各自的用途，以及创建和销毁的时间。有的区域随 JVM 进程的启动而一直存在，有的则随用户线程而建立和销毁。

## 程序计数器

程序计数器是一块很小的内存，用于记录线程此时执行到哪一行字节码。每个线程都有一个程序计数器，计数器间相互独立，互不影响，这种内存区域也称为 "线程私有内存"。如果线程正在执行 Java 方法，计数器的值就是对应字节码指令的地址，如果执行的是 Native 方法，则值为空。

由于 JVM 使用轮流切换线程 + 分配 CPU 执行时间的方式实现多线程，线程会被挂起和恢复，所以需要记录各个线程的执行进度，以在线程切换时恢复到正确位置。另外，分支、循环、跳转、异常处理等基础功能也都依赖计数器进行实现。

## JVM 栈

虚拟机栈也是线程私有内存，描述 Java 方法执行的线程内存模型：每调用一个方法，就向当前线程的虚拟机栈压入一个栈帧，帧内有局部变量表、操作数栈、动态链接、方法出口等信息，方法结束时，就把对应的栈帧从虚拟机栈弹出。

局部变量表占据着栈帧的绝大部分空间，其中存放着编译期可知的各种 Java 虚拟机基本数据类型、对象引用类型和 `returnAddress` 类型（指向一条字节码指令的地址）。数据在局部变量表的占用空间使用槽 Slot 表示，每个槽具体多大，由虚拟机实现决定，类型 `long` 和 `double` 占用 2 个槽，其它的都只占用 1 个槽。局部变量表所需内存会在编译期间完成分配，因为方法会使用哪些数据完全明确，所以局部变量表需要的槽数完全固定，方法运行期间不会改变局部变量表的大小。

如果线程请求的栈深度大于虚拟机所允许的上限，抛出 `StackOverfolwError` 异常，称为"爆栈"。如果虚拟机栈允许动态扩展，当栈拓展时无法申请到足够的内存空间，抛出 `OutOfMemoryError` 异常。HotSpot 把虚拟机栈设计为不支持拓展，所以除非在创建线程时就无法申请到足够的内存，否则这个区域不会发生 OOM 异常。

以下是相关 JVM 参数：

* `-Xss`：等同 `-XX:ThreadStackSize`，虚拟机栈的初始容量。

## 本地方法栈

作用与虚拟机栈类似，但虚拟机栈为 JVM 执行 Java 方法服务，而本地方法栈是为 JVM 执行 Native 方法服务。

《JVM 规范》对本地方法栈中方法使用的语言、使用方式，以及数据结构，没有强制要求，因此虚拟机可以根据需要自由实现。有的虚拟机，比如 HotSpot，便把本地方法栈合并到虚拟机栈。

## Java 堆

Java 堆是虚拟机所管理的内存中最大的一块，它在 JVM 启动时创建，被所有线程共享。Java 堆唯一的作用是存放对象实例。《JVM 规范》表示所有对象实例以及数组都应在堆上分配，但现实并非如此。随着 Java 发展，尤其是逃逸分析技术的进步，有些时候 Java 对象可以在其它地方，比如栈上分配。

Java 堆是垃圾收集器主要管理的区域，所以也称为 GC 堆（Garbage Collected Heap）。Java 堆可以处于物理不连续的内存空间，但在逻辑上被视为连续。但为了方便实现和性能考虑，虚拟机可能会要求内存连续。

> 现代垃圾收集器大部分都基于分代收集理论设计，所以常常看到 "新生代"、"老年代"、"永久代" 等词，这些只是某些垃圾收集器的设计风格，而非虚拟机固定的实现，更不是 JVM 规范。目前，已经出现了许多不采用分代设计的新垃圾收集器。所以除非讨论具体某个虚拟机实现，尽量别用这些名词描述 Java 堆。

Java 堆可以是固定大小，但当前主流虚拟机都是按照可扩展实现，如果 Java 堆剩余空间不足以分配新对象，并且无法再扩展，抛出 `OutOfMemoryError` 异常。

以下是相关 JVM 参数：

* `-Xms`：等同 `-XX:InitialHeapSize`，Java 堆的初始容量。
* `-Xmx`：等同 `-XX:MaxHeapSize`，Java 堆的最大容量。

## 方法区

方法区是各个线程共享的内存区域，用于存放 JVM 加载的类型信息、静态变量、常量、即时编译器的代码缓存等数据。虽然，JVM 规范把方法区描述为 Java 堆的一个逻辑部分，但不要把它们混为一谈。

《JVM 规范》对方法区的约束非常宽松，与 Java 堆一样，可以处于物理不连续的内存，可以实现为固定大小或者可拓展，甚至还能不实现垃圾收集。相对 Java 堆，方法区很少发生垃圾收集，并不是不回收垃圾，只是收集效果往往比较差。这块区域内存回收的主要目标是常量池回收和类型卸载，特别是类型卸载，收集条件非常苛刻。

> **方法区和 "永久代"**
>
> 早期，HotSpot 把收集器的分代设计拓展到方法区，或者说，用永久代实现方法区。这让垃圾收集器可以像管理 Java 堆一样管理方法区，而不必专门为方法去设计内存管理。这个做法并不好，非常容易发生内存溢出问题，因为永久代的大小有 `-XX:MaxPermSize` 上限。有些虚拟机，比如 JRockit，没有永久代的概念，使用元空间实现方法区，只要没有达到进程可用空间的上限，程序就能正常运行。
>
> 随着技术发展，HotSpot 逐渐放弃永久代，JDK 7 把永久代的字符串常量池、静态变量等移到 Java 堆，到了 JDK 8，则完全放弃永久代，参照 JRockit 改用本地内存的元空间 Mate-Space 实现方法区。前面未移到 Java 堆的数据随之被移到元空间。

如果方法区无法满足新的内存分配需求，抛出 `OutOfMemoryError` 异常。

以下是相关 JVM 参数：

* `-XX:PermSize`：永久代的初始容量，JDK 7 后无效。
* `-XX:MaxPermSize`：永久代的最大容量，JDK 7 后无效。
* `-XX:MetaspaceSize`：元空间的初始容量，垃圾收集的阈值，收集器 Full GC 后会调整该值。
* `-XX:MaxMetaspaceSize`：元空间的最大容量，默认 -1，即不限制，或者说受本地最大内存限制。
* `-XX:MinMetaspaceFreeRatio`：垃圾收集后空闲空间的最小占比，能降低因元空间不足而收集的频率。

## 运行时常量池

每个 Class 文件都有一个常量表，其中保存编译期生成的各种字面量与符号引用，虚拟机指令能根据常量表找到要执行的类名、方法名、参数类型、字面量等数据。运行时常量池是方法区的一部分（元空间），加载类的时候会把常量表的内容放入运行时常量池。运行时常量池具备动态性，运行时也能加入新的常量，比如 `intern()`。

《JVM 规范》对运行时常量池没有任何细节要求，供应商可以按需自由实现这个内存区域。通常，除了 Class 文件描述的符号引用，JVM 还会把由符号引用解析出来的直接引用也存到运行时常量池。

运行时常量池自然受到方法区内存的限制，当无法申请到足够的内存时，抛出 `OutOfMemoryError` 异常。

## 字符串常量池

字符串常量池是方法区的一部分，HotSpot 在 JDK 7 把它从永久代移到 Java 堆。其中的内容是字符串实例，或者堆上字符串对象的引用。常量池使用一个 StringTable 对象完成，这是哈希表，默认大小 1009。

**为什么设计字符串常量池？**

代码中常会出现字符串字面量，即使是临时一用，Java 也要为其创建对象。要是一个字面量多次出现，难道每次都要创建新对象嘛？字符串是不可变对象，所以等值的字面量其实都能安全地共享同一个对象。

为此，提出字符串常量池，以后只要遇到字符串字面量，就会先尝试从池中获取对象，如果找不到，则根据字面量创建对象，并把这个对象存入池内，最后返回引用。注意，这个对象保存在常量池，而非 Java 堆。

**JDK 6 与 JDK 7 的 intern()**

`String::intern()` 是一个本地方法，如果字符串常量池已有一个字符串与当前对象等值，那就返回池里面那个字符串的引用，否则把当前字符串加入常量池并返回引用。

JDK 6 以及之前，`intern()` 会在池内创建对象，到了 JDK 7，`intern()` 只会把当前对象的引用加入池中。

**经典案例分析**

以下语句会创建两个对象，程序启动后第一次遇到 "ball" 字面量，为其在常量池创建对象。然后 `new` 关键字根据字面量在堆上创建一个对象。返回的是堆内对象的引用。

```
String a = new String("ball");
```

以下语句只会在堆上创建一个对象，这里没有出现字符串字面量。

```
String a = String.valueOf(101);
```

## 直接内存

**各种内存的说明**

首先，Java 程序本质是一个运行在用户空间的进程，前边提到的那些内存区域，都由虚拟机使用和管理，但这些内存并不是进程空间的全部，那些不由虚拟机管理的内存就称为堆外内存（本地内存）。

元空间没有大小限制，只受限于物理内存，就是因为元空间使用本地内存实现。Native Heap 和直接内存都是特殊本地内存，前者通过 `DirectByteBuffer` 使用，后者通过 `Unsafe::allocateMemory()` 使用。

**普通方式接收数据**

通常，虚拟机使用 HeapByteBuffer 类从外部读数据，数据先从内核空间拷贝到用户空间的直接内存，然后再复制到堆内存，程序才能读到数据。这是 BIO 读写数据的流程。

<img src="https://images-1305875271.cos.ap-chengdu.myqcloud.com/jvm-0d1f0be1.png" style="zoom: 80%;" />

数据为什么要经过这么多流程？早期用户进程可以直接调用系统底层资源和硬件设备，但常发生安全问题，所以划分内核空间和用户空间，用户进程运行于用户空间，容易发生错误的操作只能在内核空间执行，比如 I/O。

数据为什么不直接复制到 Java 堆上呢？因为堆被 GC 管理，拷贝需要提供对应目的地址，期间可能发生 GC 导致内存地址变化，目标地址失效。而直接内存和 Java 堆交换数据的时候，能够保证不执行 GC（BIO 特性）。

**直接内存接收数据**

JDK 1.4 加入 NIO 特性，引入了一种基于 Channel 和 Buffer 的 I/O 方式。这种方式使用 Native 函数库直接分配堆外内存，然后通过 DirectByteBuffer 对象作为这块内存的引用，操作堆外内存数据。这样，便避免了把数据在 Java 堆和 Native 堆来回复制，显著提升 I/O 性能。

DirectByteBuffer 类有一个字段，记录直接内存的地址，所以它能作为引用。

虽然直接内存不受 JVM 管理，但是如果过于庞大，将使得各个内存区域的总和超出物理内存限制，从而导致动态拓展时发生 OOM 异常。

以下是相关 JVM 参数：

* `-XX:MaxDirectMemorySize`：直接内存的最大容量，默认与 Java 堆最大值 `-Xmx` 相等。

# 垃圾收集器

程序计数器、虚拟机栈和本地方法栈都是线程私有内存，生命周期与线程一致，且内存范围明确，进入方法的时候就能确定这个栈帧有多大。因此这几个区域的内存分配和回收都很明确，不需过多考虑。

至于 Java 堆和方法区，则非常不确定，仅当程序运行时，才能知道哪些对象会被创建和创建多少个，哪些类型会被加载，这些内存的分配和回收动态变化。垃圾收集器正是针对这两个区域进行管理。

## 判断对象死亡

如何判定一个对象已经死亡，即可以被回收。

### 引用计数器

对象内添加一个引用计数器，每当有一个地方引用它，计数器的值加 1，引用失效时，计数器的值减 1。任何时刻计数器为零的对象就不可能再被使用，可以回收。

引用计数算法虽然占用了一些额外的内存空间，但实现原理简单，判定效率也很高，Python 便是使用这种算法来管理内存。但是，主流 Java 虚拟机都没有采用这个算法，因为这个看似简单的算法有很多例外情况，需要大量额外处理才能正确工作。比如，两个对象循环引用对方，两个计数器都是 1，但这两对象都不可能再被使用，这种情况就需要额外考虑和处理。

### 可达性分析

基本思路是使用一系列 "GC Roots" 根对象作为起始结点集，从这些结点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链。如果某个对象与根对象没有引用链相连，说明这个对象不可能再被使用，可以回收。

> 目前主流商用语言的内存管理系统都是使用可达性分析算法来判断对象是否存活。

<img src="https://images-1305875271.cos.ap-chengdu.myqcloud.com/jvm-508acdd7.png" alt="image-20240403201549631" style="zoom:67%;" />

在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：

* 虚拟机栈中引用的对象，比如栈上方法使用的参数、局部变量、临时变量等；
* 方法区中类静态属性引用的对象，比如引用类型静态变量；
* 方法区中常量引用的对象，比如字符串常量池里的引用；
* 被同步锁（synchronized）持有的对象；
* 本地方法栈中 JNI（Native 方法）引用的对象；
* JVM 内部的引用，比如基本数据类型 Class 对象、常驻的异常对象、系统类加载器等。

除了这些固定的根对象，根据选用的垃圾收集器以及当前回收的内存区域不同，还会临时性地加入其它对象，共同构成完整 GC Roots。比如基于分代收集的收集器，如果对新生代执行垃圾收集，就得考虑这里的对象是否可能被其它区域的对象引用（比如老年代），所以就要把相关区域的对象一并加入 GC Roots。

### 引用类型

为了更好地管理那些可有可无的对象的内存，JDK 1.2 引入四种引用类型，如下所示，强度依次减弱：

* 强引用（Strongly Re-ference）

  平时的引用，即 `Object obj=new Object()` 这种，强引用关联的对象不会被回收。

* 软引用（Soft Reference，使用 `SoftReference` 类实现）

  描述有用但非必须的对象，只被软引用关联的对象，会在系统即将发生内存溢出之前被列进回收范围之中进行第二次回收，如果还是没能腾出足够空间，才会抛出 `OutOfMemoryError` 异常。

* 弱引用（Weak Reference，使用 `WeakReference` 类实现）

  与软引用类似，但强度更弱，无论当前内存是否足够，GC 时会回收所有只被弱引用关联的对象。

* 虚引用（Phantom Reference，使用 `PhantomReference` 类实现）

  完全不会影响对象的生命周期，相当于没有，唯一的作用是能在对象被回收时收到一个通知。

### finalize()

即使对象在可达性分析中判定为不可达，也不会被直接回收。首先标记不可达对象，然后进行一次筛选，检查对象是否有必要执行 `finalize()` 方法。如果对象没有重写 `finalize()` 方法，或者 `finalize()` 方法之前已经被调用了一次，收集器便认为该对象没必要执行 `finalize()`，应该回收。

筛选出来的对象会被插入 `F-Queue` 队列，稍后使用 Finalizer 线程执行这些对象的方法，这个线程由虚拟机自动创建且优先级非常低。线程不能保证等待每一个 `finalize()` 结束，因为有执行慢和死循环的风险。稍后收集器会对 F-Queue 中的对象第二次标记（不管是否执行完方法），如果 `finalize()` 有为对象连接根对象，此次标记时会将其移出即将回收集合。然后，剩下的对象就要被真正回收。

由于运行代价高昂，不确定性大，以及无法保证各个对象的调用顺序，`finalize()` 方法早被官方明确声明为不推荐使用。虽然 `finalize()` 方法能把对象从收集器手里拯救出来，但实在没什么必要。

### 回收方法区

《JVM 规范》规定方法区可以不实现垃圾回收，因为方法区的回收的性价比非常低，这个区域回收的目标主要是废弃的常量和不再使用的类型。

废弃常量的回收与 Java 堆对象的回收相似，即检查系统中还有哪些地方正在使用这个常量，以此判断还会不会被使用，如果认为不会再被使用，那就可以进行回收。

关于类型卸载，判定一个类型不再会被使用非常难，需要同时满足下面三个条件：

* 该类的所有实例都已经被回收，Java 堆中没有该类及其派生子类的对象；
* 加载该类的类加载器已被回收，默认是使用系统类加载器来加载类，所以需要专门设计；

* 类的 `Class` 对象没有在任何地方被引用，不会在后面被使用反射创建对象。

满足这些条件的无用类型允许被 JVM 回收，至于是否回收，取决于虚拟机实现和 JVM 配置。HotSpot 虚拟机提供参数 `-Xnoclassgc` 进行控制。如果方法区被高强度使用，比如使用 CGLib 字节码框架大量创建新类型，虚拟机就得具备类型卸载能力，保证不会对方法区造成过大的内存压力。

## 垃圾收集算法

根据如何判定对象死亡，垃圾收集算法可分为 "引用计数式垃圾收集" 和 "追踪式垃圾收集"，前面说过主流虚拟机都是使用可达性分析算法，所以这里只讨论追踪式垃圾收集。

### 分代收集理论

**基本的认识**

目前商业虚拟机的垃圾收集器，多数都是基于分代收集理论设计，所谓分代收集，其实只是一套符合多数程序运行实际情况的经验法则，这个理论建立在两个分代假说之上：

* 弱分代假说：绝大部分对象都是朝生夕灭，即生命周期很短，创建后很快就能回收；
* 强分代假说：熬过越多次垃圾收集的对象就越难消亡。

根据这两个假说，收集器将会把 Java 堆划分出不同的区域，然后根据对象的存活时间将其存储到不同区域。如果区域内的对象大多是朝生夕灭，那么只需关注如何保留少量的对象，而不是去关注大量的将被回收的对象，就能以较低的代价回收大量空间。如果区域内的对象都难以消亡，虚拟机就以较低的频率回收该区域。这样就能同时兼顾垃圾收集的时间开销和内存空间的有效利用。

划分出多个区域之后，就能针对单个区域或某些部分进行垃圾回收，所以才有 Minor GC、Major GC、Full GC 等回收类型。根据不同区域的对象的死亡特征，又设计出不同的垃圾回收算法（标记-删除、比较-复制等）。

> 部分收集（Partial GC）指目标不是整个堆的垃圾收集，其中分为：
>
> * 新生代收集（Minor/Young GC）：仅收集新生代的对象；
>
> * 老年代收集（Major/Old GC）：仅收集老生代的对象，目前只有 CMS 收集器有这种行为；
>
> * 混合收集（Mixed GC）：收集新生代以及部分老年代，目前只有 G1 收集器有这种行为；
>
> 整堆收集（Full GC）：收集整个 Java 堆和方法区。

**第三条假说**

基于分代收集理论的商用虚拟机至少有新生代和老年代两个区域，新生代每次回收都死一大片对象，剩余少量对象会逐步提升到老年代。分代收集并不只是简单划分一下内存区域，有很多困难，比如对象之间跨代引用。

假如现在针对新生代执行一次回收，新生代的对象完全有可能被老年代引用，为了找出那些老年代对象，不得不遍历老年代，确保可达性分析正确。理论虽然可行，但一提到遍历，就知道很不靠谱。为了解决这个问题，分代收集理论增加了第三条经验法则：

* 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

存在相互引用关系的两个对象，应该倾向于同时生存或者同时消亡。依据这条假说，虚拟机在新生代建立一个全局数据结构，称为记忆集，该结构把老年代划分为若干小块，标识老年代的哪一部分存在跨代引用。以后新生代收集时包含跨代引用的小块内存的对象会被加入 GC Roots 进行扫描。这种方法需要时刻随着对象改变引用关系而更新记忆集，增加了一些开销，但比起扫描整个老年代还是划算。

### 标记-清除算法

最基础的垃圾收集算法，后面两个算法，都是对这个算法的改进。过程分为 "标记" 和 "清除" 两个阶段：首先标记需要回收的对象，然后统一回收被标记的对象，也可以反过来标记存活的对象。标记过程，就是判定对象是否属于垃圾的过程。

该算法有两个明显缺点：

* 执行效率不稳定。如果堆中包含大量对象，且大部分都需要回收，就要进行大量的标记和清除。这就导致标记和清除的效率会随着对象数量的增长而降低。
* 空间碎片化。标记、清除将会产生大量不连续的内存碎片，碎片太多首先会浪费很多空间，接着还会导致总是无法为大对象分配内存，从而频繁触发 GC。

### 标记-复制算法

将可用内存分为大小相等的两块，每次只使用其中的一块，当这块内存用完时，就把还活着的对象复制到另一块内存里面，然后再把使用过的那块内存一次性清理。

<img src="https://images-1305875271.cos.ap-chengdu.myqcloud.com/jvm-59737df1.png" style="zoom: 67%;" />

如果回收时大多数对象仍然存活，这个算法会产生大量的内存复制开销，但对于大多数对象都要回收的区域，比如新生代，那么每次复制的对象就很少。而且回收时是针对整个半区，那就不会再有空间碎片问题，毕竟复制完后会得到一片规整干净的内存空间。

标记-复制算法实现简单，效率高，且没有空间碎片问题。缺点是只能使用一半可用内存空间，浪费太大。这个算法天生就是为了新生代而设计。

### 标记-整理算法

第一步与标记-清除算法相同，标记需要回收的对象，第二步不是回收内存，而是移动存活的对象的内存，向内存空间另一端移动，然后清理边界以外的内存。

<img src="https://images-1305875271.cos.ap-chengdu.myqcloud.com/jvm-fd120ed5.png" style="zoom:67%;" />

这个算法针对老年代而设计。虽然，直接回收内存比移动内存更高效，而且老年代有大量的存活对象，移动这么多对象开销会非常大。但是，老年代发生垃圾收集的频率很低，这片内存的访问频率倒是非常高。清除算法会造成大量碎片空间，那就需要使用更加复杂的内存访问器和内存分配器，这会增加访问内存的开销。总体而言，清除算法反而会更新耗费性能，降低程序整体的吞吐量。清除或者整理，只是利弊取舍，老年代就适合整理。

# 类加载机制

代码经过编译生成 Class 文件，JVM 把描述类的数据从字节码文件加载到内存，然后对数据进行校验、转换解析和初始化，最终形成 Java 类型，这个过程称为类加载机制。

## 类加载时机

类型从被加载到虚拟机内存开始，直到卸载出内存结束，整个生命周期会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备、解析这三个部分统称为连接（Linking）。

<img src="https://images-1305875271.cos.ap-chengdu.myqcloud.com/jvm-7f2ca7ac.png" style="zoom:67%;" />

加载、验证、准备、初始化、卸载这五个阶段的开始顺序固定，注意，只是开始的顺序，而非运行或完成，这些阶段通常会交错执行，往往某个阶段执行期间就会触发下一个阶段。但是，解析阶段则不固定，有时会在初始化阶段之后再开始，这是为了支持动态绑定特性。

《JVM 规范》没有规定什么时候开始加载阶段，但对于初始化阶段，则是严格规定了**有且只有** 6 种情况必须立即对类进行初始化：

* 遇到 `new`、`getstatic`、`putstatic`、`invokestatic` 这四种字节码指令，如果类型还未初始化，则先触发其初始化阶段。能够生成这四种指令的典型代码场景有：
  * 使用 `new` 关键字实例化对象；
  * 读取或设置一个类型的静态字段（被 `final` 修饰和已在编译期间把结果放入常量池的字段除外）；
  * 调用一个类型的静态方法。

* 使用 `java.lang.reflect` 包的方法对类型进行反射调用，将会触发该类型的初始化；

* 初始化**类**的时候，将会触发其父类的初始化（接口不会这样）；
* 程序的主类（包含 main 方法的类）会被虚拟机先初始化；
* 当使用 JDK 7 新加入的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果是 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInovkeSpecial` 四种类型的方法句柄，并且这个方法句柄对应的类没有初始化，则先触发其初始化阶段；

* 假如接口定义有默认方法，如果该接口的实现类要进行初始化，会先触发该接口的初始化。

## 类加载过程

### 加载

加载阶段 Java 虚拟机需要完成 3 件事情：

* 通过全限定类名获取定义该类的二进制字节流；
* 将字节流中的静态结构转化为方法区的运行时结构；
* Java 堆上生成一个 `java.lang.Class` 对象，作为方法区中这个类的各种数据的访问入口；

加载阶段默认使用虚拟机内置的类加载器执行，当然也能使用自定义的类加载器。

### 验证

验证阶段的目的是确保 Class 文件的字节流包含的信息符合《JVM 规范》约束要求，保证这些信息被当作代码运行时不会危害虚拟机的安全。

验证阶段的工作量在整个类加载中占了相当大的比重，整体上看，可以分为四个小阶段：

* 文件格式验证
* 元数据验证
* 字节码验证
* 符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，而这个转化动作发生在解析阶段。

### 准备

准备阶段将为类中定义的静态变量分配内存并设置初始值（**零值**）。理论上说，静态变量所使用的内存应当在方法区中进行分配，但方法区只是一个概念。JDK 7 之后，静态变量随 Class 对象一起存到 Java 堆中。

对于准备阶段，需要注意以下几点：

* 这里只对静态变量分配内存，实例变量则是在对象实例化的时候随着对象分配到 Java 堆中；
* 默认设置零值，变量定义的赋值动作和静态语句块的赋值语句会在初始化类阶段执行；
* 对于**静态常量**，且有初始值，准备阶段将为其设置初始值，而非零值。原理暂不深究。

### 解析

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。

* 符号引用

  使用一组符号描述被引用的目标，符号可以是任何字面量。符号引用和虚拟机实现的内存布局无关，引用目标甚至不一定是已经加载到虚拟机中的内容。

* 直接引用

  直接引用是可以直接指向目标的指针、相对偏移量、或者是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局直接相关，同一个符号引用被不同的虚拟机翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

### 初始化

准备阶段已为变量赋过一次系统要求的初始零值，到了初始化阶段，则会根据程序代码指定的计划来初始化类变量和其它资源。简单来说，初始化阶段就是执行类构造器 `<clinit>()` 方法的过程。

编译器会自动收集类中所有静态变量的赋值动作和静态语句块中的语句，生成 `<clinit>()` 方法。收集的顺序由语句在文件中的出现顺序决定。静态语句块只能访问定义在前面的静态变量，至于后面的变量，可以赋值，但不能访问。由此可以明白，为什么静态语句块的执行顺序与定义顺序一致。

## 类加载器

Java 虚拟机设计团队特意把类加载阶段中 "通过一个全限定类名获取定义此类的二进制字节流" 这个动作放到虚拟机外部执行，以便让应用程序自己决定如何获取需要的类，实现这个动作的程序称为 "类加载器"。

### 类与类加载器

类加载器用于加载类到虚拟机的内存，但它的作用远不止如此。任何一个类，都必须由加载它的类加载器和类本身共同确定其在虚拟机中的唯一性。也就是说，两个类即使源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就不相等。

所谓相等，包括 `Class::equals()`、`Class::isAssignableFrom()`、`Class::isInstance()` 返回结果，以及使用 `instanceof` 关键字做对象所属关系判定等各种情况。

### 双亲委派模型

Java 虚拟机眼里只有两种类加载器：

* 启动类加载器：使用 C++ 编写，是虚拟机自身一部分；
* 其它类加载器：使用 Java 编写，独立于虚拟机，全都继承 `java.lang.ClassLoader` 抽象类。

但从开发者角度看，类加载器的划分会更细致。自 JDK 1.2 以来，Java 就保持着 "三层类加载器+双亲委派" 类加载架构。虽然 Java 模块化系统（JDK 9）出现以后这个架构有了一些变化，但主体未变。

#### 三层类加载器

JDK 9 之前，所有 Java 类基本都是使用以下 3 种系统提供的类加载器进行加载：

* 启动类加载器（Bootstrap Class Loader）

  负责加载 Java 核心类库，即 `<Java_HOME>\lib` 目录或 `-Xbootclasspath` 参数指定的路径中的类库。前面已经提过，该类加载器使用 C++ 编写，是虚拟机自身一部分。不能被程序直接引用，编写自定义类加载器时如果想把加载请求委托给启动类加载器，使用 `null` 替代即可；

* 拓展类加载器（Extension Class Loader）

  负责加载 Java 拓展类库，即 `<Java_HOME>\lib\ext` 目录或 `java.ext.dirs` 系统变量指定的路径中的类库。使用 Java 代码实现，开发者能在代码中直接使用；

* 应用程序类加载器（Application Class Loader）

  由于是 `ClassLoader.getSystemClassLoader()` 返回值，所以也称为系统类加载器。负责加载用户类路径所有类库，同样能在代码中直接使用，Java 程序的类几乎都由该类加载器加载。

如果认为有必要，还能添加自定义的类加载器进行拓展，比如增加磁盘以外 Class 文件字节流，或者通过类加载器实现类的隔离、重载等功能。

#### 双亲委派机制

前面介绍的几种类加载器之间的关系如下所示，这种分层关系称为双亲委派模型。模型要求除了顶层的启动类加载器以外，其它类加载器都应有自己的父类加载器。通常，类加载器的父子关系不是通过继承，而是使用组合来复用父类加载器的代码。自定义类加载器需要把系统类加载器作为父类加载器。

<img src="https://images-1305875271.cos.ap-chengdu.myqcloud.com/jvm-518dc4d4.png" style="zoom:67%;" />

类加载器收到加载类的请求时，首先会把这个请求委派给父类加载器，每个层次都是如此，因此所有加载类的请求最终都会传到顶层的启动类加载器。仅当父类加载器返回无法加载时，子类加载器才会尝试进行加载。

再次强调，类由加载它的类加载器和类本身共同确定唯一性。双亲委派机制保证任何一个类都只会被一种类加载器加载。比如 Object 类，无论使用哪个类加载器，最后都是由启动类加载器来加载。另一个角度，这把特定的类与特定层级的类加载器绑定，使其也具有一种带有优先级的层次关系。

抽象类 `ClassLoader` 默认实现双亲委派机制，以下是 `loadClass()` 方法默认实现。

```
protected synchronized Class<?> 
		loadClass(String name, boolean resolve) throws ClassNotFoundException {   
    Class c = findLoadedClass(name); // 检查类是否已被加载
    if (c == null) {
        try {
            if (parent != null) {
                c = parent.loadClass(name, false); // 委托父类加载器
            } else {
                c = findBootstrapClassOrNull(name); // 委托系统类加载器
            }
        } catch (ClassNotFoundException e) {
            // 父类加载器无法完成加载，抛出ClassNotFoundException
        }
        if (c == null) {
            c = findClass(name); // 调用findClass方法尝试自己加载
        }
    }
    if (resolve) {
        resolveClass(c);
    }
    return c;
}
```

从中可知，如果想自定义类加载器，只需重写 `findClass(String)`，方法 `ClassLoader::defineClass()` 能够使用 byte 数组构造 Class 对象。

> **`Class.forName()` 和 `ClassLoader.loadClass()` 区别？**
>
> * `ClassLoader.loadClass()` 只是加载 Class 文件到 Java 虚拟机；
>
> * `Class.forName()` 返回 Class 对象，所以这个对象已经初始化，该方法会触发静态语句块执行。

# Java 内存模型

## final

`final` 修饰的变量具有内存可见性。因为 JMM 保证构造器在对 `final` 变量完成赋值之前，其对外不可获取。

## volatile

`volatile` 修饰的变量具有内存可见性。因为，线程每次使用变量都会先从主内存拉取更新，而 `volatile` 变量每次被修改之后，就会立即把新值同步到主内存，保证主内存的值永远是最新状态。

该特性使用内存屏障技术实现，其实就是在写入之后添加字节码指令，强制线程把前面的修改同步到主内存。

似乎 `volatile` 同步性能要优化锁（`synchronized`、`ReentrantLock`）。但由于虚拟机对锁实行的许多消除和优化，很难确切地说 `volatile` 比 `synchronized` 好上多少。`volatile` 变量读操作的性能消耗与普通变量几乎没有什么差别，写操作则会慢上一些，因为需要插入许多内存屏障指令。即便如此，`volatile` 总的开销仍然要比锁更低。所以只要能满足当前场景，优先使用 `volatile`。
