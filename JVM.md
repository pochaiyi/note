# 运行时数据区域

与 C++ 不同，Java 拥有自动内存管理机制，不需手动收回对象的内存，这使 Java 的编码更加简单和安全。但是当发生内存溢出时，如果不了解 Java 虚拟机如何管理内存，会很难分析和解决问题。

Java 虚拟机在运行字节码时，把它管理的内存划分为若干个区域，分别有不同的用途，也有不同的创建和销毁的时间。有的区域随 JVM 进程的启动而一直存在，有的则随用户线程而建立和销毁。

## 程序计数器

程序计数器是一块较小的内存，用于记录线程此时执行到哪一行字节码，可以看作线程所执行的字节码的行号指示器。每个线程都有自己的程序计数器，计数器间相互独立，互不影响，这种内存区域也称为"线程私有内存"。如果线程正在执行 Java 方法，计数器的值就是虚拟机字节码指令的地址，如果执行的是 Native 方法，那计数器的值应该为空。

因为 Java 使用线程轮流切换、分配 CPU 执行时间的方式实现多线程，线程会被挂起和恢复，所以需要记住各个线程的执行进度，以在线程切换时恢复到正确位置。另外，分支、循环、跳转、异常处理等基础功能也都依赖计数器进行实现。

## JVM 栈

虚拟机栈也是线程私有内存，用于描述 Java 方法执行的内存模型。每调用一个方法，就向当前线程的虚拟机栈压入一个栈帧，帧内有局部变量表、操作数栈、动态链接、方法出口等信息，当方法结束时，就把对应的栈帧从虚拟机栈弹出。

局部变量表占据着栈帧的绝大部分空间，其中存放着编译期可知的各种 Java 虚拟机基本数据类型、对象引用类型和 `returnAddress` 类型。这些数据在局部变量表的占用空间使用槽 Slot 表示，每个槽具体多大，由虚拟机实现决定，类型 `long` 和 `double` 占用 2 个槽，其它的都只占用 1 个槽。局部变量表所需的内存空间在编译期间完成分配，因为方法使用到的各种数据都很明确，所以它的局部变量表需要的槽数完全固定，方法在运行期间不会改变局部变量表的大小。

如果线程请求的栈深度大于虚拟机所允许的上限，抛出 `StackOverfolwError` 异常，也叫"爆栈"。如果虚拟机栈允许动态扩展，当栈拓展时无法申请到足够的内存空间，抛出 `OutOfMemoryError` 异常。HotSpot 把虚拟机栈设计为不支持拓展，所以除非在创建线程时就无法申请足够的内存，否则这个区域不会发生 OOM 异常。以下是相关的 JVM 参数：

* `-XX:ThreadStackSize`：简写 `-Xss`，虚拟机栈的初始容量。

## 本地方法栈

本地方法栈和虚拟机栈的作用相似，不过，虚拟机栈为 JVM 执行的 Java 方法服务，而本地方法栈则是为 JVM 执行的 Native 方法服务。

JVM 规范对本地方法栈中方法的语言、使用方式，以及数据结构，没有强制规定，虚拟机可以按需自由实现，有的虚拟机实现，比如 HotSpot，甚至把本地方法栈和虚拟机栈合并。

## JVM 堆

Java 堆是 Java 虚拟机管理的最大的一块内存，它在 JVM 启动时创建，被所有线程共享。Java 堆唯一的作用就是存放对象实例，几乎所有 Java 程序使用到的对象实例都在这里。这里说"几乎"，因为随着 Java 的发展，尤其是逃逸分析技术的进步，使得某些时候，Java 对象可以在其它地方，比如栈帧，分配内存。

Java 堆是垃圾收集器管理的内存区域，所以 Java 堆也称 GC 堆。Java 堆可以处于物理不连续的内存空间，但在逻辑上连续。

Java 堆可以是固定大小，主流 JVM 都把 Java 堆实现为动态拓展。以下是相关的 JVM 参数：

* `-Xms`：与 `-XX:InitialHeapSize` 等价，Java 堆的初始容量。
* `-Xmx`：与 `-XX:MaxHeapSize` 等价，Java 堆的最大容量。

如果 Java 堆剩余空间不足以分配对象实例，并且无法再扩展，抛出 `OutOfMemoryError` 异常。

## 方法区

方法区是线程共享的内存区域，用于存放 JVM 记载的类型信息、静态变量、常量等数据。虽然，JVM 规范把方法区描述为 Java 堆的一部分，但不要把它们混为一谈。

JVM 规范对方法区的约束非常宽松，与 Java 堆类似，可以处于物理不连续的内存空间，可以实现为固定大小或可拓展，甚至还可以不实现垃圾回收。相对 Java 堆，垃圾回收很少在方法区发生。这块区域垃圾回收的主要目标是类型卸载和常量池的回收，特别是类型卸载，它的回收条件非常苛刻。

如果方法区无法满足新的内存分配的需求，抛出 `OutOfMemoryError` 异常。以下是相关的 JVM 参数：

* `-XX:PermSize`：永久代的初始容量，JDK 7 后无效。
* `-XX:MaxPermSize`：永久代的最大容量，JDK 7 后无效。
* `-XX:MetaspaceSize`：元空间的初始容量，垃圾收集的阈值，收集器 Full GC 后会调整该值。
* `-XX:MaxMetaspaceSize`：元空间的最大容量，默认 -1，即不限制，或着说受限于本地内存。
* `-XX:MinMetaspaceFreeRatio`：垃圾收集后空闲空间的最小占比，可减少因元空间不足而收集的频率。

> **方法区和 "永久代"**
>
> 早期，HotSpot 把收集器的分代设计拓展到方法区，或者说，用永久代实现方法区。这使垃圾收集器可以像管理 Java 堆一样管理方法区，省去专门为方法区设计内存管理的工作。这种方式并不好，非常容易发生内存溢出问题，因为永久代的大小有 `-XX:MaxPermSize` 上限。而 JRockit 这种虚拟机，只要没有达到进程可用空间的上限，就能照常使用方法区。
>
> 在 JDK 7，HotSpot 把原本放在永久代的字符串常量池、静态变量等移到 Java 堆。到 JDK 8，HotSpot 完全放弃永久代，参照 JRockit，用在本地内存实现的元空间 Mate-Space 进行替代。

## 运行时常量池

运行时常量池是方法区的一部分，顾名思义，用于存放常量。JVM 规范对其没有任何细节要求，虚拟机可以自由实现这个内存区域。

运行时常量池的数据主要来自 class 文件，除了类的版本、字段、方法、接口等信息外，class 文件还有一个常量池表，存放编译期间生成的各种字面量和符号引用，这部分内容会在类加载后加入运行时常量池。另外，运行时常量池具备动态性，运行期间也可以把新的常量加入池中。

如果运行时常量池无法申请到足够的内存，抛出 `OutOfMemoryError` 异常。JDK 7 之前，常量池的大小被永久代限制，直到 JDK 7，常量池被 Java 堆的大小限制。

## 直接内存和本地内存



直接内存不属于 JVM 的运行时数据区域，它是操作系统管理的内存，NIO 的 `Buffer` 类就是使用直接内存。

使用直接内存的好处有许多：

* 读写效率更高，因为省去在 Java 堆和 Native 堆之间来回复制数据。
* 直接内存没有 Java 堆大小的限制，但有物理内存限制。
* 减少垃圾收集器的压力，因为直接内存不受 JVM 管理。

以下是相关的 JVM 参数：

* `-XX:MaxDirectMemorySize`：直接内存的容量，默认与 `-Xmx` 相等。

注意，**直接内存和本地内存不是一个东西**。原始的机器码运行时会向系统申请 Native Heap 空间，由 JVM 管理的内存就属于这里，Native Heap 即是本地内存。直接内存，是 JVM 进程之外，操作系统管理的内存。

# 垃圾收集器

Java 虚拟机的垃圾收集是针对 Java 堆和方法区的。程序计数器、虚拟机栈和本地方法栈都是随线程而生，随线程而灭，每一个栈帧分配的内存大小都是编译时确定的，因此这三个区域的内存分配和回收都具备确定性，不需要过多考虑回收内存的问题。

而 Java 堆和方法区则有显著的不确定性，只有程序运行时，才能确定哪些对象会被创建，创建多少个，哪些类型会被加载，这些内存的分配和回收是动态的。

## 判断对象死亡

如何判定一个对象是否死亡，或者说是否可以被回收。

### 引用计数器

在对象中添加一个引用计数器，每当有一个地方引用它，计数器的值加一，当引用失效时，计数器的值减一。任何时刻计数器为零的对象就是不可能再被使用的。

计数器算法虽然占用了一些额外的内存空间来进行技术，但它的原理简单，判定效率也很高。但是主流的 Java 虚拟机都没有选用这个算法来管理内存。主要是因为这个看似简单的算法其实有很多例外情况需要考虑，必须配合大量的额外处理才能保证正确的工作。比如单纯的计数器就很难解决多个死对象之间的循环引用问题，这些对象都不会再被使用，但它们相互持有对方的引用，导致无法回收。

### 可达性分析

可达性分析是当前主流商用语言管理内存时使用的算法。这个算法的基本思路就是通过一系列称为 "GC Roots" 的根对象作为起始结点集，从这些结点开始，根据引用关系向下搜索，搜索过程走过的路径称为 "引用链"，如果某个对象不在引用链中，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：

* 虚拟机栈中引用的对象，比如当前正在运行的方法所使用的参数、局部变量、临时变量等。
* 方法区中类静态属性引用的对象。
* 方法区中的常量引用的对象，比如字符串常量池里的引用。
* 本地方法栈中 JNI（Native 方法）引用的对象。
* Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象等。
* 所有被同步锁（`synchronized`）持有的对象。

除了这些固定的 GC Roots 集合以外，根据用户选用的垃圾收集器以及当前回收的内存区域不同，还可以有其它对象临时性地加入。比如在分代收集和局部收集中，如果只针对某个区域进行垃圾收集，必须考虑内存区域是虚拟机自己的实现细节，更不是孤立封闭的，所以某个区域的对象可能会被其它区域的对象引用，这时候就要将这些关联区域的对象也一并加入 GC Roots 集合中。

### 引用类型

JDK 1.2 之前，对引用的定义很传统：如果 `reference` 类型的数据中存储的数值代表的是另一块内存的起始地址，就称该 `reference` 数据是某个对象的引用。在这种定义下，对象只有引用和被引用两种状态，对于描述一些 "食之无味，弃之可惜" 的对象就显得无能为力。

为此，JDK 1.2 之后，Java 将引用扩充为四种类型，它们的引用强度依次减弱：

* 强引用：就是传统的引用。无论何时，被强引用关联的对象不会被垃圾收集器回收。

* 软引用：描述还有用，但非必须的对象。只被软引用关联的对象，在系统即将发生内存溢出前，会把这些对象列进回收范围之中进行第二次回收，如果还没有腾出足够的内存，才会抛出 `OutOfMemoryError` 异常。

  JDK 1.2 之后提供了 `SoftReference` 类来实现软引用。

* 弱引用：描述非必须对象，它的强度比软引用更弱。只被弱引用关联的对象只能活到下一次垃圾回收之前。当垃圾收集器开始工作，无论当前内存是否足够，都会回收只被弱引用关联的对象。

  JDK 1.2 之后提供了 `WeakReference` 类来实现弱引用。

* 虚引用：一个对象是否被虚引用关联，完全不会影响它的生存时间，就好像不存在一样。也无法通过虚引用来取得一个对象的实例。为对象设置虚引用关联的唯一目的只是为了能在这个对象被回收时受到一个通知。

  JDK 1.2 之后提供了 `PhantomReference` 类来实现虚引用。

### finalize()

即使在可达性分析中判定为不可达的对象，也不一定马上死。

如果对象被判定为不可达，首先将对它进行第一次标记，随后进行一次筛选，筛选条件是对象是否有必要执行 `finalize()` 方法。假如对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法之前已经被调用过一次，那么虚拟机就认为它没必要执行 `finalize()`。

虚拟机将所有有必要执行的对象放入一个名为 `F-Queue` 的队列之中，并在稍后由一条虚拟机建立的、低调度优先级的线程去执行它们的 `finalize()` 方法。这里的执行并不保证会等待它的运行结束，毕竟方法有可能死循环。可以在 `finalize()` 方法中将对象与任何一个 GC Roots 引用链的对象建立关联。 稍后垃圾收集器将对 `F-Queue` 中的可达对象进行标记筛选，如果此时对象仍然不可达，那它就真的要被回收了。

注意，`finalize()` 最多执行一次。而且不建议使用 `finalize()` 方法，因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。

### 回收方法区

方法区（如 HotSpot 虚拟机中的元空间或者永久代）的垃圾回收不是必须的。通常，方法区的回收性价比非常低，方法区收回的目标主要是废弃的常量和不再使用的类型。

回收废弃常量与回收 Java 堆中的对象非常类似。但要判定一个不再被使用的类型，条件就非常苛刻了，需要同时满足以下三点：

* 该类的所有实例都已经被回收，也就是堆中不存在该类及其任何派生子类的实例。
* 加载该类的类加载器已经被回收。除非专门设计，否则很难达成。
* 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

Java 虚拟机被允许对满足上述条件的无用类进行回收，而是否要进行回收，HotSpot 虚拟机提供了 `-Xnoclassgc` 参数来控制。

在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

## 垃圾收集算法

### 分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循 "分代收集" 的理论进行设计，分代收集名为理论，其实是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

* 弱分代假说：绝大多数对象都是朝生夕灭的。
* 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡。

为此，收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其存在时间分配到不同的区域之中存储。如果一个区域中大多数对象都是朝生夕灭的，那么每次回收这个区域时只需关注如何保留少量的对象，而不是去标注那些大量的要被回收的对象，就能以较低的代价回收大量的空间。如果一个区域中的对象都是难以消亡的，虚拟机就能以较低的频率回收这个区域。这就同时兼顾了垃圾收集的时间开销和内存空间的有效利用。

在 Java 堆划分出不同的区域后，垃圾收集器才可以每次只回收其中某个或某些区域，因而有了下面几种回收类型的划分：

* Minor GC：目标只是新生代的收集。
* Major GC：目标只是老年代的收集。
* Full GC：目标是整个 Java 堆和方法区的垃圾收集。

而针对不同的区域，需要使用与其里面存储对象的存亡特征相匹配的垃圾回收算法，因而发展出了标记复制算法、标记清除算法、标记整理算法。

虚拟机至少会将堆划分为新生代和老年代两个区域，针对单个区域的垃圾回收并非那么简单，区域之间不是隔离的，对象之间会存在跨代的引用。假如现在要对新生代进行一次垃圾收集，就不得不扫描以便老年代的对象，已建立完全的 GC Roots 集合，反过来也一样。这会给内存带来极大的负担。为此，提出第三条假说：

* 跨代引用假说：跨代引用相对于同代引用来说是极少数。

存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。依据这条假说，我们在新生代建立一个全局的数据结构 "记忆集"，整个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。以后发生 Minor GC 时，只扫描存在跨代引用的老年代小块。这种方法虽然需要在对象改变引用关系时维护记录数据的正确性，会增加一些运行时的开销，但比起扫描整个老年代来说仍然是划算的。

### 标记-清除

如它的名字一样，算法分为 "标记" 和 "清除" 两个阶段：首先标记出所有需要回收的对象，然后统一回收被标记的对象。也可以反过来，标记存活的对象，统一回收没有被标记的对象。

**缺点**

* 执行效率不稳定。如果堆中包含大量对象，且大部分是需要被收回的，这时必须要进行大量的标记和清除的动作，导致标记和清除的执行效率都随着对象数量的增长而降低。
* 空间碎片化。标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后程序无法为新对象分配到足够的连续内存时触发另一次垃圾收集动作。

### 标记-复制

标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题，这种算法主要用于回收新生代。

将内存分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完时，就将还活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

如果内存中的对象多数都是存活的，这种算法会产生大量的内存复制开销，但对于多数对象都是可回收的，算法需要复制的对象就占少数，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的情况，只需要移动堆顶指针，按顺序分配即可。

**缺点**

* 将可用内存缩小到原来的一半，空间浪费实在太多了。

### 标记-整理

标记-复制算法在存活对象较多的情况需要进行大量的复制，而且还直接减少一半的可用空间，所以它不适合老年代的回收。针对老年代对象的存货特征，提出了标记-整理算法。

它的标记过程与标记-清除算法一样，但后续的步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。

**利弊**

对于老年代这种有大量存活对象的区域，移动存活对象并更新引用这些对象的地方将是一种极为负重的操作。而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加危险了。但要是直接清除可回收对象，又会造成空间碎片化，使得必须用复杂的内存访问器和内存分配器，内存访问是用户程序最频繁的操作，在这个环节增加额外负担势必会影响应用程序的吞吐量。

所以，整理和清除都存在利弊，移动对象在内存回收时更复杂，直接清除在访问和分配时更复杂。通常来说，移动对象更好，因为内存访问的频率是远远大于垃圾收集的。

# 类加载机制

Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。

**注意：**

* 类型可以是接口或者类。
* Class 文件并非特指某个存在于磁盘中的文件，而是一串二进制字节流。

## 类加载时机

一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证、准备、解析这三个部分统称为连接。

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/java-9a21d463.png)

加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序 "开始"，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定特性（动态绑定）。

《JVM 规范》并没有约束什么时候开始加载阶段，但对于初始化阶段，则是严格规定了有且只有六种情况必须立即对类进行初始化：

* 遇到 `new`、`getstatic`、`putstatic`、`invokestatic` 这四种字节码指令时，如果类还未初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有：
  * 使用 `new` 关键字实例化对象。
  * 读取或设置一个类型的静态字段。
  * 调用一个类型的静态方法。
* 使用 `java.lang.reflect` 包的方法对类型进行反射调用的时候，如果类型还未初始化，则需要先触发其初始化阶段。

* 当初始化类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
* 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。
* 当使用 JDK7 新加入的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果为 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInovkeSpecial` 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
* 当一个接口定义了 JDK8 新加入的默认方法时，如果这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

## 类加载过程

### 加载

在加载阶段，Java 虚拟机需要完成以下三件事情：

* 通过一个类的全限定名获取定义此类的二进制字节流。
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 在 Java 堆中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段。加载阶段既可以使用 Java 虚拟机内置的启动类加载器来完成，也可以由用户自定义类加载器去完成。

### 验证

这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《JVM 规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机的安全。验证阶段的工作量在整个类加载中占了相当大的比重，从整体上看，验证阶段主要分为以下四个阶段：

* 文件格式验证

  验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。只有通过了这个阶段的验证之后，这段字节流才被允许进入 Java 虚拟机内存的方法区中进行存储，后面三个验证阶段全部是基于方法区的存储结构进行的，不再直接读取、操作字节流了。

* 元数据验证

  对字节码描述的信息进行语义分析。

* 字节码验证

  这是整个验证过程最中最复杂的阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。

* 符号引用验证

  最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在类加载的解析阶段进行。符号引用验证可以看作是对类自身以外的各种信息进行匹配性校验，它的目的是确保解析正确执行。

### 准备

准备阶段是正式为类中定义的变量（静态变量）分配内存并设置初始值的阶段。从概念上讲，这些变量所使用的内存应当在方法区中进行分配，但方法区只是一个逻辑上的区域，在 JDK7 之前，HotSpot 使用永久代来实现方法区，而在 JDK7 之后，类变量则会随着 Class 对象一起存放在 Java 堆中。这时候的 "类变量在方法区" 就真的只是一种对逻辑概念的表述了。

对于该阶段，需要注意以下几点：

* 这时候进行内存分配的仅是类变量，实例变量是在对象实例化的时候随着对象一起分配在 Java 堆中。

* 通常情况，这里所说的初始值是数据类型的 "零值"（也就是默认值），而变量定义的赋值动作和静态语句块的赋值语句将在初始化类阶段才会被执行。

  还有一种特殊情况，如果是静态常量，且有初始值，编译时 `Javac` 将为该变量生成 `ConstantValue` 属性，属性值就是变量定义的值。在准备阶段虚拟就会根据 `ConstantValue` 属性为变量设置初始值。

### 解析

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。

* 符号引用：符号引用以一组符号来描述所引用的对象，符号可以是任何字面量。符号引用和虚拟机实现的内存布局无关，引用的目标不一定是已经加载到虚拟机内存当中的内容。
* 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

### 初始化

在准备阶段，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过编码指定的主观计划去初始化类变量和其它资源。直接的说，初始化阶段就是执行类构造器 `<clinit>()` 方法的过程。

`<clinit>()` 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。它的收集顺序是由语句在源文件中出现的顺序决定的。静态语句块中只能访问到定义在静态语句块之前的变量，对于定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。

## 类加载器

Java 虚拟机设计团队有意把类加载阶段中的 "通过一个类的全限定名获取定义此类的二进制字节流" 这个动作放到 Java 虚拟机外部去实现。以便让应用程序自己决定如何获取所需的类。实现这个动作的代码被称为 "类加载器"。

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。也就是说，要比较两个类是否相等，只有在这两个类都是由同一个类加载器加载的前提下才有意义。

### 双亲委派模型

自 JDK 1.2 以来，Java 一直保持着三层加载器、双亲委派的类加载架构。

除了启动类加载器，其它类加载器都是由 Java 代码实现，它们都继承自 `java.lang.ClassLoader`。

* 启动类加载器

  负责加载 Java 的核心类库，比如放在 `<Java_HOME>\lib` 目录，或者 `-Xbootclasspath` 参数指定的路径中的类库。启动类加载器使用 C++ 语言实现，是虚拟机自身的一部分，无法被 Java 程序直接使用，编写自定义类加载器时，如果需要把加载请求委托给启动类加载器去处理，直接使用 `null` 代替即可。

* 拓展类加载器

  负责加载 Java 的拓展类库，比如放在 `<Java_HOME>\lib\ext` 目录，或者 `java.ext.dirs` 系统变量指定的路径中的类库。拓展类加载器由 Java 代码实现，开发者可以直接在程序中使用它来加载 Class 文件。

* 应用程序类加载器（系统类加载器）

  由于应用程序类加载器是 `ClassLoader` 类中的 `getSystemClassLoader()` 方法的返回值，所以也称它为系统类加载器。它负责加载用户类路径上的所有类库，开发者同样可以在代码中使用这个类加载器。如果应用程序没有定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。

如果觉得有必要，还可以加入自定义的类加载器来进行拓展，典型的如增加除了磁盘位置之外的 Class 文件来源。这些类加载器之间的协作关系通常如下图所示：

![](https://images-1305875271.cos.ap-chengdu.myqcloud.com/java-810430ff.png)

**双亲委派模型**

类加载器的双亲委派模型在 JDK 1.2 被引入，并被广泛应用，但它并不是一个具有强制性约束力的模型，而是 Java 设计者们推荐给开发者的一种类加载器实现的最佳实践。类加载器将双亲委派的逻辑实现在 `loadClass()` 内。

双亲委派模型的 "继承" 关系不是通过 `extends` 来实现的，而是通过组合实现。

如果一个类加载器收到了加载类的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都会传送到顶层的启动类加载器，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

这种机制的好处是：Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系，从而确保类型在虚拟机中的唯一性，和保证 Java 程序的稳定运行。比如 `Object` 类，无论使用哪个类加载器加载它，最终都是由启动类加载器来加载。如果虚拟机中存在多个 `Object` 类型，那么应用程序将变得无比混乱。

> **Class.forName() 和 ClassLoader.loadClass() 的区别？**
>
> `ClassLoader.loadClass()` 只是将 Class 文件加载到 Java 虚拟机。
>
> `Class.forName()` 方法返回这个类型的 Class 对象，这说明该类型的信息都已经经过验证、准备、解析、初始化这些阶段，会执行类的静态语句块。

> **实例初始化过程**
>
> * 类加载父类型和当前类型。
> * 执行父类的变量初始化、代码块、构造器。
> * 执行当前类的变量初始化、代码块、构造器。

# Java 内存模型 JMM

## 高速缓存 CPU Cache

## 什么是 JMM？它的作用？

## 主内存与工作内存

## 内存间交互操作

## 先行发生原则 Happens-Before

## 原子性、可见性、有序性

## volatile 可见性、有序性

`volatile` 有两种作用：保证内存可见性和代码执行的有序性。

### 保证内存可见性

使用 `volatile` 修饰的变量，一个线程对它进行的修改，对其它线程是立即可见的。这是因为线程在每次使用 `volatile` 变量前都会先刷新缓存值，每次修改完 `volatile` 变量，都会立即将缓存值同步到主内存。所以各个线程看不到不一致的情况。

`volatile ` 不提供操作的原子性。当前操作的变量，随时都可以被其它线程修改，也很容易造成覆盖更新。

`volatile ` 适合修饰具有以下特性的变量：

* 运算结果不依赖于变量的当前值，或者能确保只有单一的线程修改变量的值。
* 不需要与其它的非 `volatile ` 变量共同使用。

### 保证有序性

使用 `volatile ` 的第二个语义是禁止指令重排序优化。普通变量仅会保证在代码的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，但不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是 Java 内存模型中描述的所谓 "线程内表现为串行的语义"。

双重验证单例模式就是这个语义的经典应用场景。

### 实现原理：内存屏障

观察编译后的字节码指令，会看到一些类似 `lock addl$0x0，(%esp)` 的指令，这就是内存屏障，它的作用是将本处理器的缓存写入内存，该写入动作也会引起别的处理器或内核无效化其缓存。通过这样一个操作，可让前面对 `volatile` 变量的修改对其它线程立即可见。

那它是怎么禁止指令重排序呢？从硬件架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。所以在同一个处理器中，重排序过的代码看起来依然是有序的。

`lock addl$0x0，(%esp)` 指令把修改同步到内存，这意味着在此之前的操作都已经完成，后面的指令不能重排序到内存屏障前面。它就像一堵墙，墙两边的代码都无法重排序到对面。

### 什么时候选用 volatile

`volatile` 能让我们的代码比使用其它的同步工具更快吗？在某些情况下，`volatile` 的同步机制的性能确实要优于锁（`synchronized`、`ReentrantLock`），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说 `volatile` 就会比 `synchronized` 快上多少。如果让 `volatile` 自己与自己比较，那可以确定一个原则：`volatile` 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令。不过即便如此，大多数场景下 `volatile` 的总开销仍然要比锁来得更低。我们在 `volatile` 与锁中选择的唯一判断依据仅仅是 `volatile` 的语义能否满足使用场景的需求。

## final 内存可见性

对于 `final` 字段，编译器和处理器要遵守两个重排序规则：

* `final` 字段写：在构造器内对一个 `final` 字段的写入，与随后在构造器外把这个被构造对象的引用赋给一个变量，这两个操作之间不能重排序。

* `final` 字段读：初次读一个包含 `final` 字段的对象的引用，与随后初次读这个 `final` 字段，这两个操作之间不能重排序。

针对 `final` 引用类型，也有一条重排序规则：

* `final` 引用类型：在构造器内对一个 `final` 引用类型的字段的写入，与随后在构造器外把这个被构造对象的引用赋给一个变量，这两个操作之间不能重排序。

这些规则与内存可见性有什么关系呢？

`final` 字段写规则保证在构造器中对 `final` 字段的赋值操作完成之前，其对外是不可获取的。等到其它线程能够通过 `this` 引用读 `final` 字段时，它已经完成初始化。前提是 `this` 引用没有逃逸，否则其它线程就可能读到未完成初始化的 `final` 字段。
